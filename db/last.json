[
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-03T17:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26779",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/76fad1174a0cae6fc857b9f88b261a2e4f07d587",
            "https://git.kernel.org/stable/c/85720b69aef177318f4a18efbcc4302228a340e5",
            "https://git.kernel.org/stable/c/5ffab99e070b9f8ae0cf60c3c3602b84eee818dd",
            "https://git.kernel.org/stable/c/88c18fd06608b3adee547102505d715f21075c9d",
            "https://git.kernel.org/stable/c/eb39bb548bf974acad7bd6780fe11f9e6652d696",
            "https://git.kernel.org/stable/c/54b79d8786964e2f840e8a2ec4a9f9a50f3d4954",
            "https://git.kernel.org/stable/c/281280276b70c822f55ce15b661f6d1d3228aaa9",
            "https://git.kernel.org/stable/c/bcbc84af1183c8cf3d1ca9b78540c2185cd85e7f",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mac80211: fix race condition on enabling fast-xmit\n\nfast-xmit must only be enabled after the sta has been uploaded to the driver,\notherwise it could end up passing the not-yet-uploaded sta via drv_tx calls\nto the driver, leading to potential crashes because of uninitialized drv_priv\ndata.\nAdd a missing sta->uploaded check and re-check fast xmit after inserting a sta."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-03T17:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26778",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/224453de8505aede1890f007be973925a3edf6a1",
            "https://git.kernel.org/stable/c/84dce0f6a4cc5b7bfd7242ef9290db8ac1dd77ff",
            "https://git.kernel.org/stable/c/512ee6d6041e007ef5bf200c6e388e172a2c5b24",
            "https://git.kernel.org/stable/c/8c54acf33e5adaad6374bf3ec1e3aff0591cc8e1",
            "https://git.kernel.org/stable/c/070398d32c5f3ab0e890374904ad94551c76aec4",
            "https://git.kernel.org/stable/c/bc3c2e58d73b28b9a8789fca84778ee165a72d13",
            "https://git.kernel.org/stable/c/a9ca4e80d23474f90841251f4ac0d941fa337a01",
            "https://git.kernel.org/stable/c/04e5eac8f3ab2ff52fa191c187a46d4fdbc1e288",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nfbdev: savage: Error out if pixclock equals zero\n\nThe userspace program could pass any values to the driver through\nioctl() interface. If the driver doesn't check the value of pixclock,\nit may cause divide-by-zero error.\n\nAlthough pixclock is checked in savagefb_decode_var(), but it is not\nchecked properly in savagefb_probe(). Fix this by checking whether\npixclock is zero in the function savagefb_check_var() before\ninfo->var.pixclock is used as the divisor.\n\nThis is similar to CVE-2022-3061 in i740fb which was fixed by\ncommit 15cf0b8."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-04T09:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26790",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/518d78b4fac68cac29a263554d7f3b19da99d0da",
            "https://git.kernel.org/stable/c/bb3a06e9b9a30e33d96aadc0e077be095a4f8580",
            "https://git.kernel.org/stable/c/106c1ac953a66556ec77456c46e818208d3a9bce",
            "https://git.kernel.org/stable/c/237ecf1afe6c22534fa43abdf2bf0b0f52de0aaa",
            "https://git.kernel.org/stable/c/5b696e9c388251f1c7373be92293769a489fd367",
            "https://git.kernel.org/stable/c/ad2f8920c314e0a2d9e984fc94b729eca3cda471",
            "https://git.kernel.org/stable/c/9d739bccf261dd93ec1babf82f5c5d71dd4caa3e",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndmaengine: fsl-qdma: fix SoC may hang on 16 byte unaligned read\n\nThere is chip (ls1028a) errata:\n\nThe SoC may hang on 16 byte unaligned read transactions by QDMA.\n\nUnaligned read transactions initiated by QDMA may stall in the NOC\n(Network On-Chip), causing a deadlock condition. Stalled transactions will\ntrigger completion timeouts in PCIe controller.\n\nWorkaround:\nEnable prefetch by setting the source descriptor prefetchable bit\n( SD[PF] = 1 ).\n\nImplement this workaround."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-03T17:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26766",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/115b7f3bc1dce590a6851a2dcf23dc1100c49790",
            "https://git.kernel.org/stable/c/5833024a9856f454a964a198c63a57e59e07baf5",
            "https://git.kernel.org/stable/c/3f38d22e645e2e994979426ea5a35186102ff3c2",
            "https://git.kernel.org/stable/c/47ae64df23ed1318e27bd9844e135a5e1c0e6e39",
            "https://git.kernel.org/stable/c/52dc9a7a573dbf778625a0efca0fca55489f084b",
            "https://git.kernel.org/stable/c/a2fef1d81becf4ff60e1a249477464eae3c3bc2a",
            "https://git.kernel.org/stable/c/9034a1bec35e9f725315a3bb6002ef39666114d9",
            "https://git.kernel.org/stable/c/e6f57c6881916df39db7d95981a8ad2b9c3458d6",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nIB/hfi1: Fix sdma.h tx->num_descs off-by-one error\n\nUnfortunately the commit `fd8958efe877` introduced another error\ncausing the `descs` array to overflow. This reults in further crashes\neasily reproducible by `sendmsg` system call.\n\n[ 1080.836473] general protection fault, probably for non-canonical address 0x400300015528b00a: 0000 [#1] PREEMPT SMP PTI\n[ 1080.869326] RIP: 0010:hfi1_ipoib_build_ib_tx_headers.constprop.0+0xe1/0x2b0 [hfi1]\n--\n[ 1080.974535] Call Trace:\n[ 1080.976990]  <TASK>\n[ 1081.021929]  hfi1_ipoib_send_dma_common+0x7a/0x2e0 [hfi1]\n[ 1081.027364]  hfi1_ipoib_send_dma_list+0x62/0x270 [hfi1]\n[ 1081.032633]  hfi1_ipoib_send+0x112/0x300 [hfi1]\n[ 1081.042001]  ipoib_start_xmit+0x2a9/0x2d0 [ib_ipoib]\n[ 1081.046978]  dev_hard_start_xmit+0xc4/0x210\n--\n[ 1081.148347]  __sys_sendmsg+0x59/0xa0\n\ncrash> ipoib_txreq 0xffff9cfeba229f00\nstruct ipoib_txreq {\n  txreq = {\n    list = {\n      next = 0xffff9cfeba229f00,\n      prev = 0xffff9cfeba229f00\n    },\n    descp = 0xffff9cfeba229f40,\n    coalesce_buf = 0x0,\n    wait = 0xffff9cfea4e69a48,\n    complete = 0xffffffffc0fe0760 <hfi1_ipoib_sdma_complete>,\n    packet_len = 0x46d,\n    tlen = 0x0,\n    num_desc = 0x0,\n    desc_limit = 0x6,\n    next_descq_idx = 0x45c,\n    coalesce_idx = 0x0,\n    flags = 0x0,\n    descs = {{\n        qw = {0x8024000120dffb00, 0x4}  # SDMA_DESC0_FIRST_DESC_FLAG (bit 63)\n      }, {\n        qw = {  0x3800014231b108, 0x4}\n      }, {\n        qw = { 0x310000e4ee0fcf0, 0x8}\n      }, {\n        qw = {  0x3000012e9f8000, 0x8}\n      }, {\n        qw = {  0x59000dfb9d0000, 0x8}\n      }, {\n        qw = {  0x78000e02e40000, 0x8}\n      }}\n  },\n  sdma_hdr =  0x400300015528b000,  <<< invalid pointer in the tx request structure\n  sdma_status = 0x0,                   SDMA_DESC0_LAST_DESC_FLAG (bit 62)\n  complete = 0x0,\n  priv = 0x0,\n  txq = 0xffff9cfea4e69880,\n  skb = 0xffff9d099809f400\n}\n\nIf an SDMA send consists of exactly 6 descriptors and requires dword\npadding (in the 7th descriptor), the sdma_txreq descriptor array is not\nproperly expanded and the packet will overflow into the container\nstructure. This results in a panic when the send completion runs. The\nexact panic varies depending on what elements of the container structure\nget corrupted. The fix is to use the correct expression in\n_pad_sdma_tx_descs() to test the need to expand the descriptor array.\n\nWith this patch the crashes are no longer reproducible and the machine is\nstable."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-04T10:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26809",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/b36b83297ff4910dfc8705402c8abffd4bbf8144",
            "https://git.kernel.org/stable/c/362508506bf545e9ce18c72a2c48dcbfb891ab9c",
            "https://git.kernel.org/stable/c/5ad233dc731ab64cdc47b84a5c1f78fff6c024af",
            "https://git.kernel.org/stable/c/ff90050771412b91e928093ccd8736ae680063c2",
            "https://git.kernel.org/stable/c/821e28d5b506e6a73ccc367ff792bd894050d48b",
            "https://git.kernel.org/stable/c/9384b4d85c46ce839f51af01374062ce6318b2f2",
            "https://git.kernel.org/stable/c/b0e256f3dd2ba6532f37c5c22e07cb07a36031ee",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nft_set_pipapo: release elements in clone only from destroy path\n\nClone already always provides a current view of the lookup table, use it\nto destroy the set, otherwise it is possible to destroy elements twice.\n\nThis fix requires:\n\n 212ed75dc5fb (\"netfilter: nf_tables: integrate pipapo into commit protocol\")\n\nwhich came after:\n\n 9827a0e6e23b (\"netfilter: nft_set_pipapo: release elements in clone from abort path\")."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-03T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26696",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/228742b2ddfb99dfd71e5a307e6088ab6836272e",
            "https://git.kernel.org/stable/c/862ee4422c38be5c249844a684b00d0dbe9d1e46",
            "https://git.kernel.org/stable/c/98a4026b22ff440c7f47056481bcbbe442f607d6",
            "https://git.kernel.org/stable/c/7e9b622bd0748cc104d66535b76d9b3535f9dc0f",
            "https://git.kernel.org/stable/c/8494ba2c9ea00a54d5b50e69b22c55a8958bce32",
            "https://git.kernel.org/stable/c/ea5ddbc11613b55e5128c85f57b08f907abd9b28",
            "https://git.kernel.org/stable/c/e38585401d464578d30f5868ff4ca54475c34f7d",
            "https://git.kernel.org/stable/c/38296afe3c6ee07319e01bb249aa4bb47c07b534",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnilfs2: fix hang in nilfs_lookup_dirty_data_buffers()\n\nSyzbot reported a hang issue in migrate_pages_batch() called by mbind()\nand nilfs_lookup_dirty_data_buffers() called in the log writer of nilfs2.\n\nWhile migrate_pages_batch() locks a folio and waits for the writeback to\ncomplete, the log writer thread that should bring the writeback to\ncompletion picks up the folio being written back in\nnilfs_lookup_dirty_data_buffers() that it calls for subsequent log\ncreation and was trying to lock the folio.  Thus causing a deadlock.\n\nIn the first place, it is unexpected that folios/pages in the middle of\nwriteback will be updated and become dirty.  Nilfs2 adds a checksum to\nverify the validity of the log being written and uses it for recovery at\nmount, so data changes during writeback are suppressed.  Since this is\nbroken, an unclean shutdown could potentially cause recovery to fail.\n\nInvestigation revealed that the root cause is that the wait for writeback\ncompletion in nilfs_page_mkwrite() is conditional, and if the backing\ndevice does not require stable writes, data may be modified without\nwaiting.\n\nFix these issues by making nilfs_page_mkwrite() wait for writeback to\nfinish regardless of the stable write requirement of the backing device."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-03T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26704",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/b4fbb89d722cbb16beaaea234b7230faaaf68c71",
            "https://git.kernel.org/stable/c/afbcad9ae7d6d11608399188f03a837451b6b3a1",
            "https://git.kernel.org/stable/c/d033a555d9a1cf53dbf3301af7199cc4a4c8f537",
            "https://git.kernel.org/stable/c/afba9d11320dad5ce222ac8964caf64b7b4bedb1",
            "https://git.kernel.org/stable/c/185eab30486ba3e7bf8b9c2e049c79a06ffd2bc1",
            "https://git.kernel.org/stable/c/2883940b19c38d5884c8626483811acf4d7e148f",
            "https://git.kernel.org/stable/c/559ddacb90da1d8786dd8ec4fd76bbfa404eaef6",
            "https://git.kernel.org/stable/c/55583e899a5357308274601364741a83e78d6ac4",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix double-free of blocks due to wrong extents moved_len\n\nIn ext4_move_extents(), moved_len is only updated when all moves are\nsuccessfully executed, and only discards orig_inode and donor_inode\npreallocations when moved_len is not zero. When the loop fails to exit\nafter successfully moving some extents, moved_len is not updated and\nremains at 0, so it does not discard the preallocations.\n\nIf the moved extents overlap with the preallocated extents, the\noverlapped extents are freed twice in ext4_mb_release_inode_pa() and\next4_process_freed_data() (as described in commit 94d7c16cbbbd (\"ext4:\nFix double-free of blocks with EXT4_IOC_MOVE_EXT\")), and bb_free is\nincremented twice. Hence when trim is executed, a zero-division bug is\ntriggered in mb_update_avg_fragment_size() because bb_free is not zero\nand bb_fragments is zero.\n\nTherefore, update move_len after each extent move to avoid the issue."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-03T17:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26733",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/dbc9b22d0ed319b4e29034ce0a3fe32a3ee2c587",
            "https://git.kernel.org/stable/c/97eaa2955db4120ce6ec2ef123e860bc32232c50",
            "https://git.kernel.org/stable/c/f119f2325ba70cbfdec701000dcad4d88805d5b0",
            "https://git.kernel.org/stable/c/a3f2c083cb575d80a7627baf3339e78fedccbb91",
            "https://git.kernel.org/stable/c/3ab0d6f8289ba8402ca95a9fc61a34909d5e1f3a",
            "https://git.kernel.org/stable/c/a7d6027790acea24446ddd6632d394096c0f4667",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\narp: Prevent overflow in arp_req_get().\n\nsyzkaller reported an overflown write in arp_req_get(). [0]\n\nWhen ioctl(SIOCGARP) is issued, arp_req_get() looks up an neighbour\nentry and copies neigh->ha to struct arpreq.arp_ha.sa_data.\n\nThe arp_ha here is struct sockaddr, not struct sockaddr_storage, so\nthe sa_data buffer is just 14 bytes.\n\nIn the splat below, 2 bytes are overflown to the next int field,\narp_flags.  We initialise the field just after the memcpy(), so it's\nnot a problem.\n\nHowever, when dev->addr_len is greater than 22 (e.g. MAX_ADDR_LEN),\narp_netmask is overwritten, which could be set as htonl(0xFFFFFFFFUL)\nin arp_ioctl() before calling arp_req_get().\n\nTo avoid the overflow, let's limit the max length of memcpy().\n\nNote that commit b5f0de6df6dc (\"net: dev: Convert sa_data to flexible\narray in struct sockaddr\") just silenced syzkaller.\n\n[0]:\nmemcpy: detected field-spanning write (size 16) of single field \"r->arp_ha.sa_data\" at net/ipv4/arp.c:1128 (size 14)\nWARNING: CPU: 0 PID: 144638 at net/ipv4/arp.c:1128 arp_req_get+0x411/0x4a0 net/ipv4/arp.c:1128\nModules linked in:\nCPU: 0 PID: 144638 Comm: syz-executor.4 Not tainted 6.1.74 #31\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.0-debian-1.16.0-5 04/01/2014\nRIP: 0010:arp_req_get+0x411/0x4a0 net/ipv4/arp.c:1128\nCode: fd ff ff e8 41 42 de fb b9 0e 00 00 00 4c 89 fe 48 c7 c2 20 6d ab 87 48 c7 c7 80 6d ab 87 c6 05 25 af 72 04 01 e8 5f 8d ad fb <0f> 0b e9 6c fd ff ff e8 13 42 de fb be 03 00 00 00 4c 89 e7 e8 a6\nRSP: 0018:ffffc900050b7998 EFLAGS: 00010286\nRAX: 0000000000000000 RBX: ffff88803a815000 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: ffffffff8641a44a RDI: 0000000000000001\nRBP: ffffc900050b7a98 R08: 0000000000000001 R09: 0000000000000000\nR10: 0000000000000000 R11: 203a7970636d656d R12: ffff888039c54000\nR13: 1ffff92000a16f37 R14: ffff88803a815084 R15: 0000000000000010\nFS:  00007f172bf306c0(0000) GS:ffff88805aa00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f172b3569f0 CR3: 0000000057f12005 CR4: 0000000000770ef0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nPKRU: 55555554\nCall Trace:\n <TASK>\n arp_ioctl+0x33f/0x4b0 net/ipv4/arp.c:1261\n inet_ioctl+0x314/0x3a0 net/ipv4/af_inet.c:981\n sock_do_ioctl+0xdf/0x260 net/socket.c:1204\n sock_ioctl+0x3ef/0x650 net/socket.c:1321\n vfs_ioctl fs/ioctl.c:51 [inline]\n __do_sys_ioctl fs/ioctl.c:870 [inline]\n __se_sys_ioctl fs/ioctl.c:856 [inline]\n __x64_sys_ioctl+0x18e/0x220 fs/ioctl.c:856\n do_syscall_x64 arch/x86/entry/common.c:51 [inline]\n do_syscall_64+0x37/0x90 arch/x86/entry/common.c:81\n entry_SYSCALL_64_after_hwframe+0x64/0xce\nRIP: 0033:0x7f172b262b8d\nCode: 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f172bf300b8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 00007f172b3abf80 RCX: 00007f172b262b8d\nRDX: 0000000020000000 RSI: 0000000000008954 RDI: 0000000000000003\nRBP: 00007f172b2d3493 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 000000000000000b R14: 00007f172b3abf80 R15: 00007f172bf10000\n </TASK>"
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-03T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26712",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/230e89b5ad0a33f530a2a976b3e5e4385cb27882",
            "https://git.kernel.org/stable/c/2738e0aa2fb24a7ab9c878d912dc2b239738c6c6",
            "https://git.kernel.org/stable/c/0c09912dd8387e228afcc5e34ac5d79b1e3a1058",
            "https://git.kernel.org/stable/c/0516c06b19dc64807c10e01bb99b552bdf2d7dbe",
            "https://git.kernel.org/stable/c/70ef2ba1f4286b2b73675aeb424b590c92d57b25",
            "https://git.kernel.org/stable/c/4a7aee96200ad281a5cc4cf5c7a2e2a49d2b97b0",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/kasan: Fix addr error caused by page alignment\n\nIn kasan_init_region, when k_start is not page aligned, at the begin of\nfor loop, k_cur = k_start & PAGE_MASK is less than k_start, and then\n`va = block + k_cur - k_start` is less than block, the addr va is invalid,\nbecause the memory address space from va to block is not alloced by\nmemblock_alloc, which will not be reserved by memblock_reserve later, it\nwill be used by other places.\n\nAs a result, memory overwriting occurs.\n\nfor example:\nint __init __weak kasan_init_region(void *start, size_t size)\n{\n[...]\n\t/* if say block(dcd97000) k_start(feef7400) k_end(feeff3fe) */\n\tblock = memblock_alloc(k_end - k_start, PAGE_SIZE);\n\t[...]\n\tfor (k_cur = k_start & PAGE_MASK; k_cur < k_end; k_cur += PAGE_SIZE) {\n\t\t/* at the begin of for loop\n\t\t * block(dcd97000) va(dcd96c00) k_cur(feef7000) k_start(feef7400)\n\t\t * va(dcd96c00) is less than block(dcd97000), va is invalid\n\t\t */\n\t\tvoid *va = block + k_cur - k_start;\n\t\t[...]\n\t}\n[...]\n}\n\nTherefore, page alignment is performed on k_start before\nmemblock_alloc() to ensure the validity of the VA address."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-03T17:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26763",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/43a202bd552976497474ae144942e32cc5f34d7e",
            "https://git.kernel.org/stable/c/0dccbb93538fe89a86c6de31d4b1c8c560848eaa",
            "https://git.kernel.org/stable/c/3c652f6fa1e1f9f02c3fbf359d260ad153ec5f90",
            "https://git.kernel.org/stable/c/1a4371db68a31076afbe56ecce34fbbe6c80c529",
            "https://git.kernel.org/stable/c/e08c2a8d27e989f0f5b0888792643027d7e691e6",
            "https://git.kernel.org/stable/c/64ba01a365980755732972523600a961c4266b75",
            "https://git.kernel.org/stable/c/d9e3763a505e50ba3bd22846f2a8db99429fb857",
            "https://git.kernel.org/stable/c/50c70240097ce41fe6bce6478b80478281e4d0f7",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndm-crypt: don't modify the data when using authenticated encryption\n\nIt was said that authenticated encryption could produce invalid tag when\nthe data that is being encrypted is modified [1]. So, fix this problem by\ncopying the data into the clone bio first and then encrypt them inside the\nclone bio.\n\nThis may reduce performance, but it is needed to prevent the user from\ncorrupting the device by writing data with O_DIRECT and modifying them at\nthe same time.\n\n[1] https://lore.kernel.org/all/20240207004723.GA35324@sol.localdomain/T/"
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-02T07:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26663",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/24ec8f0da93b8a9fba11600be8a90f0d73fb46f1",
            "https://git.kernel.org/stable/c/6f70f0b412458c622a12d4292782c8e92e210c2f",
            "https://git.kernel.org/stable/c/19d7314f2fb9515bdaac9829d4d8eb34edd1fe95",
            "https://git.kernel.org/stable/c/c1701ea85ef0ec7be6a1b36c7da69f572ed2fd12",
            "https://git.kernel.org/stable/c/3d3a5b31b43515b5752ff282702ca546ec3e48b6",
            "https://git.kernel.org/stable/c/888e3524be87f3df9fa3c083484e4b62b3e3bb59",
            "https://git.kernel.org/stable/c/0cd331dfd6023640c9669d0592bc0fd491205f87",
            "https://git.kernel.org/stable/c/3871aa01e1a779d866fa9dfdd5a836f342f4eb87",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ntipc: Check the bearer type before calling tipc_udp_nl_bearer_add()\n\nsyzbot reported the following general protection fault [1]:\n\ngeneral protection fault, probably for non-canonical address 0xdffffc0000000010: 0000 [#1] PREEMPT SMP KASAN\nKASAN: null-ptr-deref in range [0x0000000000000080-0x0000000000000087]\n...\nRIP: 0010:tipc_udp_is_known_peer+0x9c/0x250 net/tipc/udp_media.c:291\n...\nCall Trace:\n <TASK>\n tipc_udp_nl_bearer_add+0x212/0x2f0 net/tipc/udp_media.c:646\n tipc_nl_bearer_add+0x21e/0x360 net/tipc/bearer.c:1089\n genl_family_rcv_msg_doit+0x1fc/0x2e0 net/netlink/genetlink.c:972\n genl_family_rcv_msg net/netlink/genetlink.c:1052 [inline]\n genl_rcv_msg+0x561/0x800 net/netlink/genetlink.c:1067\n netlink_rcv_skb+0x16b/0x440 net/netlink/af_netlink.c:2544\n genl_rcv+0x28/0x40 net/netlink/genetlink.c:1076\n netlink_unicast_kernel net/netlink/af_netlink.c:1341 [inline]\n netlink_unicast+0x53b/0x810 net/netlink/af_netlink.c:1367\n netlink_sendmsg+0x8b7/0xd70 net/netlink/af_netlink.c:1909\n sock_sendmsg_nosec net/socket.c:730 [inline]\n __sock_sendmsg+0xd5/0x180 net/socket.c:745\n ____sys_sendmsg+0x6ac/0x940 net/socket.c:2584\n ___sys_sendmsg+0x135/0x1d0 net/socket.c:2638\n __sys_sendmsg+0x117/0x1e0 net/socket.c:2667\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0x40/0x110 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x63/0x6b\n\nThe cause of this issue is that when tipc_nl_bearer_add() is called with\nthe TIPC_NLA_BEARER_UDP_OPTS attribute, tipc_udp_nl_bearer_add() is called\neven if the bearer is not UDP.\n\ntipc_udp_is_known_peer() called by tipc_udp_nl_bearer_add() assumes that\nthe media_ptr field of the tipc_bearer has an udp_bearer type object, so\nthe function goes crazy for non-UDP bearers.\n\nThis patch fixes the issue by checking the bearer type before calling\ntipc_udp_nl_bearer_add() in tipc_nl_bearer_add()."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-04T09:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26791",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/11d7a2e429c02d51e2dc90713823ea8b8d3d3a84",
            "https://git.kernel.org/stable/c/c6652e20d7d783d060fe5f987eac7b5cabe31311",
            "https://git.kernel.org/stable/c/2886fe308a83968dde252302884a1e63351cf16d",
            "https://git.kernel.org/stable/c/ab2d68655d0f04650bef09fee948ff80597c5fb9",
            "https://git.kernel.org/stable/c/f590040ce2b712177306b03c2a63b16f7d48d3c8",
            "https://git.kernel.org/stable/c/b1690ced4d2d8b28868811fb81cd33eee5aefee1",
            "https://git.kernel.org/stable/c/343eecb4ff49a7b1cc1dfe86958a805cf2341cfb",
            "https://git.kernel.org/stable/c/9845664b9ee47ce7ee7ea93caf47d39a9d4552c4",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: dev-replace: properly validate device names\n\nThere's a syzbot report that device name buffers passed to device\nreplace are not properly checked for string termination which could lead\nto a read out of bounds in getname_kernel().\n\nAdd a helper that validates both source and target device name buffers.\nFor devid as the source initialize the buffer to empty string in case\nsomething tries to read it later.\n\nThis was originally analyzed and fixed in a different way by Edward Adam\nDavis (see links)."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-04T09:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26805",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/ec343a55b687a452f5e87f3b52bf9f155864df65",
            "https://git.kernel.org/stable/c/9ae51361da43270f4ba0eb924427a07e87e48777",
            "https://git.kernel.org/stable/c/f19d1f98e60e68b11fc60839105dd02a30ec0d77",
            "https://git.kernel.org/stable/c/c71ed29d15b1a1ed6c464f8c3536996963046285",
            "https://git.kernel.org/stable/c/0b27bf4c494d61e5663baa34c3edd7ccebf0ea44",
            "https://git.kernel.org/stable/c/d3ada42e534a83b618bbc1e490d23bf0fdae4736",
            "https://git.kernel.org/stable/c/59fc3e3d049e39e7d0d271f20dd5fb47c57faf1d",
            "https://git.kernel.org/stable/c/661779e1fcafe1b74b3f3fe8e980c1e207fea1fd",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetlink: Fix kernel-infoleak-after-free in __skb_datagram_iter\n\nsyzbot reported the following uninit-value access issue [1]:\n\nnetlink_to_full_skb() creates a new `skb` and puts the `skb->data`\npassed as a 1st arg of netlink_to_full_skb() onto new `skb`. The data\nsize is specified as `len` and passed to skb_put_data(). This `len`\nis based on `skb->end` that is not data offset but buffer offset. The\n`skb->end` contains data and tailroom. Since the tailroom is not\ninitialized when the new `skb` created, KMSAN detects uninitialized\nmemory area when copying the data.\n\nThis patch resolved this issue by correct the len from `skb->end` to\n`skb->len`, which is the actual data offset.\n\nBUG: KMSAN: kernel-infoleak-after-free in instrument_copy_to_user include/linux/instrumented.h:114 [inline]\nBUG: KMSAN: kernel-infoleak-after-free in copy_to_user_iter lib/iov_iter.c:24 [inline]\nBUG: KMSAN: kernel-infoleak-after-free in iterate_ubuf include/linux/iov_iter.h:29 [inline]\nBUG: KMSAN: kernel-infoleak-after-free in iterate_and_advance2 include/linux/iov_iter.h:245 [inline]\nBUG: KMSAN: kernel-infoleak-after-free in iterate_and_advance include/linux/iov_iter.h:271 [inline]\nBUG: KMSAN: kernel-infoleak-after-free in _copy_to_iter+0x364/0x2520 lib/iov_iter.c:186\n instrument_copy_to_user include/linux/instrumented.h:114 [inline]\n copy_to_user_iter lib/iov_iter.c:24 [inline]\n iterate_ubuf include/linux/iov_iter.h:29 [inline]\n iterate_and_advance2 include/linux/iov_iter.h:245 [inline]\n iterate_and_advance include/linux/iov_iter.h:271 [inline]\n _copy_to_iter+0x364/0x2520 lib/iov_iter.c:186\n copy_to_iter include/linux/uio.h:197 [inline]\n simple_copy_to_iter+0x68/0xa0 net/core/datagram.c:532\n __skb_datagram_iter+0x123/0xdc0 net/core/datagram.c:420\n skb_copy_datagram_iter+0x5c/0x200 net/core/datagram.c:546\n skb_copy_datagram_msg include/linux/skbuff.h:3960 [inline]\n packet_recvmsg+0xd9c/0x2000 net/packet/af_packet.c:3482\n sock_recvmsg_nosec net/socket.c:1044 [inline]\n sock_recvmsg net/socket.c:1066 [inline]\n sock_read_iter+0x467/0x580 net/socket.c:1136\n call_read_iter include/linux/fs.h:2014 [inline]\n new_sync_read fs/read_write.c:389 [inline]\n vfs_read+0x8f6/0xe00 fs/read_write.c:470\n ksys_read+0x20f/0x4c0 fs/read_write.c:613\n __do_sys_read fs/read_write.c:623 [inline]\n __se_sys_read fs/read_write.c:621 [inline]\n __x64_sys_read+0x93/0xd0 fs/read_write.c:621\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0x44/0x110 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x63/0x6b\n\nUninit was stored to memory at:\n skb_put_data include/linux/skbuff.h:2622 [inline]\n netlink_to_full_skb net/netlink/af_netlink.c:181 [inline]\n __netlink_deliver_tap_skb net/netlink/af_netlink.c:298 [inline]\n __netlink_deliver_tap+0x5be/0xc90 net/netlink/af_netlink.c:325\n netlink_deliver_tap net/netlink/af_netlink.c:338 [inline]\n netlink_deliver_tap_kernel net/netlink/af_netlink.c:347 [inline]\n netlink_unicast_kernel net/netlink/af_netlink.c:1341 [inline]\n netlink_unicast+0x10f1/0x1250 net/netlink/af_netlink.c:1368\n netlink_sendmsg+0x1238/0x13d0 net/netlink/af_netlink.c:1910\n sock_sendmsg_nosec net/socket.c:730 [inline]\n __sock_sendmsg net/socket.c:745 [inline]\n ____sys_sendmsg+0x9c2/0xd60 net/socket.c:2584\n ___sys_sendmsg+0x28d/0x3c0 net/socket.c:2638\n __sys_sendmsg net/socket.c:2667 [inline]\n __do_sys_sendmsg net/socket.c:2676 [inline]\n __se_sys_sendmsg net/socket.c:2674 [inline]\n __x64_sys_sendmsg+0x307/0x490 net/socket.c:2674\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0x44/0x110 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x63/0x6b\n\nUninit was created at:\n free_pages_prepare mm/page_alloc.c:1087 [inline]\n free_unref_page_prepare+0xb0/0xa40 mm/page_alloc.c:2347\n free_unref_page_list+0xeb/0x1100 mm/page_alloc.c:2533\n release_pages+0x23d3/0x2410 mm/swap.c:1042\n free_pages_and_swap_cache+0xd9/0xf0 mm/swap_state.c:316\n tlb_batch_pages\n---truncated---"
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-30T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-36020",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/cc9cd02dd9e8b7764ea9effb24f4f1dd73d1b23d",
            "https://git.kernel.org/stable/c/9dcf0fcb80f6aeb01469e3c957f8d4c97365450a",
            "https://git.kernel.org/stable/c/b8e82128b44fa40bf99a50b919488ef361e1683c",
            "https://git.kernel.org/stable/c/951d2748a2a8242853abc3d0c153ce4bf8faad31",
            "https://git.kernel.org/stable/c/3e89846283f3cf7c7a8e28b342576fd7c561d2ba",
            "https://git.kernel.org/stable/c/0dcf573f997732702917af1563aa2493dc772fc0",
            "https://git.kernel.org/stable/c/06df7618f591b2dc43c59967e294d7b9fc8675b6",
            "https://git.kernel.org/stable/c/f37c4eac99c258111d414d31b740437e1925b8e8",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ni40e: fix vf may be used uninitialized in this function warning\n\nTo fix the regression introduced by commit 52424f974bc5, which causes\nservers hang in very hard to reproduce conditions with resets races.\nUsing two sources for the information is the root cause.\nIn this function before the fix bumping v didn't mean bumping vf\npointer. But the code used this variables interchangeably, so stale vf\ncould point to different/not intended vf.\n\nRemove redundant \"v\" variable and iterate via single VF pointer across\nwhole function instead to guarantee VF pointer validity."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-20T10:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-35973",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/43be590456e1f3566054ce78ae2dbb68cbe1a536",
            "https://git.kernel.org/stable/c/d3adf11d7993518a39bd02b383cfe657ccc0023c",
            "https://git.kernel.org/stable/c/10204df9beda4978bd1d0c2db0d8375bfb03b915",
            "https://git.kernel.org/stable/c/3c1ae6de74e3d2d6333d29a2d3e13e6094596c79",
            "https://git.kernel.org/stable/c/4a1b65d1e55d53b397cb27014208be1e04172670",
            "https://git.kernel.org/stable/c/190d9efa5773f26d6f334b1b8be282c4fa13fd5e",
            "https://git.kernel.org/stable/c/357163fff3a6e48fe74745425a32071ec9caf852",
            "https://git.kernel.org/stable/c/d8a6213d70accb403b82924a1c229e733433a5ef",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ngeneve: fix header validation in geneve[6]_xmit_skb\n\nsyzbot is able to trigger an uninit-value in geneve_xmit() [1]\n\nProblem : While most ip tunnel helpers (like ip_tunnel_get_dsfield())\nuses skb_protocol(skb, true), pskb_inet_may_pull() is only using\nskb->protocol.\n\nIf anything else than ETH_P_IPV6 or ETH_P_IP is found in skb->protocol,\npskb_inet_may_pull() does nothing at all.\n\nIf a vlan tag was provided by the caller (af_packet in the syzbot case),\nthe network header might not point to the correct location, and skb\nlinear part could be smaller than expected.\n\nAdd skb_vlan_inet_prepare() to perform a complete mac validation.\n\nUse this in geneve for the moment, I suspect we need to adopt this\nmore broadly.\n\nv4 - Jakub reported v3 broke l2_tos_ttl_inherit.sh selftest\n   - Only call __vlan_get_protocol() for vlan types.\n\nv2,v3 - Addressed Sabrina comments on v1 and v2\n\n[1]\n\nBUG: KMSAN: uninit-value in geneve_xmit_skb drivers/net/geneve.c:910 [inline]\n BUG: KMSAN: uninit-value in geneve_xmit+0x302d/0x5420 drivers/net/geneve.c:1030\n  geneve_xmit_skb drivers/net/geneve.c:910 [inline]\n  geneve_xmit+0x302d/0x5420 drivers/net/geneve.c:1030\n  __netdev_start_xmit include/linux/netdevice.h:4903 [inline]\n  netdev_start_xmit include/linux/netdevice.h:4917 [inline]\n  xmit_one net/core/dev.c:3531 [inline]\n  dev_hard_start_xmit+0x247/0xa20 net/core/dev.c:3547\n  __dev_queue_xmit+0x348d/0x52c0 net/core/dev.c:4335\n  dev_queue_xmit include/linux/netdevice.h:3091 [inline]\n  packet_xmit+0x9c/0x6c0 net/packet/af_packet.c:276\n  packet_snd net/packet/af_packet.c:3081 [inline]\n  packet_sendmsg+0x8bb0/0x9ef0 net/packet/af_packet.c:3113\n  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:745\n  __sys_sendto+0x685/0x830 net/socket.c:2191\n  __do_sys_sendto net/socket.c:2203 [inline]\n  __se_sys_sendto net/socket.c:2199 [inline]\n  __x64_sys_sendto+0x125/0x1d0 net/socket.c:2199\n do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\nUninit was created at:\n  slab_post_alloc_hook mm/slub.c:3804 [inline]\n  slab_alloc_node mm/slub.c:3845 [inline]\n  kmem_cache_alloc_node+0x613/0xc50 mm/slub.c:3888\n  kmalloc_reserve+0x13d/0x4a0 net/core/skbuff.c:577\n  __alloc_skb+0x35b/0x7a0 net/core/skbuff.c:668\n  alloc_skb include/linux/skbuff.h:1318 [inline]\n  alloc_skb_with_frags+0xc8/0xbf0 net/core/skbuff.c:6504\n  sock_alloc_send_pskb+0xa81/0xbf0 net/core/sock.c:2795\n  packet_alloc_skb net/packet/af_packet.c:2930 [inline]\n  packet_snd net/packet/af_packet.c:3024 [inline]\n  packet_sendmsg+0x722d/0x9ef0 net/packet/af_packet.c:3113\n  sock_sendmsg_nosec net/socket.c:730 [inline]\n  __sock_sendmsg+0x30f/0x380 net/socket.c:745\n  __sys_sendto+0x685/0x830 net/socket.c:2191\n  __do_sys_sendto net/socket.c:2203 [inline]\n  __se_sys_sendto net/socket.c:2199 [inline]\n  __x64_sys_sendto+0x125/0x1d0 net/socket.c:2199\n do_syscall_64+0xd5/0x1f0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\nCPU: 0 PID: 5033 Comm: syz-executor346 Not tainted 6.9.0-rc1-syzkaller-00005-g928a87efa423 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 02/29/2024"
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-20T10:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-35983",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/d34a516f2635090d36a306f84573e8de3d7374ce",
            "https://git.kernel.org/stable/c/66297b2ceda841f809637731d287bda3a93b49d8",
            "https://git.kernel.org/stable/c/93ba36238db6a74a82feb3dc476e25ea424ad630",
            "https://git.kernel.org/stable/c/9b7c5004d7c5ae062134052a85290869a015814c",
            "https://git.kernel.org/stable/c/15aa09d6d84629eb5296de30ac0aa19a33512f16",
            "https://git.kernel.org/stable/c/ebfe41889b762f1933c6762f6624b9724a25bee0",
            "https://git.kernel.org/stable/c/5af385f5f4cddf908f663974847a4083b2ff2c79",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nbounds: Use the right number of bits for power-of-two CONFIG_NR_CPUS\n\nbits_per() rounds up to the next power of two when passed a power of\ntwo.  This causes crashes on some machines and configurations."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-20T10:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "CWE-667",
        "id": "CVE-2024-35997",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/21bfca822cfc1e71796124e93b46e0d9fa584401",
            "https://git.kernel.org/stable/c/c448a9fd50f77e8fb9156ff64848aa4295eb3003",
            "https://git.kernel.org/stable/c/5095b93021b899f54c9355bebf36d78854c33a22",
            "https://git.kernel.org/stable/c/b65fb50e04a95eec34a9d1bc138454a98a5578d8",
            "https://git.kernel.org/stable/c/0561b65fbd53d3e788c5b0222d9112ca016fd6a1",
            "https://git.kernel.org/stable/c/29e94f295bad5be59cf4271a93e22cdcf5536722",
            "https://git.kernel.org/stable/c/418c5575d56410c6e186ab727bf32ae32447d497",
            "https://git.kernel.org/stable/c/9c0f59e47a90c54d0153f8ddc0f80d7a36207d0e",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nHID: i2c-hid: remove I2C_HID_READ_PENDING flag to prevent lock-up\n\nThe flag I2C_HID_READ_PENDING is used to serialize I2C operations.\nHowever, this is not necessary, because I2C core already has its own\nlocking for that.\n\nMore importantly, this flag can cause a lock-up: if the flag is set in\ni2c_hid_xfer() and an interrupt happens, the interrupt handler\n(i2c_hid_irq) will check this flag and return immediately without doing\nanything, then the interrupt handler will be invoked again in an\ninfinite loop.\n\nSince interrupt handler is an RT task, it takes over the CPU and the\nflag-clearing task never gets scheduled, thus we have a lock-up.\n\nDelete this unnecessary flag."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-20T10:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "CWE-835",
        "id": "CVE-2024-35982",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/04720ea2e6c64459a90ca28570ea78335eccd924",
            "https://git.kernel.org/stable/c/b3ddf6904073990492454b1dd1c10a24be8c74c6",
            "https://git.kernel.org/stable/c/70a8be9dc2fb65d67f8c1e0c88c587e08e2e575d",
            "https://git.kernel.org/stable/c/87b6af1a7683e021710c08fc0551fc078346032f",
            "https://git.kernel.org/stable/c/3fe79b2c83461edbbf86ed8a6f3924820ff89259",
            "https://git.kernel.org/stable/c/4ca2a5fb54ea2cc43edea614207fcede562d91c2",
            "https://git.kernel.org/stable/c/ca54e2671548616ad34885f90d4f26f7adb088f0",
            "https://git.kernel.org/stable/c/b1f532a3b1e6d2e5559c7ace49322922637a28aa",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nbatman-adv: Avoid infinite loop trying to resize local TT\n\nIf the MTU of one of an attached interface becomes too small to transmit\nthe local translation table then it must be resized to fit inside all\nfragments (when enabled) or a single packet.\n\nBut if the MTU becomes too low to transmit even the header + the VLAN\nspecific part then the resizing of the local TT will never succeed. This\ncan for example happen when the usable space is 110 bytes and 11 VLANs are\non top of batman-adv. In this case, at least 116 byte would be needed.\nThere will just be an endless spam of\n\n   batman_adv: batadv0: Forced to purge local tt entries to fit new maximum fragment MTU (110)\n\nin the log but the function will never finish. Problem here is that the\ntimeout will be halved all the time and will then stagnate at 0 and\ntherefore never be able to reduce the table even more.\n\nThere are other scenarios possible with a similar result. The number of\nBATADV_TT_CLIENT_NOPURGE entries in the local TT can for example be too\nhigh to fit inside a packet. Such a scenario can therefore happen also with\nonly a single VLAN + 7 non-purgable addresses - requiring at least 120\nbytes.\n\nWhile this should be handled proactively when:\n\n* interface with too low MTU is added\n* VLAN is added\n* non-purgeable local mac is added\n* MTU of an attached interface is reduced\n* fragmentation setting gets disabled (which most likely requires dropping\n  attached interfaces)\n\nnot all of these scenarios can be prevented because batman-adv is only\nconsuming events without the the possibility to prevent these actions\n(non-purgable MAC address added, MTU of an attached interface is reduced).\nIt is therefore necessary to also make sure that the code is able to handle\nalso the situations when there were already incompatible system\nconfiguration are present."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-20T10:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-35988",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/04bf2e5f95c1a52e28a7567a507f926efe31c3b6",
            "https://git.kernel.org/stable/c/52e8a42b11078d2aad4b9ba96503d77c7299168b",
            "https://git.kernel.org/stable/c/4201b8c8f2c32af321fb50867e68ac6c1cbed4be",
            "https://git.kernel.org/stable/c/a0f0dbbb1bc49fa0de18e92c36492ff6d804cdaa",
            "https://git.kernel.org/stable/c/efdcfa554b6eb228943ef1dd4d023c606be647d2",
            "https://git.kernel.org/stable/c/6065e736f82c817c9a597a31ee67f0ce4628e948",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nriscv: Fix TASK_SIZE on 64-bit NOMMU\n\nOn NOMMU, userspace memory can come from anywhere in physical RAM. The\ncurrent definition of TASK_SIZE is wrong if any RAM exists above 4G,\ncausing spurious failures in the userspace access routines."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-19T11:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-35930",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/edf82aa7e9eb864a09229392054d131b34a5c9e8",
            "https://git.kernel.org/stable/c/e2cd32435b1dff3d63759476a3abc878e02fb6c8",
            "https://git.kernel.org/stable/c/c473288f27d15014447de5a891bdf22a0695847a",
            "https://git.kernel.org/stable/c/7849e6f8410da96384e3d1f6b6d730f095142dc7",
            "https://git.kernel.org/stable/c/ee0b5f96b6d66a1e6698228dcb41df11ec7f352f",
            "https://git.kernel.org/stable/c/07a2aa674fca679316b8ac51440adb895b53a7cf",
            "https://git.kernel.org/stable/c/3320126ed3afbc11934502319b340f91a4d61c8f",
            "https://git.kernel.org/stable/c/2ae917d4bcab80ab304b774d492e2fcd6c52c06b",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: lpfc: Fix possible memory leak in lpfc_rcv_padisc()\n\nThe call to lpfc_sli4_resume_rpi() in lpfc_rcv_padisc() may return an\nunsuccessful status.  In such cases, the elsiocb is not issued, the\ncompletion is not called, and thus the elsiocb resource is leaked.\n\nCheck return value after calling lpfc_sli4_resume_rpi() and conditionally\nrelease the elsiocb resource."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-19T09:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-35910",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/93f0133b9d589cc6e865f254ad9be3e9d8133f50",
            "https://git.kernel.org/stable/c/44e62f5d35678686734afd47c6a421ad30772e7f",
            "https://git.kernel.org/stable/c/e3e27d2b446deb1f643758a0c4731f5c22492810",
            "https://git.kernel.org/stable/c/2e43d8eba6edd1cf05a3a20fdd77688fa7ec16a4",
            "https://git.kernel.org/stable/c/91b243de910a9ac8476d40238ab3dbfeedd5b7de",
            "https://git.kernel.org/stable/c/c1ae4d1e76eacddaacb958b67cd942082f800c87",
            "https://git.kernel.org/stable/c/899265c1389fe022802aae73dbf13ee08837a35a",
            "https://git.kernel.org/stable/c/151c9c724d05d5b0dd8acd3e11cb69ef1f2dbada",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ntcp: properly terminate timers for kernel sockets\n\nWe had various syzbot reports about tcp timers firing after\nthe corresponding netns has been dismantled.\n\nFortunately Josef Bacik could trigger the issue more often,\nand could test a patch I wrote two years ago.\n\nWhen TCP sockets are closed, we call inet_csk_clear_xmit_timers()\nto 'stop' the timers.\n\ninet_csk_clear_xmit_timers() can be called from any context,\nincluding when socket lock is held.\nThis is the reason it uses sk_stop_timer(), aka del_timer().\nThis means that ongoing timers might finish much later.\n\nFor user sockets, this is fine because each running timer\nholds a reference on the socket, and the user socket holds\na reference on the netns.\n\nFor kernel sockets, we risk that the netns is freed before\ntimer can complete, because kernel sockets do not hold\nreference on the netns.\n\nThis patch adds inet_csk_clear_xmit_timers_sync() function\nthat using sk_stop_timer_sync() to make sure all timers\nare terminated before the kernel socket is released.\nModules using kernel sockets close them in their netns exit()\nhandler.\n\nAlso add sock_not_owned_by_me() helper to get LOCKDEP\nsupport : inet_csk_clear_xmit_timers_sync() must not be called\nwhile socket lock is held.\n\nIt is very possible we can revert in the future commit\n3a58f13a881e (\"net: rds: acquire refcount on TCP sockets\")\nwhich attempted to solve the issue in rds only.\n(net/smc/af_smc.c and net/mptcp/subflow.c have similar code)\n\nWe probably can remove the check_net() tests from\ntcp_out_of_resources() and __tcp_close() in the future."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-17T14:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-35809",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/9a87375bb586515c0af63d5dcdcd58ec4acf20a6",
            "https://git.kernel.org/stable/c/47d8aafcfe313511a98f165a54d0adceb34e54b1",
            "https://git.kernel.org/stable/c/bbe068b24409ef740657215605284fc7cdddd491",
            "https://git.kernel.org/stable/c/7cc94dd36e48879e76ae7a8daea4ff322b7d9674",
            "https://git.kernel.org/stable/c/900b81caf00c89417172afe0e7e49ac4eb110f4b",
            "https://git.kernel.org/stable/c/d86ad8c3e152349454b82f37007ff6ba45f26989",
            "https://git.kernel.org/stable/c/d534198311c345e4b062c4b88bb609efb8bd91d5",
            "https://git.kernel.org/stable/c/6347348c6aba52dda0b33296684cbb627bdc6970",
            "https://git.kernel.org/stable/c/9d5286d4e7f68beab450deddbb6a32edd5ecf4bf",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nPCI/PM: Drain runtime-idle callbacks before driver removal\n\nA race condition between the .runtime_idle() callback and the .remove()\ncallback in the rtsx_pcr PCI driver leads to a kernel crash due to an\nunhandled page fault [1].\n\nThe problem is that rtsx_pci_runtime_idle() is not expected to be running\nafter pm_runtime_get_sync() has been called, but the latter doesn't really\nguarantee that.  It only guarantees that the suspend and resume callbacks\nwill not be running when it returns.\n\nHowever, if a .runtime_idle() callback is already running when\npm_runtime_get_sync() is called, the latter will notice that the runtime PM\nstatus of the device is RPM_ACTIVE and it will return right away without\nwaiting for the former to complete.  In fact, it cannot wait for\n.runtime_idle() to complete because it may be called from that callback (it\narguably does not make much sense to do that, but it is not strictly\nprohibited).\n\nThus in general, whoever is providing a .runtime_idle() callback needs\nto protect it from running in parallel with whatever code runs after\npm_runtime_get_sync().  [Note that .runtime_idle() will not start after\npm_runtime_get_sync() has returned, but it may continue running then if it\nhas started earlier.]\n\nOne way to address that race condition is to call pm_runtime_barrier()\nafter pm_runtime_get_sync() (not before it, because a nonzero value of the\nruntime PM usage counter is necessary to prevent runtime PM callbacks from\nbeing invoked) to wait for the .runtime_idle() callback to complete should\nit be running at that point.  A suitable place for doing that is in\npci_device_remove() which calls pm_runtime_get_sync() before removing the\ndriver, so it may as well call pm_runtime_barrier() subsequently, which\nwill prevent the race in question from occurring, not just in the rtsx_pcr\ndriver, but in any PCI drivers providing .runtime_idle() callbacks."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-17T14:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-35806",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/b56a793f267679945d1fdb9a280013bd2d0ed7f9",
            "https://git.kernel.org/stable/c/62c3ecd2833cff0eff4a82af4082c44ca8d2518a",
            "https://git.kernel.org/stable/c/dd199e5b759ffe349622a4b8fbcafc51fc51b1ec",
            "https://git.kernel.org/stable/c/e6378314bb920acb39013051fa65d8f9f8030430",
            "https://git.kernel.org/stable/c/a62168653774c36398d65846a98034436ee66d03",
            "https://git.kernel.org/stable/c/0e6521b0f93ff350434ed4ae61a250907e65d397",
            "https://git.kernel.org/stable/c/276af8efb05c8e47acf2738a5609dd72acfc703f",
            "https://git.kernel.org/stable/c/af25c5180b2b1796342798f6c56fcfd12f5035bd",
            "https://git.kernel.org/stable/c/584c2a9184a33a40fceee838f856de3cffa19be3",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nsoc: fsl: qbman: Always disable interrupts when taking cgr_lock\n\nsmp_call_function_single disables IRQs when executing the callback. To\nprevent deadlocks, we must disable IRQs when taking cgr_lock elsewhere.\nThis is already done by qman_update_cgr and qman_delete_cgr; fix the\nother lockers."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-17T14:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-35833",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/1c75fe450b5200c78f4a102a0eb8e15d8f1ccda8",
            "https://git.kernel.org/stable/c/ae6769ba51417c1c86fb645812d5bff455eee802",
            "https://git.kernel.org/stable/c/15eb996d7d13cb72a16389231945ada8f0fef2c3",
            "https://git.kernel.org/stable/c/25ab4d72eb7cbfa0f3d97a139a9b2bfcaa72dd59",
            "https://git.kernel.org/stable/c/5cd8a51517ce15edbdcea4fc74c4c127ddaa1bd6",
            "https://git.kernel.org/stable/c/198270de9d8eb3b5d5f030825ea303ef95285d24",
            "https://git.kernel.org/stable/c/3aa58cb51318e329d203857f7a191678e60bb714",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndmaengine: fsl-qdma: Fix a memory leak related to the queue command DMA\n\nThis dma_alloc_coherent() is undone neither in the remove function, nor in\nthe error handling path of fsl_qdma_probe().\n\nSwitch to the managed version to fix both issues."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-17T14:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-35823",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/fc7dfe3d123f00e720be80b920da287810a1f37d",
            "https://git.kernel.org/stable/c/ff7342090c1e8c5a37015c89822a68b275b46f8a",
            "https://git.kernel.org/stable/c/1ce408f75ccf1e25b3fddef75cca878b55f2ac90",
            "https://git.kernel.org/stable/c/0190d19d7651c08abc187dac3819c61b726e7e3f",
            "https://git.kernel.org/stable/c/994a1e583c0c206c8ca7d03334a65b79f4d8bc51",
            "https://git.kernel.org/stable/c/7529cbd8b5f6697b369803fe1533612c039cabda",
            "https://git.kernel.org/stable/c/2933b1e4757a0a5c689cf48d80b1a2a85f237ff1",
            "https://git.kernel.org/stable/c/1581dafaf0d34bc9c428a794a22110d7046d186d",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nvt: fix unicode buffer corruption when deleting characters\n\nThis is the same issue that was fixed for the VGA text buffer in commit\n39cdb68c64d8 (\"vt: fix memory overlapping when deleting chars in the\nbuffer\"). The cure is also the same i.e. replace memcpy() with memmove()\ndue to the overlaping buffers."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-17T14:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-35829",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/f2e80ac9344aebbff576453d5c0290b332e187ed",
            "https://git.kernel.org/stable/c/746606d37d662c70ae1379fc658ee9c65f06880f",
            "https://git.kernel.org/stable/c/f6d51a91b41704704e395de6839c667b0f810bbf",
            "https://git.kernel.org/stable/c/8e25c0ee5665e8a768b8e21445db1f86e9156eb7",
            "https://git.kernel.org/stable/c/4ab14eccf5578af1dd5668a5f2d771df27683cab",
            "https://git.kernel.org/stable/c/ec6bb037e4a35fcbb5cd7bc78242d034ed893fcd",
            "https://git.kernel.org/stable/c/04ae3eb470e52a3c41babe85ff8cee195e4dcbea",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/lima: fix a memleak in lima_heap_alloc\n\nWhen lima_vm_map_bo fails, the resources need to be deallocated, or\nthere will be memleaks."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-17T14:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-35811",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/202c503935042272e2f9e1bb549d5f69a8681169",
            "https://git.kernel.org/stable/c/8e3f03f4ef7c36091f46e7349096efb5a2cdb3a1",
            "https://git.kernel.org/stable/c/bacb8c3ab86dcd760c15903fcee58169bc3026aa",
            "https://git.kernel.org/stable/c/8c36205123dc57349b59b4f1a2301eb278cbc731",
            "https://git.kernel.org/stable/c/0b812f706fd7090be74812101114a0e165b36744",
            "https://git.kernel.org/stable/c/190794848e2b9d15de92d502b6ac652806904f5a",
            "https://git.kernel.org/stable/c/6678a1e7d896c00030b31491690e8ddc9a90767a",
            "https://git.kernel.org/stable/c/0a7591e14a8da794d0b93b5d1c6254ccb23adacb",
            "https://git.kernel.org/stable/c/0f7352557a35ab7888bc7831411ec8a3cbe20d78",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: brcmfmac: Fix use-after-free bug in brcmf_cfg80211_detach\n\nThis is the candidate patch of CVE-2023-47233 :\nhttps://nvd.nist.gov/vuln/detail/CVE-2023-47233\n\nIn brcm80211 driver,it starts with the following invoking chain\nto start init a timeout worker:\n\n->brcmf_usb_probe\n  ->brcmf_usb_probe_cb\n    ->brcmf_attach\n      ->brcmf_bus_started\n        ->brcmf_cfg80211_attach\n          ->wl_init_priv\n            ->brcmf_init_escan\n              ->INIT_WORK(&cfg->escan_timeout_work,\n\t\t  brcmf_cfg80211_escan_timeout_worker);\n\nIf we disconnect the USB by hotplug, it will call\nbrcmf_usb_disconnect to make cleanup. The invoking chain is :\n\nbrcmf_usb_disconnect\n  ->brcmf_usb_disconnect_cb\n    ->brcmf_detach\n      ->brcmf_cfg80211_detach\n        ->kfree(cfg);\n\nWhile the timeout woker may still be running. This will cause\na use-after-free bug on cfg in brcmf_cfg80211_escan_timeout_worker.\n\nFix it by deleting the timer and canceling the worker in\nbrcmf_cfg80211_detach.\n\n[arend.vanspriel@broadcom.com: keep timer delete as is and cancel work just before free]"
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-17T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-35854",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/e118e7ea24d1392878ef85926627c6bc640c4388",
            "https://git.kernel.org/stable/c/a429a912d6c779807f4d72a6cc0a1efaaa3613e1",
            "https://git.kernel.org/stable/c/4c89642ca47fb620914780c7c51d8d1248201121",
            "https://git.kernel.org/stable/c/813e2ab753a8f8c243a39ede20c2e0adc15f3887",
            "https://git.kernel.org/stable/c/311eeaa7b9e26aba5b3d57b09859f07d8e9fc049",
            "https://git.kernel.org/stable/c/a02687044e124f8ccb427cd3632124a4e1a7d7c1",
            "https://git.kernel.org/stable/c/54225988889931467a9b55fdbef534079b665519",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmlxsw: spectrum_acl_tcam: Fix possible use-after-free during rehash\n\nThe rehash delayed work migrates filters from one region to another\naccording to the number of available credits.\n\nThe migrated from region is destroyed at the end of the work if the\nnumber of credits is non-negative as the assumption is that this is\nindicative of migration being complete. This assumption is incorrect as\na non-negative number of credits can also be the result of a failed\nmigration.\n\nThe destruction of a region that still has filters referencing it can\nresult in a use-after-free [1].\n\nFix by not destroying the region if migration failed.\n\n[1]\nBUG: KASAN: slab-use-after-free in mlxsw_sp_acl_ctcam_region_entry_remove+0x21d/0x230\nRead of size 8 at addr ffff8881735319e8 by task kworker/0:31/3858\n\nCPU: 0 PID: 3858 Comm: kworker/0:31 Tainted: G        W          6.9.0-rc2-custom-00782-gf2275c2157d8 #5\nHardware name: Mellanox Technologies Ltd. MSN3700/VMOD0005, BIOS 5.11 01/06/2019\nWorkqueue: mlxsw_core mlxsw_sp_acl_tcam_vregion_rehash_work\nCall Trace:\n <TASK>\n dump_stack_lvl+0xc6/0x120\n print_report+0xce/0x670\n kasan_report+0xd7/0x110\n mlxsw_sp_acl_ctcam_region_entry_remove+0x21d/0x230\n mlxsw_sp_acl_ctcam_entry_del+0x2e/0x70\n mlxsw_sp_acl_atcam_entry_del+0x81/0x210\n mlxsw_sp_acl_tcam_vchunk_migrate_all+0x3cd/0xb50\n mlxsw_sp_acl_tcam_vregion_rehash_work+0x157/0x1300\n process_one_work+0x8eb/0x19b0\n worker_thread+0x6c9/0xf70\n kthread+0x2c9/0x3b0\n ret_from_fork+0x4d/0x80\n ret_from_fork_asm+0x1a/0x30\n </TASK>\n\nAllocated by task 174:\n kasan_save_stack+0x33/0x60\n kasan_save_track+0x14/0x30\n __kasan_kmalloc+0x8f/0xa0\n __kmalloc+0x19c/0x360\n mlxsw_sp_acl_tcam_region_create+0xdf/0x9c0\n mlxsw_sp_acl_tcam_vregion_rehash_work+0x954/0x1300\n process_one_work+0x8eb/0x19b0\n worker_thread+0x6c9/0xf70\n kthread+0x2c9/0x3b0\n ret_from_fork+0x4d/0x80\n ret_from_fork_asm+0x1a/0x30\n\nFreed by task 7:\n kasan_save_stack+0x33/0x60\n kasan_save_track+0x14/0x30\n kasan_save_free_info+0x3b/0x60\n poison_slab_object+0x102/0x170\n __kasan_slab_free+0x14/0x30\n kfree+0xc1/0x290\n mlxsw_sp_acl_tcam_region_destroy+0x272/0x310\n mlxsw_sp_acl_tcam_vregion_rehash_work+0x731/0x1300\n process_one_work+0x8eb/0x19b0\n worker_thread+0x6c9/0xf70\n kthread+0x2c9/0x3b0\n ret_from_fork+0x4d/0x80\n ret_from_fork_asm+0x1a/0x30"
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-17T14:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-35830",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/17c2650de14842c25c569cbb2126c421489a3a24",
            "https://git.kernel.org/stable/c/daf21394f9898fb9f0698c3e50de08132d2164e6",
            "https://git.kernel.org/stable/c/610f20e5cf35ca9c0992693cae0dd8643ce932e7",
            "https://git.kernel.org/stable/c/b8505a1aee8f1edc9d16d72ae09c93de086e2a1a",
            "https://git.kernel.org/stable/c/8ba8db9786b55047df5ad3db3e01dd886687a77d",
            "https://git.kernel.org/stable/c/edbb3226c985469a2f8eb69885055c9f5550f468",
            "https://git.kernel.org/stable/c/c915c46a25c3efb084c4f5e69a053d7f7a635496",
            "https://git.kernel.org/stable/c/4f1490a5d7a0472ee5d9f36547bc4ba46be755c7",
            "https://git.kernel.org/stable/c/87399f1ff92203d65f1febf5919429f4bb613a02",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: tc358743: register v4l2 async device only after successful setup\n\nEnsure the device has been setup correctly before registering the v4l2\nasync device, thus allowing userspace to access."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-17T12:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-27413",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/00cf21ac526011a29fc708f8912da446fac19f7b",
            "https://git.kernel.org/stable/c/950d4d74d311a18baed6878dbfba8180d7e5dddd",
            "https://git.kernel.org/stable/c/537e3f49dbe88881a6f0752beaa596942d9efd64",
            "https://git.kernel.org/stable/c/4b73473c050a612fb4317831371073eda07c3050",
            "https://git.kernel.org/stable/c/ddc547dd05a46720866c32022300f7376c40119f",
            "https://git.kernel.org/stable/c/11aabd7487857b8e7d768fefb092f66dfde68492",
            "https://git.kernel.org/stable/c/62a5dcd9bd3097e9813de62fa6f22815e84a0172",
            "https://git.kernel.org/stable/c/fccfa646ef3628097d59f7d9c1a3e84d4b6bb45e",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nefi/capsule-loader: fix incorrect allocation size\n\ngcc-14 notices that the allocation with sizeof(void) on 32-bit architectures\nis not enough for a 64-bit phys_addr_t:\n\ndrivers/firmware/efi/capsule-loader.c: In function 'efi_capsule_open':\ndrivers/firmware/efi/capsule-loader.c:295:24: error: allocation of insufficient size '4' for type 'phys_addr_t' {aka 'long long unsigned int'} with size '8' [-Werror=alloc-size]\n  295 |         cap_info->phys = kzalloc(sizeof(void *), GFP_KERNEL);\n      |                        ^\n\nUse the correct type instead here."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-17T12:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-27416",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/afec8f772296dd8e5a2a6f83bbf99db1b9ca877f",
            "https://git.kernel.org/stable/c/79820a7e1e057120c49be07cbe10643d0706b259",
            "https://git.kernel.org/stable/c/df193568d61234c81de7ed4d540c01975de60277",
            "https://git.kernel.org/stable/c/c3df637266df29edee85e94cab5fd7041e5753ba",
            "https://git.kernel.org/stable/c/30a5e812f78e3d1cced90e1ed750bf027599205f",
            "https://git.kernel.org/stable/c/fba268ac36ab19f9763ff90d276cde0ce6cd5f31",
            "https://git.kernel.org/stable/c/8e2758cc25891d2b76717aaf89b40ed215de188c",
            "https://git.kernel.org/stable/c/7e74aa53a68bf60f6019bd5d9a9a1406ec4d4865",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: hci_event: Fix handling of HCI_EV_IO_CAPA_REQUEST\n\nIf we received HCI_EV_IO_CAPA_REQUEST while\nHCI_OP_READ_REMOTE_EXT_FEATURES is yet to be responded assume the remote\ndoes support SSP since otherwise this event shouldn't be generated."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-17T13:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-35785",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/bc40ded92af55760d12bec8222d4108de725dbe4",
            "https://git.kernel.org/stable/c/4b12ff5edd141926d49c9ace4791adf3a4902fe7",
            "https://git.kernel.org/stable/c/e5b5948c769aa1ebf962dddfb972f87d8f166f95",
            "https://git.kernel.org/stable/c/520f79c110ff712b391b3d87fcacf03c74bc56ee",
            "https://git.kernel.org/stable/c/bfa344afbe472a9be08f78551fa2190c1a07d7d3",
            "https://git.kernel.org/stable/c/95915ba4b987cf2b222b0f251280228a1ff977ac",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ntee: optee: Fix kernel panic caused by incorrect error handling\n\nThe error path while failing to register devices on the TEE bus has a\nbug leading to kernel panic as follows:\n\n[   15.398930] Unable to handle kernel paging request at virtual address ffff07ed00626d7c\n[   15.406913] Mem abort info:\n[   15.409722]   ESR = 0x0000000096000005\n[   15.413490]   EC = 0x25: DABT (current EL), IL = 32 bits\n[   15.418814]   SET = 0, FnV = 0\n[   15.421878]   EA = 0, S1PTW = 0\n[   15.425031]   FSC = 0x05: level 1 translation fault\n[   15.429922] Data abort info:\n[   15.432813]   ISV = 0, ISS = 0x00000005, ISS2 = 0x00000000\n[   15.438310]   CM = 0, WnR = 0, TnD = 0, TagAccess = 0\n[   15.443372]   GCS = 0, Overlay = 0, DirtyBit = 0, Xs = 0\n[   15.448697] swapper pgtable: 4k pages, 48-bit VAs, pgdp=00000000d9e3e000\n[   15.455413] [ffff07ed00626d7c] pgd=1800000bffdf9003, p4d=1800000bffdf9003, pud=0000000000000000\n[   15.464146] Internal error: Oops: 0000000096000005 [#1] PREEMPT SMP\n\nCommit 7269cba53d90 (\"tee: optee: Fix supplicant based device enumeration\")\nlead to the introduction of this bug. So fix it appropriately."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-14T14:23:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2023-52656",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/cfb24022bb2c31f1f555dc6bc3cc5e2547446fb3",
            "https://git.kernel.org/stable/c/a6771f343af90a25f3a14911634562bb5621df02",
            "https://git.kernel.org/stable/c/d909d381c3152393421403be4b6435f17a2378b4",
            "https://git.kernel.org/stable/c/a3812a47a32022ca76bf46ddacdd823dc2aabf8b",
            "https://git.kernel.org/stable/c/88c49d9c896143cdc0f77197c4dcf24140375e89",
            "https://git.kernel.org/stable/c/6e5e6d274956305f1fc0340522b38f5f5be74bdb",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nio_uring: drop any code related to SCM_RIGHTS\n\nThis is dead code after we dropped support for passing io_uring fds\nover SCM_RIGHTS, get rid of it."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-14T15:12:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-27395",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/2db9a8c0a01fa1c762c1e61a13c212c492752994",
            "https://git.kernel.org/stable/c/589523cf0b384164e445dd5db8d5b1bf97982424",
            "https://git.kernel.org/stable/c/35880c3fa6f8fe281a19975d2992644588ca33d3",
            "https://git.kernel.org/stable/c/9048616553c65e750d43846f225843ed745ec0d4",
            "https://git.kernel.org/stable/c/bca6fa2d9a9f560e6b89fd5190b05cc2f5d422c1",
            "https://git.kernel.org/stable/c/eaa5e164a2110d2fb9e16c8a29e4501882235137",
            "https://git.kernel.org/stable/c/edee0758747d7c219e29db9ed1d4eb33e8d32865",
            "https://git.kernel.org/stable/c/5ea7b72d4fac2fdbc0425cd8f2ea33abe95235b2",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: openvswitch: Fix Use-After-Free in ovs_ct_exit\n\nSince kfree_rcu, which is called in the hlist_for_each_entry_rcu traversal\nof ovs_ct_limit_exit, is not part of the RCU read critical section, it\nis possible that the RCU grace period will pass during the traversal and\nthe key will be free.\n\nTo prevent this, it should be changed to hlist_for_each_entry_safe."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-01T13:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-27073",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/af37aed04997e644f7e1b52b696b62dcae3cc016",
            "https://git.kernel.org/stable/c/910363473e4bf97da3c350e08d915546dd6cc30b",
            "https://git.kernel.org/stable/c/24e51d6eb578b82ff292927f14b9f5ec05a46beb",
            "https://git.kernel.org/stable/c/55ca0c7eae8499bb96f4e5d9b26af95e89c4e6a0",
            "https://git.kernel.org/stable/c/7393c681f9aa05ffe2385e8716989565eed2fe06",
            "https://git.kernel.org/stable/c/1597cd1a88cfcdc4bf8b1b44cd458fed9a5a5d63",
            "https://git.kernel.org/stable/c/656b8cc123d7635dd399d9f02594f27aa797ac3c",
            "https://git.kernel.org/stable/c/d0b07f712bf61e1a3cf23c87c663791c42e50837",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: ttpci: fix two memleaks in budget_av_attach\n\nWhen saa7146_register_device and saa7146_vv_init fails, budget_av_attach\nshould free the resources it allocates, like the error-handling of\nttpci_budget_init does. Besides, there are two fixme comment refers to\nsuch deallocations."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-01T13:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-27074",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/7f11dd3d165b178e738fe73dfeea513e383bedb5",
            "https://git.kernel.org/stable/c/291cda0b805fc0d6e90d201710311630c8667159",
            "https://git.kernel.org/stable/c/b49fe84c6cefcc1c2336d793b53442e716c95073",
            "https://git.kernel.org/stable/c/790fa2c04dfb9f095ec372bf17909424d6e864b3",
            "https://git.kernel.org/stable/c/e04d15c8bb3e111dd69f98894acd92d63e87aac3",
            "https://git.kernel.org/stable/c/f31c1cc37411f5f7bcb266133f9a7e1b4bdf2975",
            "https://git.kernel.org/stable/c/d43988a23c32588ccd0c74219637afb96cd78661",
            "https://git.kernel.org/stable/c/7405a0d4442792988e9ae834e7d84f9d163731a4",
            "https://git.kernel.org/stable/c/b9b683844b01d171a72b9c0419a2d760d946ee12",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: go7007: fix a memleak in go7007_load_encoder\n\nIn go7007_load_encoder, bounce(i.e. go->boot_fw), is allocated without\na deallocation thereafter. After the following call chain:\n\nsaa7134_go7007_init\n  |-> go7007_boot_encoder\n        |-> go7007_load_encoder\n  |-> kfree(go)\n\ngo is freed and thus bounce is leaked."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-01T13:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-27076",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/8c2e4efe1278cd2b230cdbf90a6cefbf00acc282",
            "https://git.kernel.org/stable/c/5d9fe604bf9b5b09d2215225df55f22a4cbbc684",
            "https://git.kernel.org/stable/c/b1d0eebaf87cc9ccd05f779ec4a0589f95d6c18b",
            "https://git.kernel.org/stable/c/8df9a3c7044b847e9c4dc7e683fd64c6b873f328",
            "https://git.kernel.org/stable/c/d164ddc21e986dd9ad614b4b01746e5457aeb24f",
            "https://git.kernel.org/stable/c/42492b00156c03a79fd4851190aa63045d6a15ce",
            "https://git.kernel.org/stable/c/6c92224721a439d6350db5933a1060768dcd565e",
            "https://git.kernel.org/stable/c/4797a3dd46f220e6d83daf54d70c5b33db6deb01",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: imx: csc/scaler: fix v4l2_ctrl_handler memory leak\n\nFree the memory allocated in v4l2_ctrl_handler_init on release."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-01T13:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-27077",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/3dd8abb0ed0e0a7c66d6d677c86ccb188cc39333",
            "https://git.kernel.org/stable/c/0175f2d34c85744f9ad6554f696cf0afb5bd04e4",
            "https://git.kernel.org/stable/c/afd2a82fe300032f63f8be5d6cd6981e75f8bbf2",
            "https://git.kernel.org/stable/c/dc866b69cc51af9b8509b4731b8ce2a4950cd0ef",
            "https://git.kernel.org/stable/c/0c9550b032de48d6a7fa6a4ddc09699d64d9300d",
            "https://git.kernel.org/stable/c/90029b9c979b60de5cb2b70ade4bbf61d561bc5d",
            "https://git.kernel.org/stable/c/5dc319cc3c4f7b74f7dfba349aa26f87efb52458",
            "https://git.kernel.org/stable/c/9c23ef30e840fedc66948299509f6c2777c9cf4f",
            "https://git.kernel.org/stable/c/8f94b49a5b5d386c038e355bef6347298aabd211",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: v4l2-mem2mem: fix a memleak in v4l2_m2m_register_entity\n\nThe entity->name (i.e. name) is allocated in v4l2_m2m_register_entity\nbut isn't freed in its following error-handling paths. This patch\nadds such deallocation to prevent memleak of entity->name."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-01T13:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-27078",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/0de691ff547d86dd54c24b40a81f9c925df8dd77",
            "https://git.kernel.org/stable/c/8269ab16415f2065cd792c49b0475543936cbd79",
            "https://git.kernel.org/stable/c/94303a06e1852a366e9671fff46d19459f88cb28",
            "https://git.kernel.org/stable/c/770a57922ce36a8476c43f7400b6501c554ea511",
            "https://git.kernel.org/stable/c/6bf5c2fade8ed53b2d26fa9875e5b04f36c7145d",
            "https://git.kernel.org/stable/c/4c86c772fef06f5d7a66151bac42366825db0941",
            "https://git.kernel.org/stable/c/31096da07933598da8522c54bd007376fb152a09",
            "https://git.kernel.org/stable/c/622b1cf38521569869c8f7b9fbe9e4f1a289add7",
            "https://git.kernel.org/stable/c/8cf9c5051076e0eb958f4361d50d8b0c3ee6691c",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: v4l2-tpg: fix some memleaks in tpg_alloc\n\nIn tpg_alloc, resources should be deallocated in each and every\nerror-handling paths, since they are allocated in for statements.\nOtherwise there would be memleaks because tpg_free is called only when\ntpg_alloc return 0."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-01T13:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2023-52650",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/47a13d0b9d8527518639ab5c39667f69d6203e80",
            "https://git.kernel.org/stable/c/f05631a8525c3b5e5994ecb1304d2d878956c0f5",
            "https://git.kernel.org/stable/c/92003981a6df5dc84af8a5904f8ee112fa324129",
            "https://git.kernel.org/stable/c/93128052bf832359531c3c0a9e3567b2b8682a2d",
            "https://git.kernel.org/stable/c/50c0ad785a780c72a2fdaba10b38c645ffb4eae6",
            "https://git.kernel.org/stable/c/52aa507148c4aad41436e2005d742ffcafad9976",
            "https://git.kernel.org/stable/c/c5d2342d24ef6e08fc90a529fe3dc59de421a2b9",
            "https://git.kernel.org/stable/c/3169eaf1365541fd8e521091010c44fbe14691fc",
            "https://git.kernel.org/stable/c/afe6fcb9775882230cd29b529203eabd5d2a638d",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/tegra: dsi: Add missing check for of_find_device_by_node\n\nAdd check for the return value of of_find_device_by_node() and return\nthe error if it fails in order to avoid NULL pointer dereference."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-01T13:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-27388",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/b97c37978ca825557d331c9012e0c1ddc0e42364",
            "https://git.kernel.org/stable/c/bfa9d86d39a0fe4685f90c3529aa9bd62a9d97a8",
            "https://git.kernel.org/stable/c/bb336cd8d5ecb69c430ebe3e7bcff68471d93fa8",
            "https://git.kernel.org/stable/c/dd292e884c649f9b1c18af0ec75ca90b390cd044",
            "https://git.kernel.org/stable/c/934212a623cbab851848b6de377eb476718c3e4c",
            "https://git.kernel.org/stable/c/5e6013ae2c8d420faea553d363935f65badd32c3",
            "https://git.kernel.org/stable/c/9806c2393cd2ab0a8e7bb9ffae02ce20e3112ec4",
            "https://git.kernel.org/stable/c/996997d1fb2126feda550d6adcedcbd94911fc69",
            "https://git.kernel.org/stable/c/3cfcfc102a5e57b021b786a755a38935e357797d",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nSUNRPC: fix some memleaks in gssx_dec_option_array\n\nThe creds and oa->data need to be freed in the error-handling paths after\ntheir allocation. So this patch add these deallocations in the\ncorresponding paths."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-01T13:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-27028",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/2342b05ec5342a519e00524a507f7a6ea6791a38",
            "https://git.kernel.org/stable/c/55f8ea6731aa64871ee6aef7dba53ee9f9f3b2f6",
            "https://git.kernel.org/stable/c/bcfcdf19698024565eff427706ebbd8df65abd11",
            "https://git.kernel.org/stable/c/c10fed329c1c104f375a75ed97ea3abef0786d62",
            "https://git.kernel.org/stable/c/766ec94cc57492eab97cbbf1595bd516ab0cb0e4",
            "https://git.kernel.org/stable/c/62b1f837b15cf3ec2835724bdf8577e47d14c753",
            "https://git.kernel.org/stable/c/bea82355df9e1c299625405b1947fc9b26b4c6d4",
            "https://git.kernel.org/stable/c/1784053cf10a14c4ebd8a890bad5cfe1bee51713",
            "https://git.kernel.org/stable/c/a20ad45008a7c82f1184dc6dee280096009ece55",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nspi: spi-mt65xx: Fix NULL pointer access in interrupt handler\n\nThe TX buffer in spi_transfer can be a NULL pointer, so the interrupt\nhandler may end up writing to the invalid memory and cause crashes.\n\nAdd a check to trans->tx_buf before using it."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-01T06:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-27000",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/2c9b943e9924cf1269e44289bc5e60e51b0f5270",
            "https://git.kernel.org/stable/c/5f40fd6ca2cf0bfbc5a5c9e403dfce8ca899ba37",
            "https://git.kernel.org/stable/c/94b0e65c75f4af888ab2dd6c90f060f762924e86",
            "https://git.kernel.org/stable/c/54c4ec5f8c471b7c1137a1f769648549c423c026",
            "https://git.kernel.org/stable/c/56434e295bd446142025913bfdf1587f5e1970ad",
            "https://git.kernel.org/stable/c/21535ef0ac1945080198fe3e4347ea498205c99a",
            "https://git.kernel.org/stable/c/0dc0637e6b16158af85945425821bfd0151adb37",
            "https://git.kernel.org/stable/c/479244d68f5d94f3903eced52b093c1e01ddb495",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nserial: mxs-auart: add spinlock around changing cts state\n\nThe uart_handle_cts_change() function in serial_core expects the caller\nto hold uport->lock. For example, I have seen the below kernel splat,\nwhen the Bluetooth driver is loaded on an i.MX28 board.\n\n    [   85.119255] ------------[ cut here ]------------\n    [   85.124413] WARNING: CPU: 0 PID: 27 at /drivers/tty/serial/serial_core.c:3453 uart_handle_cts_change+0xb4/0xec\n    [   85.134694] Modules linked in: hci_uart bluetooth ecdh_generic ecc wlcore_sdio configfs\n    [   85.143314] CPU: 0 PID: 27 Comm: kworker/u3:0 Not tainted 6.6.3-00021-gd62a2f068f92 #1\n    [   85.151396] Hardware name: Freescale MXS (Device Tree)\n    [   85.156679] Workqueue: hci0 hci_power_on [bluetooth]\n    (...)\n    [   85.191765]  uart_handle_cts_change from mxs_auart_irq_handle+0x380/0x3f4\n    [   85.198787]  mxs_auart_irq_handle from __handle_irq_event_percpu+0x88/0x210\n    (...)"
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-01T06:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "CWE-667",
        "id": "CVE-2024-26934",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/8cbdd324b41528994027128207fae8100dff094f",
            "https://git.kernel.org/stable/c/12d6a5681a0a5cecc2af7860f0a1613fa7c6e947",
            "https://git.kernel.org/stable/c/e451709573f8be904a8a72d0775bf114d7c291d9",
            "https://git.kernel.org/stable/c/1b175bc579f46520b11ecda443bcd2ee4904f66a",
            "https://git.kernel.org/stable/c/ab062fa3dc69aea88fe62162c5881ba14b50ecc5",
            "https://git.kernel.org/stable/c/122a06f1068bf5e39089863f4f60b1f5d4273384",
            "https://git.kernel.org/stable/c/dbdf66250d2d33e8b27352fcb901de79f3521057",
            "https://git.kernel.org/stable/c/07acf979da33c721357ff27129edf74c23c036c6",
            "https://git.kernel.org/stable/c/80ba43e9f799cbdd83842fc27db667289b3150f5",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nUSB: core: Fix deadlock in usb_deauthorize_interface()\n\nAmong the attribute file callback routines in\ndrivers/usb/core/sysfs.c, the interface_authorized_store() function is\nthe only one which acquires a device lock on an ancestor device: It\ncalls usb_deauthorize_interface(), which locks the interface's parent\nUSB device.\n\nThe will lead to deadlock if another process already owns that lock\nand tries to remove the interface, whether through a configuration\nchange or because the device has been disconnected.  As part of the\nremoval procedure, device_del() waits for all ongoing sysfs attribute\ncallbacks to complete.  But usb_deauthorize_interface() can't complete\nuntil the device lock has been released, and the lock won't be\nreleased until the removal has finished.\n\nThe mechanism provided by sysfs to prevent this kind of deadlock is\nto use the sysfs_break_active_protection() function, which tells sysfs\nnot to wait for the attribute callback.\n\nReported-and-tested by: Yue Sun <samsun1006219@gmail.com>\nReported by: xingwei lee <xrivendell7@gmail.com>"
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-01T06:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26960",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/d85c11c97ecf92d47a4b29e3faca714dc1f18d0d",
            "https://git.kernel.org/stable/c/2da5568ee222ce0541bfe446a07998f92ed1643e",
            "https://git.kernel.org/stable/c/1ede7f1d7eed1738d1b9333fd1e152ccb450b86a",
            "https://git.kernel.org/stable/c/0f98f6d2fb5fad00f8299b84b85b6bc1b6d7d19a",
            "https://git.kernel.org/stable/c/3ce4c4c653e4e478ecb15d3c88e690f12cbf6b39",
            "https://git.kernel.org/stable/c/363d17e7f7907c8e27a9e86968af0eaa2301787b",
            "https://git.kernel.org/stable/c/82b1c07a0af603e3c47b906c8e991dc96f01688e",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm: swap: fix race between free_swap_and_cache() and swapoff()\n\nThere was previously a theoretical window where swapoff() could run and\nteardown a swap_info_struct while a call to free_swap_and_cache() was\nrunning in another thread.  This could cause, amongst other bad\npossibilities, swap_page_trans_huge_swapped() (called by\nfree_swap_and_cache()) to access the freed memory for swap_map.\n\nThis is a theoretical problem and I haven't been able to provoke it from a\ntest case.  But there has been agreement based on code review that this is\npossible (see link below).\n\nFix it by using get_swap_device()/put_swap_device(), which will stall\nswapoff().  There was an extra check in _swap_info_get() to confirm that\nthe swap entry was not free.  This isn't present in get_swap_device()\nbecause it doesn't make sense in general due to the race between getting\nthe reference and swapoff.  So I've added an equivalent check directly in\nfree_swap_and_cache().\n\nDetails of how to provoke one possible issue (thanks to David Hildenbrand\nfor deriving this):\n\n--8<-----\n\n__swap_entry_free() might be the last user and result in\n\"count == SWAP_HAS_CACHE\".\n\nswapoff->try_to_unuse() will stop as soon as soon as si->inuse_pages==0.\n\nSo the question is: could someone reclaim the folio and turn\nsi->inuse_pages==0, before we completed swap_page_trans_huge_swapped().\n\nImagine the following: 2 MiB folio in the swapcache. Only 2 subpages are\nstill references by swap entries.\n\nProcess 1 still references subpage 0 via swap entry.\nProcess 2 still references subpage 1 via swap entry.\n\nProcess 1 quits. Calls free_swap_and_cache().\n-> count == SWAP_HAS_CACHE\n[then, preempted in the hypervisor etc.]\n\nProcess 2 quits. Calls free_swap_and_cache().\n-> count == SWAP_HAS_CACHE\n\nProcess 2 goes ahead, passes swap_page_trans_huge_swapped(), and calls\n__try_to_reclaim_swap().\n\n__try_to_reclaim_swap()->folio_free_swap()->delete_from_swap_cache()->\nput_swap_folio()->free_swap_slot()->swapcache_free_entries()->\nswap_entry_free()->swap_range_free()->\n...\nWRITE_ONCE(si->inuse_pages, si->inuse_pages - nr_entries);\n\nWhat stops swapoff to succeed after process 2 reclaimed the swap cache\nbut before process1 finished its call to swap_page_trans_huge_swapped()?\n\n--8<-----"
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-01T06:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26969",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/e117c6e2d1617520f5f7d7f6f6b395f01d8b5a27",
            "https://git.kernel.org/stable/c/83fe1bbd9e259ad109827ccfbfc2488e0dea8e94",
            "https://git.kernel.org/stable/c/851cc19bdb02556fb13629b3e4fef6f2bdb038fe",
            "https://git.kernel.org/stable/c/9de184d4e557d550fb0b7b833b676bda4f269e4f",
            "https://git.kernel.org/stable/c/dd92b159c506804ac57adf3742d9728298bb1255",
            "https://git.kernel.org/stable/c/b6b31b4c67ea6bd9222e5b73b330554c57f2f90d",
            "https://git.kernel.org/stable/c/fc3ac2fcd0a7fad63eba1b359490a4b81720d0f9",
            "https://git.kernel.org/stable/c/be9e2752d823eca1d5af67014a1844a9176ff566",
            "https://git.kernel.org/stable/c/1040ef5ed95d6fd2628bad387d78a61633e09429",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nclk: qcom: gcc-ipq8074: fix terminating of frequency table arrays\n\nThe frequency table arrays are supposed to be terminated with an\nempty element. Add such entry to the end of the arrays where it\nis missing in order to avoid possible out-of-bound access when\nthe table is traversed by functions like qcom_find_freq() or\nqcom_find_freq_floor().\n\nOnly compile tested."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-01T06:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26984",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/3ab056814cd8ab84744c9a19ef51360b2271c572",
            "https://git.kernel.org/stable/c/ad74d208f213c06d860916ad40f609ade8c13039",
            "https://git.kernel.org/stable/c/a019b44b1bc6ed224c46fb5f88a8a10dd116e525",
            "https://git.kernel.org/stable/c/21ca9539f09360fd83654f78f2c361f2f5ddcb52",
            "https://git.kernel.org/stable/c/fff1386cc889d8fb4089d285f883f8cba62d82ce",
            "https://git.kernel.org/stable/c/bba8ec5e9b16649d85bc9e9086bf7ae5b5716ff9",
            "https://git.kernel.org/stable/c/1bc4825d4c3ec6abe43cf06c3c39d664d044cbf7",
            "https://git.kernel.org/stable/c/13d76b2f443dc371842916dd8768009ff1594716",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnouveau: fix instmem race condition around ptr stores\n\nRunning a lot of VK CTS in parallel against nouveau, once every\nfew hours you might see something like this crash.\n\nBUG: kernel NULL pointer dereference, address: 0000000000000008\nPGD 8000000114e6e067 P4D 8000000114e6e067 PUD 109046067 PMD 0\nOops: 0000 [#1] PREEMPT SMP PTI\nCPU: 7 PID: 53891 Comm: deqp-vk Not tainted 6.8.0-rc6+ #27\nHardware name: Gigabyte Technology Co., Ltd. Z390 I AORUS PRO WIFI/Z390 I AORUS PRO WIFI-CF, BIOS F8 11/05/2021\nRIP: 0010:gp100_vmm_pgt_mem+0xe3/0x180 [nouveau]\nCode: c7 48 01 c8 49 89 45 58 85 d2 0f 84 95 00 00 00 41 0f b7 46 12 49 8b 7e 08 89 da 42 8d 2c f8 48 8b 47 08 41 83 c7 01 48 89 ee <48> 8b 40 08 ff d0 0f 1f 00 49 8b 7e 08 48 89 d9 48 8d 75 04 48 c1\nRSP: 0000:ffffac20c5857838 EFLAGS: 00010202\nRAX: 0000000000000000 RBX: 00000000004d8001 RCX: 0000000000000001\nRDX: 00000000004d8001 RSI: 00000000000006d8 RDI: ffffa07afe332180\nRBP: 00000000000006d8 R08: ffffac20c5857ad0 R09: 0000000000ffff10\nR10: 0000000000000001 R11: ffffa07af27e2de0 R12: 000000000000001c\nR13: ffffac20c5857ad0 R14: ffffa07a96fe9040 R15: 000000000000001c\nFS:  00007fe395eed7c0(0000) GS:ffffa07e2c980000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000000000008 CR3: 000000011febe001 CR4: 00000000003706f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n\n...\n\n ? gp100_vmm_pgt_mem+0xe3/0x180 [nouveau]\n ? gp100_vmm_pgt_mem+0x37/0x180 [nouveau]\n nvkm_vmm_iter+0x351/0xa20 [nouveau]\n ? __pfx_nvkm_vmm_ref_ptes+0x10/0x10 [nouveau]\n ? __pfx_gp100_vmm_pgt_mem+0x10/0x10 [nouveau]\n ? __pfx_gp100_vmm_pgt_mem+0x10/0x10 [nouveau]\n ? __lock_acquire+0x3ed/0x2170\n ? __pfx_gp100_vmm_pgt_mem+0x10/0x10 [nouveau]\n nvkm_vmm_ptes_get_map+0xc2/0x100 [nouveau]\n ? __pfx_nvkm_vmm_ref_ptes+0x10/0x10 [nouveau]\n ? __pfx_gp100_vmm_pgt_mem+0x10/0x10 [nouveau]\n nvkm_vmm_map_locked+0x224/0x3a0 [nouveau]\n\nAdding any sort of useful debug usually makes it go away, so I hand\nwrote the function in a line, and debugged the asm.\n\nEvery so often pt->memory->ptrs is NULL. This ptrs ptr is set in\nthe nv50_instobj_acquire called from nvkm_kmap.\n\nIf Thread A and Thread B both get to nv50_instobj_acquire around\nthe same time, and Thread A hits the refcount_set line, and in\nlockstep thread B succeeds at refcount_inc_not_zero, there is a\nchance the ptrs value won't have been stored since refcount_set\nis unordered. Force a memory barrier here, I picked smp_mb, since\nwe want it on all CPUs and it's write followed by a read.\n\nv2: use paired smp_rmb/smp_wmb."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-01T06:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26974",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/daba62d9eeddcc5b1081be7d348ca836c83c59d7",
            "https://git.kernel.org/stable/c/8e81cd58aee14a470891733181a47d123193ba81",
            "https://git.kernel.org/stable/c/d03092550f526a79cf1ade7f0dfa74906f39eb71",
            "https://git.kernel.org/stable/c/4ae5a97781ce7d6ecc9c7055396535815b64ca4f",
            "https://git.kernel.org/stable/c/226fc408c5fcd23cc4186f05ea3a09a7a9aef2f7",
            "https://git.kernel.org/stable/c/8a5a7611ccc7b1fba8d933a9f22a2e76859d94dc",
            "https://git.kernel.org/stable/c/0c2cf5142bfb634c0ef0a1a69cdf37950747d0be",
            "https://git.kernel.org/stable/c/bb279ead42263e9fb09480f02a4247b2c287d828",
            "https://git.kernel.org/stable/c/7d42e097607c4d246d99225bf2b195b6167a210c",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: qat - resolve race condition during AER recovery\n\nDuring the PCI AER system's error recovery process, the kernel driver\nmay encounter a race condition with freeing the reset_data structure's\nmemory. If the device restart will take more than 10 seconds the function\nscheduling that restart will exit due to a timeout, and the reset_data\nstructure will be freed. However, this data structure is used for\ncompletion notification after the restart is completed, which leads\nto a UAF bug.\n\nThis results in a KFENCE bug notice.\n\n  BUG: KFENCE: use-after-free read in adf_device_reset_worker+0x38/0xa0 [intel_qat]\n  Use-after-free read at 0x00000000bc56fddf (in kfence-#142):\n  adf_device_reset_worker+0x38/0xa0 [intel_qat]\n  process_one_work+0x173/0x340\n\nTo resolve this race condition, the memory associated to the container\nof the work_struct is freed on the worker if the timeout expired,\notherwise on the function that schedules the worker.\nThe timeout detection can be done by checking if the caller is\nstill waiting for completion or not by using completion_done() function."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-01T06:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26981",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/bdbe483da21f852c93b22557b146bc4d989260f0",
            "https://git.kernel.org/stable/c/897ac5306bbeb83e90c437326f7044c79a17c611",
            "https://git.kernel.org/stable/c/2382eae66b196c31893984a538908c3eb7506ff9",
            "https://git.kernel.org/stable/c/90823f8d9ecca3d5fa6b102c8e464c62f416975f",
            "https://git.kernel.org/stable/c/c4a7dc9523b59b3e73fd522c73e95e072f876b16",
            "https://git.kernel.org/stable/c/054f29e9ca05be3906544c5f2a2c7321c30a4243",
            "https://git.kernel.org/stable/c/90f43980ea6be4ad903e389be9a27a2a0018f1c8",
            "https://git.kernel.org/stable/c/7061c7efbb9e8f11ce92d6b4646405ea2b0b4de1",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnilfs2: fix OOB in nilfs_set_de_type\n\nThe size of the nilfs_type_by_mode array in the fs/nilfs2/dir.c file is\ndefined as \"S_IFMT >> S_SHIFT\", but the nilfs_set_de_type() function,\nwhich uses this array, specifies the index to read from the array in the\nsame way as \"(mode & S_IFMT) >> S_SHIFT\".\n\nstatic void nilfs_set_de_type(struct nilfs_dir_entry *de, struct inode\n *inode)\n{\n\tumode_t mode = inode->i_mode;\n\n\tde->file_type = nilfs_type_by_mode[(mode & S_IFMT)>>S_SHIFT]; // oob\n}\n\nHowever, when the index is determined this way, an out-of-bounds (OOB)\nerror occurs by referring to an index that is 1 larger than the array size\nwhen the condition \"mode & S_IFMT == S_IFMT\" is satisfied.  Therefore, a\npatch to resize the nilfs_type_by_mode array should be applied to prevent\nOOB errors."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-01T06:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26976",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/ab2c2f5d9576112ad22cfd3798071cb74693b1f5",
            "https://git.kernel.org/stable/c/82e25cc1c2e93c3023da98be282322fc08b61ffb",
            "https://git.kernel.org/stable/c/f8730d6335e5f43d09151fca1f0f41922209a264",
            "https://git.kernel.org/stable/c/83d3c5e309611ef593e2fcb78444fc8ceedf9bac",
            "https://git.kernel.org/stable/c/b54478d20375874aeee257744dedfd3e413432ff",
            "https://git.kernel.org/stable/c/a75afe480d4349c524d9c659b1a5a544dbc39a98",
            "https://git.kernel.org/stable/c/4f3a3bce428fb439c66a578adc447afce7b4a750",
            "https://git.kernel.org/stable/c/caa9af2e27c275e089d702cfbaaece3b42bca31b",
            "https://git.kernel.org/stable/c/3d75b8aa5c29058a512db29da7cbee8052724157",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: Always flush async #PF workqueue when vCPU is being destroyed\n\nAlways flush the per-vCPU async #PF workqueue when a vCPU is clearing its\ncompletion queue, e.g. when a VM and all its vCPUs is being destroyed.\nKVM must ensure that none of its workqueue callbacks is running when the\nlast reference to the KVM _module_ is put.  Gifting a reference to the\nassociated VM prevents the workqueue callback from dereferencing freed\nvCPU/VM memory, but does not prevent the KVM module from being unloaded\nbefore the callback completes.\n\nDrop the misguided VM refcount gifting, as calling kvm_put_kvm() from\nasync_pf_execute() if kvm_put_kvm() flushes the async #PF workqueue will\nresult in deadlock.  async_pf_execute() can't return until kvm_put_kvm()\nfinishes, and kvm_put_kvm() can't return until async_pf_execute() finishes:\n\n WARNING: CPU: 8 PID: 251 at virt/kvm/kvm_main.c:1435 kvm_put_kvm+0x2d/0x320 [kvm]\n Modules linked in: vhost_net vhost vhost_iotlb tap kvm_intel kvm irqbypass\n CPU: 8 PID: 251 Comm: kworker/8:1 Tainted: G        W          6.6.0-rc1-e7af8d17224a-x86/gmem-vm #119\n Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015\n Workqueue: events async_pf_execute [kvm]\n RIP: 0010:kvm_put_kvm+0x2d/0x320 [kvm]\n Call Trace:\n  <TASK>\n  async_pf_execute+0x198/0x260 [kvm]\n  process_one_work+0x145/0x2d0\n  worker_thread+0x27e/0x3a0\n  kthread+0xba/0xe0\n  ret_from_fork+0x2d/0x50\n  ret_from_fork_asm+0x11/0x20\n  </TASK>\n ---[ end trace 0000000000000000 ]---\n INFO: task kworker/8:1:251 blocked for more than 120 seconds.\n       Tainted: G        W          6.6.0-rc1-e7af8d17224a-x86/gmem-vm #119\n \"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\" disables this message.\n task:kworker/8:1     state:D stack:0     pid:251   ppid:2      flags:0x00004000\n Workqueue: events async_pf_execute [kvm]\n Call Trace:\n  <TASK>\n  __schedule+0x33f/0xa40\n  schedule+0x53/0xc0\n  schedule_timeout+0x12a/0x140\n  __wait_for_common+0x8d/0x1d0\n  __flush_work.isra.0+0x19f/0x2c0\n  kvm_clear_async_pf_completion_queue+0x129/0x190 [kvm]\n  kvm_arch_destroy_vm+0x78/0x1b0 [kvm]\n  kvm_put_kvm+0x1c1/0x320 [kvm]\n  async_pf_execute+0x198/0x260 [kvm]\n  process_one_work+0x145/0x2d0\n  worker_thread+0x27e/0x3a0\n  kthread+0xba/0xe0\n  ret_from_fork+0x2d/0x50\n  ret_from_fork_asm+0x11/0x20\n  </TASK>\n\nIf kvm_clear_async_pf_completion_queue() actually flushes the workqueue,\nthen there's no need to gift async_pf_execute() a reference because all\ninvocations of async_pf_execute() will be forced to complete before the\nvCPU and its VM are destroyed/freed.  And that in turn fixes the module\nunloading bug as __fput() won't do module_put() on the last vCPU reference\nuntil the vCPU has been freed, e.g. if closing the vCPU file also puts the\nlast reference to the KVM module.\n\nNote that kvm_check_async_pf_completion() may also take the work item off\nthe completion queue and so also needs to flush the work queue, as the\nwork will not be seen by kvm_clear_async_pf_completion_queue().  Waiting\non the workqueue could theoretically delay a vCPU due to waiting for the\nwork to complete, but that's a very, very small chance, and likely a very\nsmall delay.  kvm_arch_async_page_present_queued() unconditionally makes a\nnew request, i.e. will effectively delay entering the guest, so the\nremaining work is really just:\n\n        trace_kvm_async_pf_completed(addr, cr2_or_gpa);\n\n        __kvm_vcpu_wake_up(vcpu);\n\n        mmput(mm);\n\nand mmput() can't drop the last reference to the page tables if the vCPU is\nstill alive, i.e. the vCPU won't get stuck tearing down page tables.\n\nAdd a helper to do the flushing, specifically to deal with \"wakeup all\"\nwork items, as they aren't actually work items, i.e. are never placed in a\nworkqueue.  Trying to flush a bogus workqueue entry rightly makes\n__flush_work() complain (kudos to whoever added that sanity check).\n\nNote, commit 5f6de5cbebee (\"KVM: Prevent module exit until al\n---truncated---"
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-01T06:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26994",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/0d130158db29f5e0b3893154908cf618896450a8",
            "https://git.kernel.org/stable/c/89af25bd4b4bf6a71295f07e07a8ae7dc03c6595",
            "https://git.kernel.org/stable/c/8defb1d22ba0395b81feb963b96e252b097ba76f",
            "https://git.kernel.org/stable/c/0efb15c14c493263cb3a5f65f5ddfd4603d19a76",
            "https://git.kernel.org/stable/c/c8d2f34ea96ea3bce6ba2535f867f0d4ee3b22e1",
            "https://git.kernel.org/stable/c/756c5cb7c09e537b87b5d3acafcb101b2ccf394f",
            "https://git.kernel.org/stable/c/8f6b62125befe1675446923e4171eac2c012959c",
            "https://git.kernel.org/stable/c/6401038acfa24cba9c28cce410b7505efadd0222",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nspeakup: Avoid crash on very long word\n\nIn case a console is set up really large and contains a really long word\n(> 256 characters), we have to stop before the length of the word buffer."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-01T06:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26988",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/0dc727a4e05400205358a22c3d01ccad2c8e1fe4",
            "https://git.kernel.org/stable/c/76c2f4d426a5358fced5d5990744d46f10a4ccea",
            "https://git.kernel.org/stable/c/81cf85ae4f2dd5fa3e43021782aa72c4c85558e8",
            "https://git.kernel.org/stable/c/936a02b5a9630c5beb0353c3085cc49d86c57034",
            "https://git.kernel.org/stable/c/46dad3c1e57897ab9228332f03e1c14798d2d3b9",
            "https://git.kernel.org/stable/c/2ef607ea103616aec0289f1b65d103d499fa903a",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ninit/main.c: Fix potential static_command_line memory overflow\n\nWe allocate memory of size 'xlen + strlen(boot_command_line) + 1' for\nstatic_command_line, but the strings copied into static_command_line are\nextra_command_line and command_line, rather than extra_command_line and\nboot_command_line.\n\nWhen strlen(command_line) > strlen(boot_command_line), static_command_line\nwill overflow.\n\nThis patch just recovers strlen(command_line) which was miss-consolidated\nwith strlen(boot_command_line) in the commit f5c7310ac73e (\"init/main: add\nchecks for the return value of memblock_alloc*()\")"
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-01T06:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26999",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/7a3bbe41efa55323b6ea3c35fa15941d4dbecdef",
            "https://git.kernel.org/stable/c/bbaafbb4651fede8d3c3881601ecaa4f834f9d3f",
            "https://git.kernel.org/stable/c/52aaf1ff14622a04148dbb9ccce6d9de5d534ea7",
            "https://git.kernel.org/stable/c/ca09dfc3cfdf89e6af3ac24e1c6c0be5c575a729",
            "https://git.kernel.org/stable/c/1be3226445362bfbf461c92a5bcdb1723f2e4907",
            "https://git.kernel.org/stable/c/69a02273e288011b521ee7c1f3ab2c23fda633ce",
            "https://git.kernel.org/stable/c/d679c816929d62af51c8e6d7fc0e165c9412d2f3",
            "https://git.kernel.org/stable/c/ab86cf6f8d24e63e9aca23da5108af1aa5483928",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nserial/pmac_zilog: Remove flawed mitigation for rx irq flood\n\nThe mitigation was intended to stop the irq completely. That may be\nbetter than a hard lock-up but it turns out that you get a crash anyway\nif you're using pmac_zilog as a serial console:\n\nttyPZ0: pmz: rx irq flood !\nBUG: spinlock recursion on CPU#0, swapper/0\n\nThat's because the pr_err() call in pmz_receive_chars() results in\npmz_console_write() attempting to lock a spinlock already locked in\npmz_interrupt(). With CONFIG_DEBUG_SPINLOCK=y, this produces a fatal\nBUG splat. The spinlock in question is the one in struct uart_port.\n\nEven when it's not fatal, the serial port rx function ceases to work.\nAlso, the iteration limit doesn't play nicely with QEMU, as can be\nseen in the bug report linked below.\n\nA web search for other reports of the error message \"pmz: rx irq flood\"\ndidn't produce anything. So I don't think this code is needed any more.\nRemove it."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-01T06:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-27001",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/b0b268eeb087e324ef3ea71f8e6cabd07630517f",
            "https://git.kernel.org/stable/c/ac882d6b21bffecb57bcc4486701239eef5aa67b",
            "https://git.kernel.org/stable/c/59f33af9796160f851641d960bd93937f282c696",
            "https://git.kernel.org/stable/c/6ec3514a7d35ad9cfab600187612c29f669069d2",
            "https://git.kernel.org/stable/c/d1718530e3f640b7d5f0050e725216eab57a85d8",
            "https://git.kernel.org/stable/c/3a63ae0348d990e137cca04eced5b08379969ea9",
            "https://git.kernel.org/stable/c/a3b8ae7e9297dd453f2977b011c5bc75eb20e71b",
            "https://git.kernel.org/stable/c/f15370e315976198f338b41611f37ce82af6cf54",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ncomedi: vmk80xx: fix incomplete endpoint checking\n\nWhile vmk80xx does have endpoint checking implemented, some things\ncan fall through the cracks. Depending on the hardware model,\nURBs can have either bulk or interrupt type, and current version\nof vmk80xx_find_usb_endpoints() function does not take that fully\ninto account. While this warning does not seem to be too harmful,\nat the very least it will crash systems with 'panic_on_warn' set on\nthem.\n\nFix the issue found by Syzkaller [1] by somewhat simplifying the\nendpoint checking process with usb_find_common_endpoints() and\nensuring that only expected endpoint types are present.\n\nThis patch has not been tested on real hardware.\n\n[1] Syzkaller report:\nusb 1-1: BOGUS urb xfer, pipe 1 != type 3\nWARNING: CPU: 0 PID: 781 at drivers/usb/core/urb.c:504 usb_submit_urb+0xc4e/0x18c0 drivers/usb/core/urb.c:503\n...\nCall Trace:\n <TASK>\n usb_start_wait_urb+0x113/0x520 drivers/usb/core/message.c:59\n vmk80xx_reset_device drivers/comedi/drivers/vmk80xx.c:227 [inline]\n vmk80xx_auto_attach+0xa1c/0x1a40 drivers/comedi/drivers/vmk80xx.c:818\n comedi_auto_config+0x238/0x380 drivers/comedi/drivers.c:1067\n usb_probe_interface+0x5cd/0xb00 drivers/usb/core/driver.c:399\n...\n\nSimilar issue also found by Syzkaller:"
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-05-01T06:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "CWE-770",
        "id": "CVE-2024-27013",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/a50dbeca28acf7051dfa92786b85f704c75db6eb",
            "https://git.kernel.org/stable/c/62e27ef18eb4f0d33bbae8e9ef56b99696a74713",
            "https://git.kernel.org/stable/c/40f4ced305c6c47487d3cd8da54676e2acc1a6ad",
            "https://git.kernel.org/stable/c/52854101180beccdb9dc2077a3bea31b6ad48dfa",
            "https://git.kernel.org/stable/c/f8bbc07ac535593139c875ffa19af924b1084540",
            "https://git.kernel.org/stable/c/68459b8e3ee554ce71878af9eb69659b9462c588",
            "https://git.kernel.org/stable/c/4b0dcae5c4797bf31c63011ed62917210d3fdac3",
            "https://git.kernel.org/stable/c/14cdb43dbc827e18ac7d5b30c5b4c676219f1421",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ntun: limit printing rate when illegal packet received by tun dev\n\nvhost_worker will call tun call backs to receive packets. If too many\nillegal packets arrives, tun_do_read will keep dumping packet contents.\nWhen console is enabled, it will costs much more cpu time to dump\npacket and soft lockup will be detected.\n\nnet_ratelimit mechanism can be used to limit the dumping rate.\n\nPID: 33036    TASK: ffff949da6f20000  CPU: 23   COMMAND: \"vhost-32980\"\n #0 [fffffe00003fce50] crash_nmi_callback at ffffffff89249253\n #1 [fffffe00003fce58] nmi_handle at ffffffff89225fa3\n #2 [fffffe00003fceb0] default_do_nmi at ffffffff8922642e\n #3 [fffffe00003fced0] do_nmi at ffffffff8922660d\n #4 [fffffe00003fcef0] end_repeat_nmi at ffffffff89c01663\n    [exception RIP: io_serial_in+20]\n    RIP: ffffffff89792594  RSP: ffffa655314979e8  RFLAGS: 00000002\n    RAX: ffffffff89792500  RBX: ffffffff8af428a0  RCX: 0000000000000000\n    RDX: 00000000000003fd  RSI: 0000000000000005  RDI: ffffffff8af428a0\n    RBP: 0000000000002710   R8: 0000000000000004   R9: 000000000000000f\n    R10: 0000000000000000  R11: ffffffff8acbf64f  R12: 0000000000000020\n    R13: ffffffff8acbf698  R14: 0000000000000058  R15: 0000000000000000\n    ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018\n #5 [ffffa655314979e8] io_serial_in at ffffffff89792594\n #6 [ffffa655314979e8] wait_for_xmitr at ffffffff89793470\n #7 [ffffa65531497a08] serial8250_console_putchar at ffffffff897934f6\n #8 [ffffa65531497a20] uart_console_write at ffffffff8978b605\n #9 [ffffa65531497a48] serial8250_console_write at ffffffff89796558\n #10 [ffffa65531497ac8] console_unlock at ffffffff89316124\n #11 [ffffa65531497b10] vprintk_emit at ffffffff89317c07\n #12 [ffffa65531497b68] printk at ffffffff89318306\n #13 [ffffa65531497bc8] print_hex_dump at ffffffff89650765\n #14 [ffffa65531497ca8] tun_do_read at ffffffffc0b06c27 [tun]\n #15 [ffffa65531497d38] tun_recvmsg at ffffffffc0b06e34 [tun]\n #16 [ffffa65531497d68] handle_rx at ffffffffc0c5d682 [vhost_net]\n #17 [ffffa65531497ed0] vhost_worker at ffffffffc0c644dc [vhost]\n #18 [ffffa65531497f10] kthread at ffffffff892d2e72\n #19 [ffffa65531497f50] ret_from_fork at ffffffff89c0022f"
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-25T06:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26923",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/e76c2678228f6aec74b305ae30c9374cc2f28a51",
            "https://git.kernel.org/stable/c/b75722be422c276b699200de90527d01c602ea7c",
            "https://git.kernel.org/stable/c/507cc232ffe53a352847893f8177d276c3b532a9",
            "https://git.kernel.org/stable/c/dbdf7bec5c920200077d693193f989cb1513f009",
            "https://git.kernel.org/stable/c/47d8ac011fe1c9251070e1bd64cb10b48193ec51",
            "https://git.kernel.org/stable/c/343c5372d5e17b306db5f8f3c895539b06e3177f",
            "https://git.kernel.org/stable/c/2e2a03787f4f0abc0072350654ab0ef3324d9db3",
            "https://git.kernel.org/stable/c/a36ae0ec2353015f0f6762e59f4c2dbc0c906423",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\naf_unix: Fix garbage collector racing against connect()\n\nGarbage collector does not take into account the risk of embryo getting\nenqueued during the garbage collection. If such embryo has a peer that\ncarries SCM_RIGHTS, two consecutive passes of scan_children() may see a\ndifferent set of children. Leading to an incorrectly elevated inflight\ncount, and then a dangling pointer within the gc_inflight_list.\n\nsockets are AF_UNIX/SOCK_STREAM\nS is an unconnected socket\nL is a listening in-flight socket bound to addr, not in fdtable\nV's fd will be passed via sendmsg(), gets inflight count bumped\n\nconnect(S, addr)\tsendmsg(S, [V]); close(V)\t__unix_gc()\n----------------\t-------------------------\t-----------\n\nNS = unix_create1()\nskb1 = sock_wmalloc(NS)\nL = unix_find_other(addr)\nunix_state_lock(L)\nunix_peer(S) = NS\n\t\t\t// V count=1 inflight=0\n\n \t\t\tNS = unix_peer(S)\n \t\t\tskb2 = sock_alloc()\n\t\t\tskb_queue_tail(NS, skb2[V])\n\n\t\t\t// V became in-flight\n\t\t\t// V count=2 inflight=1\n\n\t\t\tclose(V)\n\n\t\t\t// V count=1 inflight=1\n\t\t\t// GC candidate condition met\n\n\t\t\t\t\t\tfor u in gc_inflight_list:\n\t\t\t\t\t\t  if (total_refs == inflight_refs)\n\t\t\t\t\t\t    add u to gc_candidates\n\n\t\t\t\t\t\t// gc_candidates={L, V}\n\n\t\t\t\t\t\tfor u in gc_candidates:\n\t\t\t\t\t\t  scan_children(u, dec_inflight)\n\n\t\t\t\t\t\t// embryo (skb1) was not\n\t\t\t\t\t\t// reachable from L yet, so V's\n\t\t\t\t\t\t// inflight remains unchanged\n__skb_queue_tail(L, skb1)\nunix_state_unlock(L)\n\t\t\t\t\t\tfor u in gc_candidates:\n\t\t\t\t\t\t  if (u.inflight)\n\t\t\t\t\t\t    scan_children(u, inc_inflight_move_tail)\n\n\t\t\t\t\t\t// V count=1 inflight=2 (!)\n\nIf there is a GC-candidate listening socket, lock/unlock its state. This\nmakes GC wait until the end of any ongoing connect() to that socket. After\nflipping the lock, a possibly SCM-laden embryo is already enqueued. And if\nthere is another embryo coming, it can not possibly carry SCM_RIGHTS. At\nthis point, unix_inflight() can not happen because unix_gc_lock is already\ntaken. Inflight graph remains unaffected."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-25T06:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26926",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/aaef73821a3b0194a01bd23ca77774f704a04d40",
            "https://git.kernel.org/stable/c/a2fd6dbc98be1105a1d8e9e31575da8873ef115c",
            "https://git.kernel.org/stable/c/a6d2a8b211c874971ee4cf3ddd167408177f6e76",
            "https://git.kernel.org/stable/c/1d7f1049035b2060342f11eff957cf567d810bdc",
            "https://git.kernel.org/stable/c/f01d6619045704d78613b14e2e0420bfdb7f1c15",
            "https://git.kernel.org/stable/c/68a28f551e4690db2b27b3db716c7395f6fada12",
            "https://git.kernel.org/stable/c/48a1f83ca9c68518b1a783c62e6a8223144fa9fc",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nbinder: check offset alignment in binder_get_object()\n\nCommit 6d98eb95b450 (\"binder: avoid potential data leakage when copying\ntxn\") introduced changes to how binder objects are copied. In doing so,\nit unintentionally removed an offset alignment check done through calls\nto binder_alloc_copy_from_buffer() -> check_buffer().\n\nThese calls were replaced in binder_get_object() with copy_from_user(),\nso now an explicit offset alignment check is needed here. This avoids\nlater complications when unwinding the objects gets harder.\n\nIt is worth noting this check existed prior to commit 7a67a39320df\n(\"binder: add function to copy binder object from buffer\"), likely\nremoved due to redundancy at the time."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-23T13:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26922",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/6fef2d4c00b5b8561ad68dd2b68173f5c6af1e75",
            "https://git.kernel.org/stable/c/8b12fc7b032633539acdf7864888b0ebd49e90f2",
            "https://git.kernel.org/stable/c/212e3baccdb1939606420d88f7f52d346b49a284",
            "https://git.kernel.org/stable/c/ef13eeca7c79136bc38e21eb67322c1cbd5c40ee",
            "https://git.kernel.org/stable/c/b1f04b9b1c5317f562a455384c5f7473e46bdbaa",
            "https://git.kernel.org/stable/c/d4da6b084f1c5625937d49bb6722c5b4aef11b8d",
            "https://git.kernel.org/stable/c/f68039375d4d6d67303674c0ab2d06b7295c0ec9",
            "https://git.kernel.org/stable/c/1fd7db5c16028dc07b2ceec190f2e895dddb532d",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu: validate the parameters of bo mapping operations more clearly\n\nVerify the parameters of\namdgpu_vm_bo_(map/replace_map/clearing_mappings) in one common place."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-17T10:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26835",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/ae4360cbd385f0d7a8a86d5723e50448cc6318f3",
            "https://git.kernel.org/stable/c/31ea574aeca1aa488e18716459bde057217637af",
            "https://git.kernel.org/stable/c/664264a5c55bf97a9c571c557d477b75416199be",
            "https://git.kernel.org/stable/c/0c9302a6da262e6ab6a6c1d30f04a6130ed97376",
            "https://git.kernel.org/stable/c/f2135bbf14949687e96cabb13d8a91ae3deb9069",
            "https://git.kernel.org/stable/c/6f2496366426cec18ba53f1c7f6c3ac307ca6a95",
            "https://git.kernel.org/stable/c/bccebf64701735533c8db37773eeacc6566cc8ec",
            "https://git.kernel.org/stable/c/a6411f3c48f991c19aaf9a24fce36865fbba28d7",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_tables: set dormant flag on hook register failure\n\nWe need to set the dormant flag again if we fail to register\nthe hooks.\n\nDuring memory pressure hook registration can fail and we end up\nwith a table marked as active but no registered hooks.\n\nOn table/base chain deletion, nf_tables will attempt to unregister\nthe hook again which yields a warn splat from the nftables core."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-17T10:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26833",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/b49b022f7dfce85eb77d0d987008fde5c01d7857",
            "https://git.kernel.org/stable/c/33f649f1b1cea39ed360e6c12bba4fac83118e6e",
            "https://git.kernel.org/stable/c/58168005337eabef345a872be3f87d0215ff3b30",
            "https://git.kernel.org/stable/c/10c6b90e975358c17856a578419dc449887899c2",
            "https://git.kernel.org/stable/c/541e79265ea7e339a7c4a462feafe9f8f996e04b",
            "https://git.kernel.org/stable/c/bae67893578d608e35691dcdfa90c4957debf1d3",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Fix memory leak in dm_sw_fini()\n\nAfter destroying dmub_srv, the memory associated with it is\nnot freed, causing a memory leak:\n\nunreferenced object 0xffff896302b45800 (size 1024):\n  comm \"(udev-worker)\", pid 222, jiffies 4294894636\n  hex dump (first 32 bytes):\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n  backtrace (crc 6265fd77):\n    [<ffffffff993495ed>] kmalloc_trace+0x29d/0x340\n    [<ffffffffc0ea4a94>] dm_dmub_sw_init+0xb4/0x450 [amdgpu]\n    [<ffffffffc0ea4e55>] dm_sw_init+0x15/0x2b0 [amdgpu]\n    [<ffffffffc0ba8557>] amdgpu_device_init+0x1417/0x24e0 [amdgpu]\n    [<ffffffffc0bab285>] amdgpu_driver_load_kms+0x15/0x190 [amdgpu]\n    [<ffffffffc0ba09c7>] amdgpu_pci_probe+0x187/0x4e0 [amdgpu]\n    [<ffffffff9968fd1e>] local_pci_probe+0x3e/0x90\n    [<ffffffff996918a3>] pci_device_probe+0xc3/0x230\n    [<ffffffff99805872>] really_probe+0xe2/0x480\n    [<ffffffff99805c98>] __driver_probe_device+0x78/0x160\n    [<ffffffff99805daf>] driver_probe_device+0x1f/0x90\n    [<ffffffff9980601e>] __driver_attach+0xce/0x1c0\n    [<ffffffff99803170>] bus_for_each_dev+0x70/0xc0\n    [<ffffffff99804822>] bus_add_driver+0x112/0x210\n    [<ffffffff99807245>] driver_register+0x55/0x100\n    [<ffffffff990012d1>] do_one_initcall+0x41/0x300\n\nFix this by freeing dmub_srv after destroying it."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-17T11:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26863",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/e3b2bfb8ff1810a537b2aa55ba906a6743ed120c",
            "https://git.kernel.org/stable/c/889ed056eae7fda85b769a9ab33c093379c45428",
            "https://git.kernel.org/stable/c/7fb2d4d6bb1c85f7a23aace0ed6c86a95dea792a",
            "https://git.kernel.org/stable/c/a809bbfd0e503351d3051317288a70a4569a4949",
            "https://git.kernel.org/stable/c/1ed222ca7396938eb1ab2d034f1ba0d8b00a7122",
            "https://git.kernel.org/stable/c/39cc316fb3bc5e7c9dc5eed314fe510d119c6862",
            "https://git.kernel.org/stable/c/97d2148ea435dff4b4e71817c9032eb321bcd37e",
            "https://git.kernel.org/stable/c/09e5cdbe2cc88c3c758927644a3eb02fac317209",
            "https://git.kernel.org/stable/c/ddbec99f58571301679addbc022256970ca3eac6",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nhsr: Fix uninit-value access in hsr_get_node()\n\nKMSAN reported the following uninit-value access issue [1]:\n\n=====================================================\nBUG: KMSAN: uninit-value in hsr_get_node+0xa2e/0xa40 net/hsr/hsr_framereg.c:246\n hsr_get_node+0xa2e/0xa40 net/hsr/hsr_framereg.c:246\n fill_frame_info net/hsr/hsr_forward.c:577 [inline]\n hsr_forward_skb+0xe12/0x30e0 net/hsr/hsr_forward.c:615\n hsr_dev_xmit+0x1a1/0x270 net/hsr/hsr_device.c:223\n __netdev_start_xmit include/linux/netdevice.h:4940 [inline]\n netdev_start_xmit include/linux/netdevice.h:4954 [inline]\n xmit_one net/core/dev.c:3548 [inline]\n dev_hard_start_xmit+0x247/0xa10 net/core/dev.c:3564\n __dev_queue_xmit+0x33b8/0x5130 net/core/dev.c:4349\n dev_queue_xmit include/linux/netdevice.h:3134 [inline]\n packet_xmit+0x9c/0x6b0 net/packet/af_packet.c:276\n packet_snd net/packet/af_packet.c:3087 [inline]\n packet_sendmsg+0x8b1d/0x9f30 net/packet/af_packet.c:3119\n sock_sendmsg_nosec net/socket.c:730 [inline]\n __sock_sendmsg net/socket.c:745 [inline]\n __sys_sendto+0x735/0xa10 net/socket.c:2191\n __do_sys_sendto net/socket.c:2203 [inline]\n __se_sys_sendto net/socket.c:2199 [inline]\n __x64_sys_sendto+0x125/0x1c0 net/socket.c:2199\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0x6d/0x140 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x63/0x6b\n\nUninit was created at:\n slab_post_alloc_hook+0x129/0xa70 mm/slab.h:768\n slab_alloc_node mm/slub.c:3478 [inline]\n kmem_cache_alloc_node+0x5e9/0xb10 mm/slub.c:3523\n kmalloc_reserve+0x13d/0x4a0 net/core/skbuff.c:560\n __alloc_skb+0x318/0x740 net/core/skbuff.c:651\n alloc_skb include/linux/skbuff.h:1286 [inline]\n alloc_skb_with_frags+0xc8/0xbd0 net/core/skbuff.c:6334\n sock_alloc_send_pskb+0xa80/0xbf0 net/core/sock.c:2787\n packet_alloc_skb net/packet/af_packet.c:2936 [inline]\n packet_snd net/packet/af_packet.c:3030 [inline]\n packet_sendmsg+0x70e8/0x9f30 net/packet/af_packet.c:3119\n sock_sendmsg_nosec net/socket.c:730 [inline]\n __sock_sendmsg net/socket.c:745 [inline]\n __sys_sendto+0x735/0xa10 net/socket.c:2191\n __do_sys_sendto net/socket.c:2203 [inline]\n __se_sys_sendto net/socket.c:2199 [inline]\n __x64_sys_sendto+0x125/0x1c0 net/socket.c:2199\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0x6d/0x140 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x63/0x6b\n\nCPU: 1 PID: 5033 Comm: syz-executor334 Not tainted 6.7.0-syzkaller-00562-g9f8413c4a66f #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 11/17/2023\n=====================================================\n\nIf the packet type ID field in the Ethernet header is either ETH_P_PRP or\nETH_P_HSR, but it is not followed by an HSR tag, hsr_get_skb_sequence_nr()\nreads an invalid value as a sequence number. This causes the above issue.\n\nThis patch fixes the issue by returning NULL if the Ethernet header is not\nfollowed by an HSR tag."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-17T11:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26870",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/4403438eaca6e91f02d272211c4d6b045092396b",
            "https://git.kernel.org/stable/c/9d52865ff28245fc2134da9f99baff603a24407a",
            "https://git.kernel.org/stable/c/06e828b3f1b206de08ef520fc46a40b22e1869cb",
            "https://git.kernel.org/stable/c/79cdcc765969d23f4e3d6ea115660c3333498768",
            "https://git.kernel.org/stable/c/80365c9f96015bbf048fdd6c8705d3f8770132bf",
            "https://git.kernel.org/stable/c/23bfecb4d852751d5e403557dd500bb563313baf",
            "https://git.kernel.org/stable/c/251a658bbfceafb4d58c76b77682c8bf7bcfad65",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFSv4.2: fix nfs4_listxattr kernel BUG at mm/usercopy.c:102\n\nA call to listxattr() with a buffer size = 0 returns the actual\nsize of the buffer needed for a subsequent call. When size > 0,\nnfs4_listxattr() does not return an error because either\ngeneric_listxattr() or nfs4_listxattr_nfs4_label() consumes\nexactly all the bytes then size is 0 when calling\nnfs4_listxattr_nfs4_user() which then triggers the following\nkernel BUG:\n\n  [   99.403778] kernel BUG at mm/usercopy.c:102!\n  [   99.404063] Internal error: Oops - BUG: 00000000f2000800 [#1] SMP\n  [   99.408463] CPU: 0 PID: 3310 Comm: python3 Not tainted 6.6.0-61.fc40.aarch64 #1\n  [   99.415827] Call trace:\n  [   99.415985]  usercopy_abort+0x70/0xa0\n  [   99.416227]  __check_heap_object+0x134/0x158\n  [   99.416505]  check_heap_object+0x150/0x188\n  [   99.416696]  __check_object_size.part.0+0x78/0x168\n  [   99.416886]  __check_object_size+0x28/0x40\n  [   99.417078]  listxattr+0x8c/0x120\n  [   99.417252]  path_listxattr+0x78/0xe0\n  [   99.417476]  __arm64_sys_listxattr+0x28/0x40\n  [   99.417723]  invoke_syscall+0x78/0x100\n  [   99.417929]  el0_svc_common.constprop.0+0x48/0xf0\n  [   99.418186]  do_el0_svc+0x24/0x38\n  [   99.418376]  el0_svc+0x3c/0x110\n  [   99.418554]  el0t_64_sync_handler+0x120/0x130\n  [   99.418788]  el0t_64_sync+0x194/0x198\n  [   99.418994] Code: aa0003e3 d000a3e0 91310000 97f49bdb (d4210000)\n\nIssue is reproduced when generic_listxattr() returns 'system.nfs4_acl',\nthus calling lisxattr() with size = 16 will trigger the bug.\n\nAdd check on nfs4_listxattr() to return ERANGE error when it is\ncalled with size > 0 and the return value is greater than size."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-17T10:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26845",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/425a571a7e6fc389954cf2564e1edbba3740e171",
            "https://git.kernel.org/stable/c/11f3fe5001ed05721e641f0ecaa7a73b7deb245d",
            "https://git.kernel.org/stable/c/168ed59170de1fd7274080fe102216162d6826cf",
            "https://git.kernel.org/stable/c/a9849b67b4402a12eb35eadc9306c1ef9847d53d",
            "https://git.kernel.org/stable/c/e717bd412001495f17400bfc09f606f1b594ef5a",
            "https://git.kernel.org/stable/c/36bc5040c863b44af06094b22f1e50059227b9cb",
            "https://git.kernel.org/stable/c/bd508f96b5fef96d8a0ce9cbb211d82bcfc2341f",
            "https://git.kernel.org/stable/c/83ab68168a3d990d5ff39ab030ad5754cbbccb25",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: target: core: Add TMF to tmr_list handling\n\nAn abort that is responded to by iSCSI itself is added to tmr_list but does\nnot go to target core. A LUN_RESET that goes through tmr_list takes a\nrefcounter on the abort and waits for completion. However, the abort will\nbe never complete because it was not started in target core.\n\n Unable to locate ITT: 0x05000000 on CID: 0\n Unable to locate RefTaskTag: 0x05000000 on CID: 0.\n wait_for_tasks: Stopping tmf LUN_RESET with tag 0x0 ref_task_tag 0x0 i_state 34 t_state ISTATE_PROCESSING refcnt 2 transport_state active,stop,fabric_stop\n wait for tasks: tmf LUN_RESET with tag 0x0 ref_task_tag 0x0 i_state 34 t_state ISTATE_PROCESSING refcnt 2 transport_state active,stop,fabric_stop\n...\n INFO: task kworker/0:2:49 blocked for more than 491 seconds.\n task:kworker/0:2     state:D stack:    0 pid:   49 ppid:     2 flags:0x00000800\n Workqueue: events target_tmr_work [target_core_mod]\nCall Trace:\n __switch_to+0x2c4/0x470\n _schedule+0x314/0x1730\n schedule+0x64/0x130\n schedule_timeout+0x168/0x430\n wait_for_completion+0x140/0x270\n target_put_cmd_and_wait+0x64/0xb0 [target_core_mod]\n core_tmr_lun_reset+0x30/0xa0 [target_core_mod]\n target_tmr_work+0xc8/0x1b0 [target_core_mod]\n process_one_work+0x2d4/0x5d0\n worker_thread+0x78/0x6c0\n\nTo fix this, only add abort to tmr_list if it will be handled by target\ncore."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-17T11:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26895",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/5956f4203b6cdd0755bbdd21b45f3933c7026208",
            "https://git.kernel.org/stable/c/fe20e3d56bc911408fc3c27a17c59e9d7885f7d1",
            "https://git.kernel.org/stable/c/a9545af2a533739ffb64d6c9a6fec6f13e2b505f",
            "https://git.kernel.org/stable/c/3da9d32b7f4a1a9f7e4bb15bb82f2b2dd6719447",
            "https://git.kernel.org/stable/c/24228dcf1d30c2231caa332be7d3090ac59fbfe9",
            "https://git.kernel.org/stable/c/73a2aa0aef86c2c07be5a2f42c9e6047e1a2f7bb",
            "https://git.kernel.org/stable/c/cb5942b77c05d54310a0420cac12935e9b6aa21c",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: wilc1000: prevent use-after-free on vif when cleaning up all interfaces\n\nwilc_netdev_cleanup currently triggers a KASAN warning, which can be\nobserved on interface registration error path, or simply by\nremoving the module/unbinding device from driver:\n\necho spi0.1 > /sys/bus/spi/drivers/wilc1000_spi/unbind\n\n==================================================================\nBUG: KASAN: slab-use-after-free in wilc_netdev_cleanup+0x508/0x5cc\nRead of size 4 at addr c54d1ce8 by task sh/86\n\nCPU: 0 PID: 86 Comm: sh Not tainted 6.8.0-rc1+ #117\nHardware name: Atmel SAMA5\n unwind_backtrace from show_stack+0x18/0x1c\n show_stack from dump_stack_lvl+0x34/0x58\n dump_stack_lvl from print_report+0x154/0x500\n print_report from kasan_report+0xac/0xd8\n kasan_report from wilc_netdev_cleanup+0x508/0x5cc\n wilc_netdev_cleanup from wilc_bus_remove+0xc8/0xec\n wilc_bus_remove from spi_remove+0x8c/0xac\n spi_remove from device_release_driver_internal+0x434/0x5f8\n device_release_driver_internal from unbind_store+0xbc/0x108\n unbind_store from kernfs_fop_write_iter+0x398/0x584\n kernfs_fop_write_iter from vfs_write+0x728/0xf88\n vfs_write from ksys_write+0x110/0x1e4\n ksys_write from ret_fast_syscall+0x0/0x1c\n\n[...]\n\nAllocated by task 1:\n kasan_save_track+0x30/0x5c\n __kasan_kmalloc+0x8c/0x94\n __kmalloc_node+0x1cc/0x3e4\n kvmalloc_node+0x48/0x180\n alloc_netdev_mqs+0x68/0x11dc\n alloc_etherdev_mqs+0x28/0x34\n wilc_netdev_ifc_init+0x34/0x8ec\n wilc_cfg80211_init+0x690/0x910\n wilc_bus_probe+0xe0/0x4a0\n spi_probe+0x158/0x1b0\n really_probe+0x270/0xdf4\n __driver_probe_device+0x1dc/0x580\n driver_probe_device+0x60/0x140\n __driver_attach+0x228/0x5d4\n bus_for_each_dev+0x13c/0x1a8\n bus_add_driver+0x2a0/0x608\n driver_register+0x24c/0x578\n do_one_initcall+0x180/0x310\n kernel_init_freeable+0x424/0x484\n kernel_init+0x20/0x148\n ret_from_fork+0x14/0x28\n\nFreed by task 86:\n kasan_save_track+0x30/0x5c\n kasan_save_free_info+0x38/0x58\n __kasan_slab_free+0xe4/0x140\n kfree+0xb0/0x238\n device_release+0xc0/0x2a8\n kobject_put+0x1d4/0x46c\n netdev_run_todo+0x8fc/0x11d0\n wilc_netdev_cleanup+0x1e4/0x5cc\n wilc_bus_remove+0xc8/0xec\n spi_remove+0x8c/0xac\n device_release_driver_internal+0x434/0x5f8\n unbind_store+0xbc/0x108\n kernfs_fop_write_iter+0x398/0x584\n vfs_write+0x728/0xf88\n ksys_write+0x110/0x1e4\n ret_fast_syscall+0x0/0x1c\n [...]\n\nDavid Mosberger-Tan initial investigation [1] showed that this\nuse-after-free is due to netdevice unregistration during vif list\ntraversal. When unregistering a net device, since the needs_free_netdev has\nbeen set to true during registration, the netdevice object is also freed,\nand as a consequence, the corresponding vif object too, since it is\nattached to it as private netdevice data. The next occurrence of the loop\nthen tries to access freed vif pointer to the list to move forward in the\nlist.\n\nFix this use-after-free thanks to two mechanisms:\n- navigate in the list with list_for_each_entry_safe, which allows to\n  safely modify the list as we go through each element. For each element,\n  remove it from the list with list_del_rcu\n- make sure to wait for RCU grace period end after each vif removal to make\n  sure it is safe to free the corresponding vif too (through\n  unregister_netdev)\n\nSince we are in a RCU \"modifier\" path (not a \"reader\" path), and because\nsuch path is expected not to be concurrent to any other modifier (we are\nusing the vif_mutex lock), we do not need to use RCU list API, that's why\nwe can benefit from list_for_each_entry_safe.\n\n[1] https://lore.kernel.org/linux-wireless/ab077dbe58b1ea5de0a3b2ca21f275a07af967d2.camel@egauge.net/"
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-17T11:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26897",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/1bc5461a21c56a36e2a7d81e152b90ce019a3905",
            "https://git.kernel.org/stable/c/f8ff4b4df71e87f609be0cc37d92e918107f9b90",
            "https://git.kernel.org/stable/c/74d0639261dd795dce958d1b14815bdcbb48a715",
            "https://git.kernel.org/stable/c/a015fbf698c8957aa5fbeefc5c59dd2cf3107298",
            "https://git.kernel.org/stable/c/ac90e22e735bac44f74b5161fb096fbeb0ff8bc2",
            "https://git.kernel.org/stable/c/4afa0246656d5680c8a4c3fb37ba6570c4ab819b",
            "https://git.kernel.org/stable/c/24355fcb0d4cbcb6ddda262596558e8cfba70f11",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath9k: delay all of ath9k_wmi_event_tasklet() until init is complete\n\nThe ath9k_wmi_event_tasklet() used in ath9k_htc assumes that all the data\nstructures have been fully initialised by the time it runs. However, because of\nthe order in which things are initialised, this is not guaranteed to be the\ncase, because the device is exposed to the USB subsystem before the ath9k driver\ninitialisation is completed.\n\nWe already committed a partial fix for this in commit:\n8b3046abc99e (\"ath9k_htc: fix NULL pointer dereference at ath9k_htc_tx_get_packet()\")\n\nHowever, that commit only aborted the WMI_TXSTATUS_EVENTID command in the event\ntasklet, pairing it with an \"initialisation complete\" bit in the TX struct. It\nseems syzbot managed to trigger the race for one of the other commands as well,\nso let's just move the existing synchronisation bit to cover the whole\ntasklet (setting it at the end of ath9k_htc_probe_device() instead of inside\nath9k_tx_init())."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-17T11:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26877",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/8a01335aedc50a66d04dd39203c89f4bc8042596",
            "https://git.kernel.org/stable/c/03e6d4e948432a61b35783323b6ab2be071d2619",
            "https://git.kernel.org/stable/c/a71f66bd5f7b9b35a8aaa49e29565eca66299399",
            "https://git.kernel.org/stable/c/23bc89fdce71124cd2126fc919c7076e7cb489cf",
            "https://git.kernel.org/stable/c/9db89b1fb85557892e6681724b367287de5f9f20",
            "https://git.kernel.org/stable/c/dbf291d8ffffb70f48286176a15c6c54f0bb0743",
            "https://git.kernel.org/stable/c/a853450bf4c752e664abab0b2fad395b7ad7701c",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: xilinx - call finalize with bh disabled\n\nWhen calling crypto_finalize_request, BH should be disabled to avoid\ntriggering the following calltrace:\n\n    ------------[ cut here ]------------\n    WARNING: CPU: 2 PID: 74 at crypto/crypto_engine.c:58 crypto_finalize_request+0xa0/0x118\n    Modules linked in: cryptodev(O)\n    CPU: 2 PID: 74 Comm: firmware:zynqmp Tainted: G           O       6.8.0-rc1-yocto-standard #323\n    Hardware name: ZynqMP ZCU102 Rev1.0 (DT)\n    pstate: 40000005 (nZcv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n    pc : crypto_finalize_request+0xa0/0x118\n    lr : crypto_finalize_request+0x104/0x118\n    sp : ffffffc085353ce0\n    x29: ffffffc085353ce0 x28: 0000000000000000 x27: ffffff8808ea8688\n    x26: ffffffc081715038 x25: 0000000000000000 x24: ffffff880100db00\n    x23: ffffff880100da80 x22: 0000000000000000 x21: 0000000000000000\n    x20: ffffff8805b14000 x19: ffffff880100da80 x18: 0000000000010450\n    x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000\n    x14: 0000000000000003 x13: 0000000000000000 x12: ffffff880100dad0\n    x11: 0000000000000000 x10: ffffffc0832dcd08 x9 : ffffffc0812416d8\n    x8 : 00000000000001f4 x7 : ffffffc0830d2830 x6 : 0000000000000001\n    x5 : ffffffc082091000 x4 : ffffffc082091658 x3 : 0000000000000000\n    x2 : ffffffc7f9653000 x1 : 0000000000000000 x0 : ffffff8802d20000\n    Call trace:\n     crypto_finalize_request+0xa0/0x118\n     crypto_finalize_aead_request+0x18/0x30\n     zynqmp_handle_aes_req+0xcc/0x388\n     crypto_pump_work+0x168/0x2d8\n     kthread_worker_fn+0xfc/0x3a0\n     kthread+0x118/0x138\n     ret_from_fork+0x10/0x20\n    irq event stamp: 40\n    hardirqs last  enabled at (39): [<ffffffc0812416f8>] _raw_spin_unlock_irqrestore+0x70/0xb0\n    hardirqs last disabled at (40): [<ffffffc08122d208>] el1_dbg+0x28/0x90\n    softirqs last  enabled at (36): [<ffffffc080017dec>] kernel_neon_begin+0x8c/0xf0\n    softirqs last disabled at (34): [<ffffffc080017dc0>] kernel_neon_begin+0x60/0xf0\n    ---[ end trace 0000000000000000 ]---"
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-17T10:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26825",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/7e9a8498658b398bf11b8e388005fa54e40aed81",
            "https://git.kernel.org/stable/c/71349abe3aba7fedcab5b3fcd7aa82371fb5ccbf",
            "https://git.kernel.org/stable/c/2f6d16f0520d6505241629ee2f5c131b547d5f9d",
            "https://git.kernel.org/stable/c/471c9ede8061357b43a116fa692e70d91941ac23",
            "https://git.kernel.org/stable/c/5c0c5ffaed73cbae6c317374dc32ba6cacc60895",
            "https://git.kernel.org/stable/c/16d3f507b0fa70453dc54550df093d6e9ac630c1",
            "https://git.kernel.org/stable/c/a3d90fb5c23f29ba59c04005ae76c5228cef2be9",
            "https://git.kernel.org/stable/c/bfb007aebe6bff451f7f3a4be19f4f286d0d5d9c",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfc: nci: free rx_data_reassembly skb on NCI device cleanup\n\nrx_data_reassembly skb is stored during NCI data exchange for processing\nfragmented packets. It is dropped only when the last fragment is processed\nor when an NTF packet with NCI_OP_RF_DEACTIVATE_NTF opcode is received.\nHowever, the NCI device may be deallocated before that which leads to skb\nleak.\n\nAs by design the rx_data_reassembly skb is bound to the NCI device and\nnothing prevents the device to be freed before the skb is processed in\nsome way and cleaned, free it on the NCI device cleanup.\n\nFound by Linux Verification Center (linuxtesting.org) with Syzkaller."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-17T10:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26840",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/cb5466783793e66272624cf71925ae1d1ba32083",
            "https://git.kernel.org/stable/c/037d5a949b0455540ef9aab34c10ddf54b65d285",
            "https://git.kernel.org/stable/c/43eccc5823732ba6daab2511ed32dfc545a666d8",
            "https://git.kernel.org/stable/c/94965be37add0983672e48ecb33cdbda92b62579",
            "https://git.kernel.org/stable/c/8b218e2f0a27a9f09428b1847b4580640b9d1e58",
            "https://git.kernel.org/stable/c/38e921616320d159336b0ffadb09e9fb4945c7c3",
            "https://git.kernel.org/stable/c/9cac69912052a4def571fedf1cb9bb4ec590e25a",
            "https://git.kernel.org/stable/c/e21a2f17566cbd64926fb8f16323972f7a064444",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ncachefiles: fix memory leak in cachefiles_add_cache()\n\nThe following memory leak was reported after unbinding /dev/cachefiles:\n\n==================================================================\nunreferenced object 0xffff9b674176e3c0 (size 192):\n  comm \"cachefilesd2\", pid 680, jiffies 4294881224\n  hex dump (first 32 bytes):\n    01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n    00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n  backtrace (crc ea38a44b):\n    [<ffffffff8eb8a1a5>] kmem_cache_alloc+0x2d5/0x370\n    [<ffffffff8e917f86>] prepare_creds+0x26/0x2e0\n    [<ffffffffc002eeef>] cachefiles_determine_cache_security+0x1f/0x120\n    [<ffffffffc00243ec>] cachefiles_add_cache+0x13c/0x3a0\n    [<ffffffffc0025216>] cachefiles_daemon_write+0x146/0x1c0\n    [<ffffffff8ebc4a3b>] vfs_write+0xcb/0x520\n    [<ffffffff8ebc5069>] ksys_write+0x69/0xf0\n    [<ffffffff8f6d4662>] do_syscall_64+0x72/0x140\n    [<ffffffff8f8000aa>] entry_SYSCALL_64_after_hwframe+0x6e/0x76\n==================================================================\n\nPut the reference count of cache_cred in cachefiles_daemon_unbind() to\nfix the problem. And also put cache_cred in cachefiles_add_cache() error\nbranch to avoid memory leaks."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-04-17T11:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26889",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/6d5a9d4a7bcbb7534ce45a18a52e7bd23e69d8ac",
            "https://git.kernel.org/stable/c/54a03e4ac1a41edf8a5087bd59f8241b0de96d3d",
            "https://git.kernel.org/stable/c/d47e6c1932cee02954ea588c9f09fd5ecefeadfc",
            "https://git.kernel.org/stable/c/2e845867b4e279eff0a19ade253390470e07e8a1",
            "https://git.kernel.org/stable/c/68644bf5ec6baaff40fc39b3529c874bfda709bd",
            "https://git.kernel.org/stable/c/a41c8efe659caed0e21422876bbb6b73c15b5244",
            "https://git.kernel.org/stable/c/8c28598a2c29201d2ba7fc37539a7d41c264fb10",
            "https://git.kernel.org/stable/c/2edce8e9a99dd5e4404259d52e754fdc97fb42c2",
            "https://git.kernel.org/stable/c/81137162bfaa7278785b24c1fd2e9e74f082e8e4",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: hci_core: Fix possible buffer overflow\n\nstruct hci_dev_info has a fixed size name[8] field so in the event that\nhdev->name is bigger than that strcpy would attempt to write past its\nsize, so this fixes this problem by switching to use strscpy."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-03-14T17:15:00",
        "access": {},
        "assigner": "secure@intel.com",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2023-28746",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00898.html",
            "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZON4TLXG7TG4A2XZG563JMVTGQW4SF3A/",
            "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/H63LGAQXPEVJOES73U4XK65I6DASOAAG/",
            "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/EIUICU6CVJUIB6BPJ7P5QTPQR5VOBHFK/",
            "http://www.openwall.com/lists/oss-security/2024/03/12/13",
            "https://lists.debian.org/debian-lts-announce/2024/05/msg00003.html",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "Information exposure through microarchitectural state after transient execution from some register files for some Intel(R) Atom(R) Processors may allow an authenticated user to potentially enable information disclosure via local access."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-03-11T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2023-52486",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/376e21a9e4c2c63ee5d8d3aa74be5082c3882229",
            "https://git.kernel.org/stable/c/9dd334a8245011ace45e53298175c7b659edb3e7",
            "https://git.kernel.org/stable/c/f55261469be87c55df13db76dc945f6bcd825105",
            "https://git.kernel.org/stable/c/b4af63da9d94986c529d74499fdfe44289acd551",
            "https://git.kernel.org/stable/c/62f2e79cf9f4f47cc9dea9cebdf58d9f7b5695e0",
            "https://git.kernel.org/stable/c/d7afdf360f4ac142832b098b4de974e867cc063c",
            "https://git.kernel.org/stable/c/bfd0feb1b109cb63b87fdcd00122603787c75a1a",
            "https://git.kernel.org/stable/c/cb4daf271302d71a6b9a7c01bd0b6d76febd8f0c",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm: Don't unref the same fb many times by mistake due to deadlock handling\n\nIf we get a deadlock after the fb lookup in drm_mode_page_flip_ioctl()\nwe proceed to unref the fb and then retry the whole thing from the top.\nBut we forget to reset the fb pointer back to NULL, and so if we then\nget another error during the retry, before the fb lookup, we proceed\nthe unref the same fb again without having gotten another reference.\nThe end result is that the fb will (eventually) end up being freed\nwhile it's still in use.\n\nReset fb to NULL once we've unreffed it to avoid doing it again\nuntil we've done another fb lookup.\n\nThis turned out to be pretty easy to hit on a DG2 when doing async\nflips (and CONFIG_DEBUG_WW_MUTEX_SLOWPATH=y). The first symptom I\nsaw that drm_closefb() simply got stuck in a busy loop while walking\nthe framebuffer list. Fortunately I was able to convince it to oops\ninstead, and from there it was easier to track down the culprit."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-03-11T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2023-52489",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/90ad17575d26874287271127d43ef3c2af876cea",
            "https://git.kernel.org/stable/c/b448de2459b6d62a53892487ab18b7d823ff0529",
            "https://git.kernel.org/stable/c/68ed9e33324021e9d6b798e9db00ca3093d2012a",
            "https://git.kernel.org/stable/c/70064241f2229f7ba7b9599a98f68d9142e81a97",
            "https://git.kernel.org/stable/c/3a01daace71b521563c38bbbf874e14c3e58adb7",
            "https://git.kernel.org/stable/c/5ec8e8ea8b7783fab150cf86404fc38cb4db8800",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/sparsemem: fix race in accessing memory_section->usage\n\nThe below race is observed on a PFN which falls into the device memory\nregion with the system memory configuration where PFN's are such that\n[ZONE_NORMAL ZONE_DEVICE ZONE_NORMAL].  Since normal zone start and end\npfn contains the device memory PFN's as well, the compaction triggered\nwill try on the device memory PFN's too though they end up in NOP(because\npfn_to_online_page() returns NULL for ZONE_DEVICE memory sections).  When\nfrom other core, the section mappings are being removed for the\nZONE_DEVICE region, that the PFN in question belongs to, on which\ncompaction is currently being operated is resulting into the kernel crash\nwith CONFIG_SPASEMEM_VMEMAP enabled.  The crash logs can be seen at [1].\n\ncompact_zone()\t\t\tmemunmap_pages\n-------------\t\t\t---------------\n__pageblock_pfn_to_page\n   ......\n (a)pfn_valid():\n     valid_section()//return true\n\t\t\t      (b)__remove_pages()->\n\t\t\t\t  sparse_remove_section()->\n\t\t\t\t    section_deactivate():\n\t\t\t\t    [Free the array ms->usage and set\n\t\t\t\t     ms->usage = NULL]\n     pfn_section_valid()\n     [Access ms->usage which\n     is NULL]\n\nNOTE: From the above it can be said that the race is reduced to between\nthe pfn_valid()/pfn_section_valid() and the section deactivate with\nSPASEMEM_VMEMAP enabled.\n\nThe commit b943f045a9af(\"mm/sparse: fix kernel crash with\npfn_section_valid check\") tried to address the same problem by clearing\nthe SECTION_HAS_MEM_MAP with the expectation of valid_section() returns\nfalse thus ms->usage is not accessed.\n\nFix this issue by the below steps:\n\na) Clear SECTION_HAS_MEM_MAP before freeing the ->usage.\n\nb) RCU protected read side critical section will either return NULL\n   when SECTION_HAS_MEM_MAP is cleared or can successfully access ->usage.\n\nc) Free the ->usage with kfree_rcu() and set ms->usage = NULL.  No\n   attempt will be made to access ->usage after this as the\n   SECTION_HAS_MEM_MAP is cleared thus valid_section() return false.\n\nThanks to David/Pavan for their inputs on this patch.\n\n[1] https://lore.kernel.org/linux-mm/994410bb-89aa-d987-1f50-f514903c55aa@quicinc.com/\n\nOn Snapdragon SoC, with the mentioned memory configuration of PFN's as\n[ZONE_NORMAL ZONE_DEVICE ZONE_NORMAL], we are able to see bunch of\nissues daily while testing on a device farm.\n\nFor this particular issue below is the log.  Though the below log is\nnot directly pointing to the pfn_section_valid(){ ms->usage;}, when we\nloaded this dump on T32 lauterbach tool, it is pointing.\n\n[  540.578056] Unable to handle kernel NULL pointer dereference at\nvirtual address 0000000000000000\n[  540.578068] Mem abort info:\n[  540.578070]   ESR = 0x0000000096000005\n[  540.578073]   EC = 0x25: DABT (current EL), IL = 32 bits\n[  540.578077]   SET = 0, FnV = 0\n[  540.578080]   EA = 0, S1PTW = 0\n[  540.578082]   FSC = 0x05: level 1 translation fault\n[  540.578085] Data abort info:\n[  540.578086]   ISV = 0, ISS = 0x00000005\n[  540.578088]   CM = 0, WnR = 0\n[  540.579431] pstate: 82400005 (Nzcv daif +PAN -UAO +TCO -DIT -SSBSBTYPE=--)\n[  540.579436] pc : __pageblock_pfn_to_page+0x6c/0x14c\n[  540.579454] lr : compact_zone+0x994/0x1058\n[  540.579460] sp : ffffffc03579b510\n[  540.579463] x29: ffffffc03579b510 x28: 0000000000235800 x27:000000000000000c\n[  540.579470] x26: 0000000000235c00 x25: 0000000000000068 x24:ffffffc03579b640\n[  540.579477] x23: 0000000000000001 x22: ffffffc03579b660 x21:0000000000000000\n[  540.579483] x20: 0000000000235bff x19: ffffffdebf7e3940 x18:ffffffdebf66d140\n[  540.579489] x17: 00000000739ba063 x16: 00000000739ba063 x15:00000000009f4bff\n[  540.579495] x14: 0000008000000000 x13: 0000000000000000 x12:0000000000000001\n[  540.579501] x11: 0000000000000000 x10: 0000000000000000 x9 :ffffff897d2cd440\n[  540.579507] x8 : 0000000000000000 x7 : 0000000000000000 x6 :ffffffc03579b5b4\n[  540.579512] x5 : 0000000000027f25 x4 : ffffffc03579b5b8 x3 :0000000000000\n---truncated---"
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-03-06T07:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2023-52600",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/81b4249ef37297fb17ba102a524039a05c6c5d35",
            "https://git.kernel.org/stable/c/93df0a2a0b3cde2d7ab3a52ed46ea1d6d4aaba5f",
            "https://git.kernel.org/stable/c/bc6ef64dbe71136f327d63b2b9071b828af2c2a8",
            "https://git.kernel.org/stable/c/8e44dc3f96e903815dab1d74fff8faafdc6feb61",
            "https://git.kernel.org/stable/c/32e8f2d95528d45828c613417cb2827d866cbdce",
            "https://git.kernel.org/stable/c/1696d6d7d4a1b373e96428d0fe1166bd7c3c795e",
            "https://git.kernel.org/stable/c/bacdaa04251382d7efd4f09f9a0686bfcc297e2e",
            "https://git.kernel.org/stable/c/e0e1958f4c365e380b17ccb35617345b31ef7bf3",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\njfs: fix uaf in jfs_evict_inode\n\nWhen the execution of diMount(ipimap) fails, the object ipimap that has been\nreleased may be accessed in diFreeSpecial(). Asynchronous ipimap release occurs\nwhen rcu_core() calls jfs_free_node().\n\nTherefore, when diMount(ipimap) fails, sbi->ipimap should not be initialized as\nipimap."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-03-06T07:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2023-52607",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/21e45a7b08d7cd98d6a53c5fc5111879f2d96611",
            "https://git.kernel.org/stable/c/f6781add1c311c17eff43e14c786004bbacf901e",
            "https://git.kernel.org/stable/c/aa28eecb43cac6e20ef14dfc50b8892c1fbcda5b",
            "https://git.kernel.org/stable/c/ac3ed969a40357b0542d20f096a6d43acdfa6cc7",
            "https://git.kernel.org/stable/c/d482d61025e303a2bef3733a011b6b740215cfa1",
            "https://git.kernel.org/stable/c/145febd85c3bcc5c74d87ef9a598fc7d9122d532",
            "https://git.kernel.org/stable/c/ffd29dc45bc0355393859049f6becddc3ed08f74",
            "https://git.kernel.org/stable/c/f46c8a75263f97bda13c739ba1c90aced0d3b071",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/mm: Fix null-pointer dereference in pgtable_cache_add\n\nkasprintf() returns a pointer to dynamically allocated memory\nwhich can be NULL upon failure. Ensure the allocation was successful\nby checking the pointer validity."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-03-06T07:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2023-52583",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/eb55ba8aa7fb7aad54f40fbf4d8dcdfdba0bebf6",
            "https://git.kernel.org/stable/c/6ab4fd508fad942f1f1ba940492f2735e078e980",
            "https://git.kernel.org/stable/c/e016e358461b89b231626fcf78c5c38e35c44fd3",
            "https://git.kernel.org/stable/c/a9c15d6e8aee074fae66c04d114f20b84274fcca",
            "https://git.kernel.org/stable/c/7f2649c94264d00df6b6ac27161e9f4372a3450e",
            "https://git.kernel.org/stable/c/196b87e5c00ce021e164a5de0f0d04f4116a9160",
            "https://git.kernel.org/stable/c/76cb2aa3421fee4fde706dec41b1344bc0a9ad67",
            "https://git.kernel.org/stable/c/b493ad718b1f0357394d2cdecbf00a44a36fa085",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nceph: fix deadlock or deadcode of misusing dget()\n\nThe lock order is incorrect between denty and its parent, we should\nalways make sure that the parent get the lock first.\n\nBut since this deadcode is never used and the parent dir will always\nbe set from the callers, let's just remove it."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-03-06T07:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2023-52587",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/4c8922ae8eb8dcc1e4b7d1059d97a8334288d825",
            "https://git.kernel.org/stable/c/615e3adc2042b7be4ad122a043fc9135e6342c90",
            "https://git.kernel.org/stable/c/ac2630fd3c90ffec34a0bfc4d413668538b0e8f2",
            "https://git.kernel.org/stable/c/ed790bd0903ed3352ebf7f650d910f49b7319b34",
            "https://git.kernel.org/stable/c/5108a2dc2db5630fb6cd58b8be80a0c134bc310a",
            "https://git.kernel.org/stable/c/342258fb46d66c1b4c7e2c3717ac01e10c03cf18",
            "https://git.kernel.org/stable/c/7c7bd4d561e9dc6f5b7df9e184974915f6701a89",
            "https://git.kernel.org/stable/c/4f973e211b3b1c6d36f7c6a19239d258856749f9",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nIB/ipoib: Fix mcast list locking\n\nReleasing the `priv->lock` while iterating the `priv->multicast_list` in\n`ipoib_mcast_join_task()` opens a window for `ipoib_mcast_dev_flush()` to\nremove the items while in the middle of iteration. If the mcast is removed\nwhile the lock was dropped, the for loop spins forever resulting in a hard\nlockup (as was reported on RHEL 4.18.0-372.75.1.el8_6 kernel):\n\n    Task A (kworker/u72:2 below)       | Task B (kworker/u72:0 below)\n    -----------------------------------+-----------------------------------\n    ipoib_mcast_join_task(work)        | ipoib_ib_dev_flush_light(work)\n      spin_lock_irq(&priv->lock)       | __ipoib_ib_dev_flush(priv, ...)\n      list_for_each_entry(mcast,       | ipoib_mcast_dev_flush(dev = priv->dev)\n          &priv->multicast_list, list) |\n        ipoib_mcast_join(dev, mcast)   |\n          spin_unlock_irq(&priv->lock) |\n                                       |   spin_lock_irqsave(&priv->lock, flags)\n                                       |   list_for_each_entry_safe(mcast, tmcast,\n                                       |                  &priv->multicast_list, list)\n                                       |     list_del(&mcast->list);\n                                       |     list_add_tail(&mcast->list, &remove_list)\n                                       |   spin_unlock_irqrestore(&priv->lock, flags)\n          spin_lock_irq(&priv->lock)   |\n                                       |   ipoib_mcast_remove_list(&remove_list)\n   (Here, `mcast` is no longer on the  |     list_for_each_entry_safe(mcast, tmcast,\n    `priv->multicast_list` and we keep |                            remove_list, list)\n    spinning on the `remove_list` of   |  >>>  wait_for_completion(&mcast->done)\n    the other thread which is blocked  |\n    and the list is still valid on     |\n    it's stack.)\n\nFix this by keeping the lock held and changing to GFP_ATOMIC to prevent\neventual sleeps.\nUnfortunately we could not reproduce the lockup and confirm this fix but\nbased on the code review I think this fix should address such lockups.\n\ncrash> bc 31\nPID: 747      TASK: ff1c6a1a007e8000  CPU: 31   COMMAND: \"kworker/u72:2\"\n--\n    [exception RIP: ipoib_mcast_join_task+0x1b1]\n    RIP: ffffffffc0944ac1  RSP: ff646f199a8c7e00  RFLAGS: 00000002\n    RAX: 0000000000000000  RBX: ff1c6a1a04dc82f8  RCX: 0000000000000000\n                                  work (&priv->mcast_task{,.work})\n    RDX: ff1c6a192d60ac68  RSI: 0000000000000286  RDI: ff1c6a1a04dc8000\n           &mcast->list\n    RBP: ff646f199a8c7e90   R8: ff1c699980019420   R9: ff1c6a1920c9a000\n    R10: ff646f199a8c7e00  R11: ff1c6a191a7d9800  R12: ff1c6a192d60ac00\n                                                         mcast\n    R13: ff1c6a1d82200000  R14: ff1c6a1a04dc8000  R15: ff1c6a1a04dc82d8\n           dev                    priv (&priv->lock)     &priv->multicast_list (aka head)\n    ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018\n--- <NMI exception stack> ---\n #5 [ff646f199a8c7e00] ipoib_mcast_join_task+0x1b1 at ffffffffc0944ac1 [ib_ipoib]\n #6 [ff646f199a8c7e98] process_one_work+0x1a7 at ffffffff9bf10967\n\ncrash> rx ff646f199a8c7e68\nff646f199a8c7e68:  ff1c6a1a04dc82f8 <<< work = &priv->mcast_task.work\n\ncrash> list -hO ipoib_dev_priv.multicast_list ff1c6a1a04dc8000\n(empty)\n\ncrash> ipoib_dev_priv.mcast_task.work.func,mcast_mutex.owner.counter ff1c6a1a04dc8000\n  mcast_task.work.func = 0xffffffffc0944910 <ipoib_mcast_join_task>,\n  mcast_mutex.owner.counter = 0xff1c69998efec000\n\ncrash> b 8\nPID: 8        TASK: ff1c69998efec000  CPU: 33   COMMAND: \"kworker/u72:0\"\n--\n #3 [ff646f1980153d50] wait_for_completion+0x96 at ffffffff9c7d7646\n #4 [ff646f1980153d90] ipoib_mcast_remove_list+0x56 at ffffffffc0944dc6 [ib_ipoib]\n #5 [ff646f1980153de8] ipoib_mcast_dev_flush+0x1a7 at ffffffffc09455a7 [ib_ipoib]\n #6 [ff646f1980153e58] __ipoib_ib_dev_flush+0x1a4 at ffffffffc09431a4 [ib_ipoib]\n #7 [ff\n---truncated---"
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-03-06T07:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2023-52594",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/f44f073c78112ff921a220d01b86d09f2ace59bc",
            "https://git.kernel.org/stable/c/f11f0fd1ad6c11ae7856d4325fe9d05059767225",
            "https://git.kernel.org/stable/c/84770a996ad8d7f121ff2fb5a8d149aad52d64c1",
            "https://git.kernel.org/stable/c/9003fa9a0198ce004b30738766c67eb7373479c9",
            "https://git.kernel.org/stable/c/25c6f49ef59b7a9b80a3f7ab9e95268a1b01a234",
            "https://git.kernel.org/stable/c/e4f4bac7d3b64eb75f70cd3345712de6f68a215d",
            "https://git.kernel.org/stable/c/be609c7002dd4504b15b069cb7582f4c778548d1",
            "https://git.kernel.org/stable/c/2adc886244dff60f948497b59affb6c6ebb3c348",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath9k: Fix potential array-index-out-of-bounds read in ath9k_htc_txstatus()\n\nFix an array-index-out-of-bounds read in ath9k_htc_txstatus(). The bug\noccurs when txs->cnt, data from a URB provided by a USB device, is\nbigger than the size of the array txs->txstatus, which is\nHTC_MAX_TX_STATUS. WARN_ON() already checks it, but there is no bug\nhandling code after the check. Make the function return if that is the\ncase.\n\nFound by a modified version of syzkaller.\n\nUBSAN: array-index-out-of-bounds in htc_drv_txrx.c\nindex 13 is out of range for type '__wmi_event_txstatus [12]'\nCall Trace:\n ath9k_htc_txstatus\n ath9k_wmi_event_tasklet\n tasklet_action_common\n __do_softirq\n irq_exit_rxu\n sysvec_apic_timer_interrupt"
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-03-06T07:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2023-52595",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/e1f113b57ddd18274d7c83618deca25cc880bc48",
            "https://git.kernel.org/stable/c/69e905beca193125820c201ab3db4fb0e245124e",
            "https://git.kernel.org/stable/c/4cc198580a7b93a36f5beb923f40f7ae27a3716c",
            "https://git.kernel.org/stable/c/739b3ccd9486dff04af95f9a890846d088a84957",
            "https://git.kernel.org/stable/c/04cfe4a5da57ab9358cdfadea22bcb37324aaf83",
            "https://git.kernel.org/stable/c/fdb580ed05df8973aa5149cafa598c64bebcd0cb",
            "https://git.kernel.org/stable/c/a11d965a218f0cd95b13fe44d0bcd8a20ce134a8",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: rt2x00: restart beacon queue when hardware reset\n\nWhen a hardware reset is triggered, all registers are reset, so all\nqueues are forced to stop in hardware interface. However, mac80211\nwill not automatically stop the queue. If we don't manually stop the\nbeacon queue, the queue will be deadlocked and unable to start again.\nThis patch fixes the issue where Apple devices cannot connect to the\nAP after calling ieee80211_restart_hw()."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-03-06T07:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2023-52597",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/3a04410b0bc7e056e0843ac598825dd359246d18",
            "https://git.kernel.org/stable/c/5e63c9ae8055109d805aacdaf2a4fe2c3b371ba1",
            "https://git.kernel.org/stable/c/150a3a3871490e8c454ffbac2e60abeafcecff99",
            "https://git.kernel.org/stable/c/732a3bea7aba5b15026ea42d14953c3425cc7dc2",
            "https://git.kernel.org/stable/c/0671f42a9c1084db10d68ac347d08dbf6689ecb3",
            "https://git.kernel.org/stable/c/c87d7d910775a025e230fd6359b60627e392460f",
            "https://git.kernel.org/stable/c/2823db0010c400e4b2b12d02aa5d0d3ecb15d7c7",
            "https://git.kernel.org/stable/c/b988b1bb0053c0dcd26187d29ef07566a565cf55",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: s390: fix setting of fpc register\n\nkvm_arch_vcpu_ioctl_set_fpu() allows to set the floating point control\n(fpc) register of a guest cpu. The new value is tested for validity by\ntemporarily loading it into the fpc register.\n\nThis may lead to corruption of the fpc register of the host process:\nif an interrupt happens while the value is temporarily loaded into the fpc\nregister, and within interrupt context floating point or vector registers\nare used, the current fp/vx registers are saved with save_fpu_regs()\nassuming they belong to user space and will be loaded into fp/vx registers\nwhen returning to user space.\n\ntest_fp_ctl() restores the original user space / host process fpc register\nvalue, however it will be discarded, when returning to user space.\n\nIn result the host process will incorrectly continue to run with the value\nthat was supposed to be used for a guest cpu.\n\nFix this by simply removing the test. There is another test right before\nthe SIE context is entered which will handles invalid values.\n\nThis results in a change of behaviour: invalid values will now be accepted\ninstead of that the ioctl fails with -EINVAL. This seems to be acceptable,\ngiven that this interface is most likely not used anymore, and this is in\naddition the same behaviour implemented with the memory mapped interface\n(replace invalid values with zero) - see sync_regs() in kvm-s390.c."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-03-06T07:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2023-52598",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/6ccf904aac0292e1f6b1a1be6c407c414f7cf713",
            "https://git.kernel.org/stable/c/6d0822f2cc9b153bf2df49a84599195a2e0d21a8",
            "https://git.kernel.org/stable/c/856caf2730ea18cb39e95833719c02a02447dc0a",
            "https://git.kernel.org/stable/c/28a1f492cb527f64593457a0a0f0d809b3f36c25",
            "https://git.kernel.org/stable/c/7a4d6481fbdd661f9e40e95febb95e3dee82bad3",
            "https://git.kernel.org/stable/c/02c6bbfb08bad78dd014e24c7b893723c15ec7a1",
            "https://git.kernel.org/stable/c/bdce67df7f12fb0409fbc604ce7c4254703f56d4",
            "https://git.kernel.org/stable/c/8b13601d19c541158a6e18b278c00ba69ae37829",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ns390/ptrace: handle setting of fpc register correctly\n\nIf the content of the floating point control (fpc) register of a traced\nprocess is modified with the ptrace interface the new value is tested for\nvalidity by temporarily loading it into the fpc register.\n\nThis may lead to corruption of the fpc register of the tracing process:\nif an interrupt happens while the value is temporarily loaded into the\nfpc register, and within interrupt context floating point or vector\nregisters are used, the current fp/vx registers are saved with\nsave_fpu_regs() assuming they belong to user space and will be loaded into\nfp/vx registers when returning to user space.\n\ntest_fp_ctl() restores the original user space fpc register value, however\nit will be discarded, when returning to user space.\n\nIn result the tracer will incorrectly continue to run with the value that\nwas supposed to be used for the traced process.\n\nFix this by saving fpu register contents with save_fpu_regs() before using\ntest_fp_ctl()."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-03-06T07:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2023-52606",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/42084a428a139f1a429f597d44621e3a18f3e414",
            "https://git.kernel.org/stable/c/0580f4403ad33f379eef865c2a6fe94de37febdf",
            "https://git.kernel.org/stable/c/beee482cc4c9a6b1dcffb2e190b4fd8782258678",
            "https://git.kernel.org/stable/c/de4f5ed63b8a199704d8cdcbf810309d7eb4b36b",
            "https://git.kernel.org/stable/c/abd26515d4b767ba48241eea77b28ce0872aef3e",
            "https://git.kernel.org/stable/c/28b8ba8eebf26f66d9f2df4ba550b6b3b136082c",
            "https://git.kernel.org/stable/c/848e1d7fd710900397e1d0e7584680c1c04e3afd",
            "https://git.kernel.org/stable/c/8f9abaa6d7de0a70fc68acaedce290c1f96e2e59",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/lib: Validate size for vector operations\n\nSome of the fp/vmx code in sstep.c assume a certain maximum size for the\ninstructions being emulated. The size of those operations however is\ndetermined separately in analyse_instr().\n\nAdd a check to validate the assumption on the maximum size of the\noperations, so as to prevent any unintended kernel stack corruption."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-02-29T06:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2023-52482",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/f090a8b4d2e3ec6f318d6fdab243a2edc5a8cc37",
            "https://git.kernel.org/stable/c/6ce2f297a7168274547d0b5aea6c7c16268b8a96",
            "https://git.kernel.org/stable/c/cf43b304b6952b549d58feabc342807b334f03d4",
            "https://git.kernel.org/stable/c/a5ef7d68cea1344cf524f04981c2b3f80bedbb0d",
            "https://git.kernel.org/stable/c/e7ea043bc3f19473561c08565047b3f1671bf35d",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/srso: Add SRSO mitigation for Hygon processors\n\nAdd mitigation for the speculative return stack overflow vulnerability\nwhich exists on Hygon processors too."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-02-26T16:27:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "CWE-476",
        "id": "CVE-2024-26600",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/486218c11e8d1c8f515a3bdd70d62203609d4b6b",
            "https://git.kernel.org/stable/c/8398d8d735ee93a04fb9e9f490e8cacd737e3bf5",
            "https://git.kernel.org/stable/c/be3b82e4871ba00e9b5d0ede92d396d579d7b3b3",
            "https://git.kernel.org/stable/c/8cc889b9dea0579726be9520fcc766077890b462",
            "https://git.kernel.org/stable/c/0430bfcd46657d9116a26cd377f112cbc40826a4",
            "https://git.kernel.org/stable/c/14ef61594a5a286ae0d493b8acbf9eac46fd04c4",
            "https://git.kernel.org/stable/c/396e17af6761b3cc9e6e4ca94b4de7f642bfece1",
            "https://git.kernel.org/stable/c/7104ba0f1958adb250319e68a15eff89ec4fd36d",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nphy: ti: phy-omap-usb2: Fix NULL pointer dereference for SRP\n\nIf the external phy working together with phy-omap-usb2 does not implement\nsend_srp(), we may still attempt to call it. This can happen on an idle\nEthernet gadget triggering a wakeup for example:\n\nconfigfs-gadget.g1 gadget.0: ECM Suspend\nconfigfs-gadget.g1 gadget.0: Port suspended. Triggering wakeup\n...\nUnable to handle kernel NULL pointer dereference at virtual address\n00000000 when execute\n...\nPC is at 0x0\nLR is at musb_gadget_wakeup+0x1d4/0x254 [musb_hdrc]\n...\nmusb_gadget_wakeup [musb_hdrc] from usb_gadget_wakeup+0x1c/0x3c [udc_core]\nusb_gadget_wakeup [udc_core] from eth_start_xmit+0x3b0/0x3d4 [u_ether]\neth_start_xmit [u_ether] from dev_hard_start_xmit+0x94/0x24c\ndev_hard_start_xmit from sch_direct_xmit+0x104/0x2e4\nsch_direct_xmit from __dev_queue_xmit+0x334/0xd88\n__dev_queue_xmit from arp_solicit+0xf0/0x268\narp_solicit from neigh_probe+0x54/0x7c\nneigh_probe from __neigh_event_send+0x22c/0x47c\n__neigh_event_send from neigh_resolve_output+0x14c/0x1c0\nneigh_resolve_output from ip_finish_output2+0x1c8/0x628\nip_finish_output2 from ip_send_skb+0x40/0xd8\nip_send_skb from udp_send_skb+0x124/0x340\nudp_send_skb from udp_sendmsg+0x780/0x984\nudp_sendmsg from __sys_sendto+0xd8/0x158\n__sys_sendto from ret_fast_syscall+0x0/0x58\n\nLet's fix the issue by checking for send_srp() and set_vbus() before\ncalling them. For USB peripheral only cases these both could be NULL."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-02-23T10:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "CWE-125",
        "id": "CVE-2024-26593",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/d074d5ff5ae77b18300e5079c6bda6342a4d44b7",
            "https://git.kernel.org/stable/c/7a14b8a477b88607d157c24aeb23e7389ec3319f",
            "https://git.kernel.org/stable/c/1f8d0691c50581ba6043f009ec9e8b9f78f09d5a",
            "https://git.kernel.org/stable/c/491528935c9c48bf341d8b40eabc6c4fc5df6f2c",
            "https://git.kernel.org/stable/c/6be99c51829b24c914cef5bff6164877178e84d9",
            "https://git.kernel.org/stable/c/609c7c1cc976e740d0fed4dbeec688b3ecb5dce2",
            "https://git.kernel.org/stable/c/c1c9d0f6f7f1dbf29db996bd8e166242843a5f21",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ni2c: i801: Fix block process call transactions\n\nAccording to the Intel datasheets, software must reset the block\nbuffer index twice for block process call transactions: once before\nwriting the outgoing data to the buffer, and once again before\nreading the incoming data from the buffer.\n\nThe driver is currently missing the second reset, causing the wrong\nportion of the block buffer to be read."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-02-20T13:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "NVD-CWE-noinfo",
        "id": "CVE-2024-26581",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://git.kernel.org/stable/c/1296c110c5a0b45a8fcf58e7d18bc5da61a565cb",
            "https://git.kernel.org/stable/c/b734f7a47aeb32a5ba298e4ccc16bb0c52b6dbf7",
            "https://git.kernel.org/stable/c/6eb14441f10602fa1cf691da9d685718b68b78a9",
            "https://git.kernel.org/stable/c/60c0c230c6f046da536d3df8b39a20b9a9fd6af0",
            "https://git.kernel.org/stable/c/10e9cb39313627f2eae4cd70c4b742074e998fd8",
            "https://git.kernel.org/stable/c/4cee42fcf54fec46b344681e7cc4f234bb22f85a",
            "https://git.kernel.org/stable/c/2bab493a5624444ec6e648ad0d55a362bcb4c003",
            "https://git.kernel.org/stable/c/c60d252949caf9aba537525195edae6bbabc35eb",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nft_set_rbtree: skip end interval element from gc\n\nrbtree lazy gc on insert might collect an end interval element that has\nbeen just added in this transactions, skip end interval elements that\nare not yet active."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-02-12T03:15:00",
        "access": {},
        "assigner": "cve@mitre.org",
        "cvss": null,
        "cwe": "CWE-754",
        "id": "CVE-2024-25739",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://www.spinics.net/lists/kernel/msg5074816.html",
            "https://groups.google.com/g/syzkaller/c/Xl97YcQA4hg",
            "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=68a24aba7c593eafa8fd00f2f76407b9b32b47a9",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "create_empty_lvol in drivers/mtd/ubi/vtbl.c in the Linux kernel through 6.7.4 can attempt to allocate zero bytes, and crash, because of a missing check for ubi->leb_size."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-02-11T15:15:00",
        "access": {},
        "assigner": "secalert@redhat.com",
        "cvss": null,
        "cwe": "CWE-121",
        "id": "CVE-2024-1151",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://access.redhat.com/security/cve/CVE-2024-1151",
            "https://bugzilla.redhat.com/show_bug.cgi?id=2262241",
            "https://lore.kernel.org/all/20240207132416.1488485-1-aconole@redhat.com/",
            "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GS7S3XLTLOUKBXV67LLFZWB3YVFJZHRK/",
            "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3LZROQAX7Q7LEP4F7WQ3KUZKWCZGFFP2/",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "A vulnerability was reported in the Open vSwitch sub-component in the Linux Kernel. The flaw occurs when a recursive operation of code push recursively calls into the code block. The OVS module does not validate the stack depth, pushing too many frames and causing a stack overflow. As a result, this can lead to a crash or other related issues."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-01-28T12:15:00",
        "access": {},
        "assigner": "secalert@redhat.com",
        "cvss": null,
        "cwe": "CWE-476",
        "id": "CVE-2024-0841",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://access.redhat.com/security/cve/CVE-2024-0841",
            "https://bugzilla.redhat.com/show_bug.cgi?id=2256490",
            "https://access.redhat.com/errata/RHSA-2024:2394",
            "https://access.redhat.com/errata/RHSA-2024:2950",
            "https://access.redhat.com/errata/RHSA-2024:3138",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "A null pointer dereference flaw was found in the hugetlbfs_fill_super function in the Linux kernel hugetlbfs (HugeTLB pages) functionality. This issue may allow a local user to crash the system or potentially escalate their privileges on the system."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-01-23T09:15:00",
        "access": {},
        "assigner": "cve@mitre.org",
        "cvss": null,
        "cwe": "CWE-193",
        "id": "CVE-2024-23849",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://lore.kernel.org/netdev/CALGdzuoVdq-wtQ4Az9iottBqC5cv9ZhcE5q8N7LfYFvkRsOVcw%40mail.gmail.com",
            "https://lore.kernel.org/netdev/1705715319-19199-1-git-send-email-sharath.srinivasan%40oracle.com/",
            "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/7LSPIOMIJYTLZB6QKPQVVAYSUETUWKPF/",
            "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/LBVHM4LGMFIHBN4UBESYRFMYX3WUICV5/",
            "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=13e788deb7348cc88df34bed736c3b3b9927ea52",
            "https://bugzilla.suse.com/show_bug.cgi?id=1219127",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In rds_recv_track_latency in net/rds/af_rds.c in the Linux kernel through 6.7.1, there is an off-by-one error for an RDS_MSG_RX_DGRAM_TRACE_MAX comparison, resulting in out-of-bounds access."
    },
    {
        "Modified": "2024-06-25T23:15:00",
        "Published": "2024-01-09T18:15:00",
        "access": {},
        "assigner": "secalert@redhat.com",
        "cvss": null,
        "cwe": "NVD-CWE-noinfo",
        "id": "CVE-2024-0340",
        "impact": {},
        "last-modified": "2024-06-25T23:15:00",
        "references": [
            "https://access.redhat.com/security/cve/CVE-2024-0340",
            "https://bugzilla.redhat.com/show_bug.cgi?id=2257406",
            "https://lore.kernel.org/lkml/5kn47peabxjrptkqa6dwtyus35ahf4pcj4qm4pumse33kxqpjw@mec4se5relrc/T/",
            "https://access.redhat.com/errata/RHSA-2024:3618",
            "https://access.redhat.com/errata/RHSA-2024:3627",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "A vulnerability was found in vhost_new_msg in drivers/vhost/vhost.c in the Linux kernel, which does not properly initialize memory in messages passed between virtual guests and the host operating system in the vhost/vhost.c:vhost_new_msg() function. This issue can allow local privileged users to read some kernel memory contents when reading from the /dev/vhost-net device file."
    },
    {
        "Modified": "2024-06-25T22:15:00",
        "Published": "2024-04-02T07:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26664",
        "impact": {},
        "last-modified": "2024-06-25T22:15:00",
        "references": [
            "https://git.kernel.org/stable/c/93f0f4e846fcb682c3ec436e3b2e30e5a3a8ee6a",
            "https://git.kernel.org/stable/c/1eb74c00c9c3b13cb65e508c5d5a2f11afb96b8b",
            "https://git.kernel.org/stable/c/f0da068c75c20ffc5ba28243ff577531dc2af1fd",
            "https://git.kernel.org/stable/c/a16afec8e83c56b14a4a73d2e3fb8eec3a8a057e",
            "https://git.kernel.org/stable/c/9bce69419271eb8b2b3ab467387cb59c99d80deb",
            "https://git.kernel.org/stable/c/853a6503c586a71abf27e60a7f8c4fb28092976d",
            "https://git.kernel.org/stable/c/3a7753bda55985dc26fae17795cb10d825453ad1",
            "https://git.kernel.org/stable/c/4e440abc894585a34c2904a32cd54af1742311b3",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nhwmon: (coretemp) Fix out-of-bounds memory access\n\nFix a bug that pdata->cpu_map[] is set before out-of-bounds check.\nThe problem might be triggered on systems with more than 128 cores per\npackage."
    },
    {
        "Modified": "2024-06-25T22:15:00",
        "Published": "2024-04-02T07:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2023-52635",
        "impact": {},
        "last-modified": "2024-06-25T22:15:00",
        "references": [
            "https://git.kernel.org/stable/c/3399cc7013e761fee9d6eec795e9b31ab0cbe475",
            "https://git.kernel.org/stable/c/099f6a9edbe30b142c1d97fe9a4748601d995675",
            "https://git.kernel.org/stable/c/31569995fc65007b73a3fff605ec2b3401b435e9",
            "https://git.kernel.org/stable/c/0aedb319ef3ed39e9e5a7b7726c8264ca627bbd9",
            "https://git.kernel.org/stable/c/ae815e2fdc284ab31651d52460698bd89c0fce22",
            "https://git.kernel.org/stable/c/aed5ed595960c6d301dcd4ed31aeaa7a8054c0c6",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nPM / devfreq: Synchronize devfreq_monitor_[start/stop]\n\nThere is a chance if a frequent switch of the governor\ndone in a loop result in timer list corruption where\ntimer cancel being done from two place one from\ncancel_delayed_work_sync() and followed by expire_timers()\ncan be seen from the traces[1].\n\nwhile true\ndo\n        echo \"simple_ondemand\" > /sys/class/devfreq/1d84000.ufshc/governor\n        echo \"performance\" > /sys/class/devfreq/1d84000.ufshc/governor\ndone\n\nIt looks to be issue with devfreq driver where\ndevice_monitor_[start/stop] need to synchronized so that\ndelayed work should get corrupted while it is either\nbeing queued or running or being cancelled.\n\nLet's use polling flag and devfreq lock to synchronize the\nqueueing the timer instance twice and work data being\ncorrupted.\n\n[1]\n...\n..\n<idle>-0    [003]   9436.209662:  timer_cancel   timer=0xffffff80444f0428\n<idle>-0    [003]   9436.209664:  timer_expire_entry   timer=0xffffff80444f0428  now=0x10022da1c  function=__typeid__ZTSFvP10timer_listE_global_addr  baseclk=0x10022da1c\n<idle>-0    [003]   9436.209718:  timer_expire_exit   timer=0xffffff80444f0428\nkworker/u16:6-14217    [003]   9436.209863:  timer_start   timer=0xffffff80444f0428  function=__typeid__ZTSFvP10timer_listE_global_addr  expires=0x10022da2b  now=0x10022da1c  flags=182452227\nvendor.xxxyyy.ha-1593    [004]   9436.209888:  timer_cancel   timer=0xffffff80444f0428\nvendor.xxxyyy.ha-1593    [004]   9436.216390:  timer_init   timer=0xffffff80444f0428\nvendor.xxxyyy.ha-1593    [004]   9436.216392:  timer_start   timer=0xffffff80444f0428  function=__typeid__ZTSFvP10timer_listE_global_addr  expires=0x10022da2c  now=0x10022da1d  flags=186646532\nvendor.xxxyyy.ha-1593    [005]   9436.220992:  timer_cancel   timer=0xffffff80444f0428\nxxxyyyTraceManag-7795    [004]   9436.261641:  timer_cancel   timer=0xffffff80444f0428\n\n[2]\n\n 9436.261653][    C4] Unable to handle kernel paging request at virtual address dead00000000012a\n[ 9436.261664][    C4] Mem abort info:\n[ 9436.261666][    C4]   ESR = 0x96000044\n[ 9436.261669][    C4]   EC = 0x25: DABT (current EL), IL = 32 bits\n[ 9436.261671][    C4]   SET = 0, FnV = 0\n[ 9436.261673][    C4]   EA = 0, S1PTW = 0\n[ 9436.261675][    C4] Data abort info:\n[ 9436.261677][    C4]   ISV = 0, ISS = 0x00000044\n[ 9436.261680][    C4]   CM = 0, WnR = 1\n[ 9436.261682][    C4] [dead00000000012a] address between user and kernel address ranges\n[ 9436.261685][    C4] Internal error: Oops: 96000044 [#1] PREEMPT SMP\n[ 9436.261701][    C4] Skip md ftrace buffer dump for: 0x3a982d0\n...\n\n[ 9436.262138][    C4] CPU: 4 PID: 7795 Comm: TraceManag Tainted: G S      W  O      5.10.149-android12-9-o-g17f915d29d0c #1\n[ 9436.262141][    C4] Hardware name: Qualcomm Technologies, Inc.  (DT)\n[ 9436.262144][    C4] pstate: 22400085 (nzCv daIf +PAN -UAO +TCO BTYPE=--)\n[ 9436.262161][    C4] pc : expire_timers+0x9c/0x438\n[ 9436.262164][    C4] lr : expire_timers+0x2a4/0x438\n[ 9436.262168][    C4] sp : ffffffc010023dd0\n[ 9436.262171][    C4] x29: ffffffc010023df0 x28: ffffffd0636fdc18\n[ 9436.262178][    C4] x27: ffffffd063569dd0 x26: ffffffd063536008\n[ 9436.262182][    C4] x25: 0000000000000001 x24: ffffff88f7c69280\n[ 9436.262185][    C4] x23: 00000000000000e0 x22: dead000000000122\n[ 9436.262188][    C4] x21: 000000010022da29 x20: ffffff8af72b4e80\n[ 9436.262191][    C4] x19: ffffffc010023e50 x18: ffffffc010025038\n[ 9436.262195][    C4] x17: 0000000000000240 x16: 0000000000000201\n[ 9436.262199][    C4] x15: ffffffffffffffff x14: ffffff889f3c3100\n[ 9436.262203][    C4] x13: ffffff889f3c3100 x12: 00000000049f56b8\n[ 9436.262207][    C4] x11: 00000000049f56b8 x10: 00000000ffffffff\n[ 9436.262212][    C4] x9 : ffffffc010023e50 x8 : dead000000000122\n[ 9436.262216][    C4] x7 : ffffffffffffffff x6 : ffffffc0100239d8\n[ 9436.262220][    C4] x5 : 0000000000000000 x4 : 0000000000000101\n[ 9436.262223][    C4] x3 : 0000000000000080 x2 : ffffff8\n---truncated---"
    },
    {
        "Modified": "2024-06-25T22:15:00",
        "Published": "2024-04-03T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26688",
        "impact": {},
        "last-modified": "2024-06-25T22:15:00",
        "references": [
            "https://git.kernel.org/stable/c/1dde8ef4b7a749ae1bc73617c91775631d167557",
            "https://git.kernel.org/stable/c/80d852299987a8037be145a94f41874228f1a773",
            "https://git.kernel.org/stable/c/22850c9950a4e43a67299755d11498f3292d02ff",
            "https://git.kernel.org/stable/c/2e2c07104b4904aed1389a59b25799b95a85b5b9",
            "https://git.kernel.org/stable/c/13c5a9fb07105557a1fa9efdb4f23d7ef30b7274",
            "https://git.kernel.org/stable/c/ec78418801ef7b0c22cd6a30145ec480dd48db39",
            "https://git.kernel.org/stable/c/79d72c68c58784a3e1cd2378669d51bfd0cb7498",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs,hugetlb: fix NULL pointer dereference in hugetlbs_fill_super\n\nWhen configuring a hugetlb filesystem via the fsconfig() syscall, there is\na possible NULL dereference in hugetlbfs_fill_super() caused by assigning\nNULL to ctx->hstate in hugetlbfs_parse_param() when the requested pagesize\nis non valid.\n\nE.g: Taking the following steps:\n\n     fd = fsopen(\"hugetlbfs\", FSOPEN_CLOEXEC);\n     fsconfig(fd, FSCONFIG_SET_STRING, \"pagesize\", \"1024\", 0);\n     fsconfig(fd, FSCONFIG_CMD_CREATE, NULL, NULL, 0);\n\nGiven that the requested \"pagesize\" is invalid, ctxt->hstate will be replaced\nwith NULL, losing its previous value, and we will print an error:\n\n ...\n ...\n case Opt_pagesize:\n ps = memparse(param->string, &rest);\n ctx->hstate = h;\n if (!ctx->hstate) {\n         pr_err(\"Unsupported page size %lu MB\\n\", ps / SZ_1M);\n         return -EINVAL;\n }\n return 0;\n ...\n ...\n\nThis is a problem because later on, we will dereference ctxt->hstate in\nhugetlbfs_fill_super()\n\n ...\n ...\n sb->s_blocksize = huge_page_size(ctx->hstate);\n ...\n ...\n\nCausing below Oops.\n\nFix this by replacing cxt->hstate value only when then pagesize is known\nto be valid.\n\n kernel: hugetlbfs: Unsupported page size 0 MB\n kernel: BUG: kernel NULL pointer dereference, address: 0000000000000028\n kernel: #PF: supervisor read access in kernel mode\n kernel: #PF: error_code(0x0000) - not-present page\n kernel: PGD 800000010f66c067 P4D 800000010f66c067 PUD 1b22f8067 PMD 0\n kernel: Oops: 0000 [#1] PREEMPT SMP PTI\n kernel: CPU: 4 PID: 5659 Comm: syscall Tainted: G            E      6.8.0-rc2-default+ #22 5a47c3fef76212addcc6eb71344aabc35190ae8f\n kernel: Hardware name: Intel Corp. GROVEPORT/GROVEPORT, BIOS GVPRCRB1.86B.0016.D04.1705030402 05/03/2017\n kernel: RIP: 0010:hugetlbfs_fill_super+0xb4/0x1a0\n kernel: Code: 48 8b 3b e8 3e c6 ed ff 48 85 c0 48 89 45 20 0f 84 d6 00 00 00 48 b8 ff ff ff ff ff ff ff 7f 4c 89 e7 49 89 44 24 20 48 8b 03 <8b> 48 28 b8 00 10 00 00 48 d3 e0 49 89 44 24 18 48 8b 03 8b 40 28\n kernel: RSP: 0018:ffffbe9960fcbd48 EFLAGS: 00010246\n kernel: RAX: 0000000000000000 RBX: ffff9af5272ae780 RCX: 0000000000372004\n kernel: RDX: ffffffffffffffff RSI: ffffffffffffffff RDI: ffff9af555e9b000\n kernel: RBP: ffff9af52ee66b00 R08: 0000000000000040 R09: 0000000000370004\n kernel: R10: ffffbe9960fcbd48 R11: 0000000000000040 R12: ffff9af555e9b000\n kernel: R13: ffffffffa66b86c0 R14: ffff9af507d2f400 R15: ffff9af507d2f400\n kernel: FS:  00007ffbc0ba4740(0000) GS:ffff9b0bd7000000(0000) knlGS:0000000000000000\n kernel: CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n kernel: CR2: 0000000000000028 CR3: 00000001b1ee0000 CR4: 00000000001506f0\n kernel: Call Trace:\n kernel:  <TASK>\n kernel:  ? __die_body+0x1a/0x60\n kernel:  ? page_fault_oops+0x16f/0x4a0\n kernel:  ? search_bpf_extables+0x65/0x70\n kernel:  ? fixup_exception+0x22/0x310\n kernel:  ? exc_page_fault+0x69/0x150\n kernel:  ? asm_exc_page_fault+0x22/0x30\n kernel:  ? __pfx_hugetlbfs_fill_super+0x10/0x10\n kernel:  ? hugetlbfs_fill_super+0xb4/0x1a0\n kernel:  ? hugetlbfs_fill_super+0x28/0x1a0\n kernel:  ? __pfx_hugetlbfs_fill_super+0x10/0x10\n kernel:  vfs_get_super+0x40/0xa0\n kernel:  ? __pfx_bpf_lsm_capable+0x10/0x10\n kernel:  vfs_get_tree+0x25/0xd0\n kernel:  vfs_cmd_create+0x64/0xe0\n kernel:  __x64_sys_fsconfig+0x395/0x410\n kernel:  do_syscall_64+0x80/0x160\n kernel:  ? syscall_exit_to_user_mode+0x82/0x240\n kernel:  ? do_syscall_64+0x8d/0x160\n kernel:  ? syscall_exit_to_user_mode+0x82/0x240\n kernel:  ? do_syscall_64+0x8d/0x160\n kernel:  ? exc_page_fault+0x69/0x150\n kernel:  entry_SYSCALL_64_after_hwframe+0x6e/0x76\n kernel: RIP: 0033:0x7ffbc0cb87c9\n kernel: Code: 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 66 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 97 96 0d 00 f7 d8 64 89 01 48\n kernel: RSP: 002b:00007ffc29d2f388 EFLAGS: 00000206 ORIG_RAX: 00000000000001af\n kernel: RAX: fffffffffff\n---truncated---"
    },
    {
        "Modified": "2024-06-25T22:15:00",
        "Published": "2024-04-03T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26697",
        "impact": {},
        "last-modified": "2024-06-25T22:15:00",
        "references": [
            "https://git.kernel.org/stable/c/5278c3eb6bf5896417572b52adb6be9d26e92f65",
            "https://git.kernel.org/stable/c/a6efe6dbaaf504f5b3f8a5c3f711fe54e7dda0ba",
            "https://git.kernel.org/stable/c/364a66be2abdcd4fd426ffa44d9b8f40aafb3caa",
            "https://git.kernel.org/stable/c/120f7fa2008e3bd8b7680b4ab5df942decf60fd5",
            "https://git.kernel.org/stable/c/9c9c68d64fd3284f7097ed6ae057c8441f39fcd3",
            "https://git.kernel.org/stable/c/2e1480538ef60bfee5473dfe02b1ecbaf1a4aa0d",
            "https://git.kernel.org/stable/c/2000016bab499074e6248ea85aeea7dd762355d9",
            "https://git.kernel.org/stable/c/67b8bcbaed4777871bb0dcc888fb02a614a98ab1",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnilfs2: fix data corruption in dsync block recovery for small block sizes\n\nThe helper function nilfs_recovery_copy_block() of\nnilfs_recovery_dsync_blocks(), which recovers data from logs created by\ndata sync writes during a mount after an unclean shutdown, incorrectly\ncalculates the on-page offset when copying repair data to the file's page\ncache.  In environments where the block size is smaller than the page\nsize, this flaw can cause data corruption and leak uninitialized memory\nbytes during the recovery process.\n\nFix these issues by correcting this byte offset calculation on the page."
    },
    {
        "Modified": "2024-06-25T22:15:00",
        "Published": "2024-04-03T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2023-52637",
        "impact": {},
        "last-modified": "2024-06-25T22:15:00",
        "references": [
            "https://git.kernel.org/stable/c/08de58abedf6e69396e1207e4f99ef8904b2b532",
            "https://git.kernel.org/stable/c/978e50ef8c38dc71bd14d1b0143d554ff5d188ba",
            "https://git.kernel.org/stable/c/41ccb5bcbf03f02d820bc6ea8390811859f558f8",
            "https://git.kernel.org/stable/c/4dd684d4bb3cd5454e0bf6e2a1bdfbd5c9c872ed",
            "https://git.kernel.org/stable/c/f84e7534457dcd7835be743517c35378bb4e7c50",
            "https://git.kernel.org/stable/c/fc74b9cb789cae061bbca7b203a3842e059f6b5d",
            "https://git.kernel.org/stable/c/efe7cf828039aedb297c1f9920b638fffee6aabc",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ncan: j1939: Fix UAF in j1939_sk_match_filter during setsockopt(SO_J1939_FILTER)\n\nLock jsk->sk to prevent UAF when setsockopt(..., SO_J1939_FILTER, ...)\nmodifies jsk->filters while receiving packets.\n\nFollowing trace was seen on affected system:\n ==================================================================\n BUG: KASAN: slab-use-after-free in j1939_sk_recv_match_one+0x1af/0x2d0 [can_j1939]\n Read of size 4 at addr ffff888012144014 by task j1939/350\n\n CPU: 0 PID: 350 Comm: j1939 Tainted: G        W  OE      6.5.0-rc5 #1\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014\n Call Trace:\n  print_report+0xd3/0x620\n  ? kasan_complete_mode_report_info+0x7d/0x200\n  ? j1939_sk_recv_match_one+0x1af/0x2d0 [can_j1939]\n  kasan_report+0xc2/0x100\n  ? j1939_sk_recv_match_one+0x1af/0x2d0 [can_j1939]\n  __asan_load4+0x84/0xb0\n  j1939_sk_recv_match_one+0x1af/0x2d0 [can_j1939]\n  j1939_sk_recv+0x20b/0x320 [can_j1939]\n  ? __kasan_check_write+0x18/0x20\n  ? __pfx_j1939_sk_recv+0x10/0x10 [can_j1939]\n  ? j1939_simple_recv+0x69/0x280 [can_j1939]\n  ? j1939_ac_recv+0x5e/0x310 [can_j1939]\n  j1939_can_recv+0x43f/0x580 [can_j1939]\n  ? __pfx_j1939_can_recv+0x10/0x10 [can_j1939]\n  ? raw_rcv+0x42/0x3c0 [can_raw]\n  ? __pfx_j1939_can_recv+0x10/0x10 [can_j1939]\n  can_rcv_filter+0x11f/0x350 [can]\n  can_receive+0x12f/0x190 [can]\n  ? __pfx_can_rcv+0x10/0x10 [can]\n  can_rcv+0xdd/0x130 [can]\n  ? __pfx_can_rcv+0x10/0x10 [can]\n  __netif_receive_skb_one_core+0x13d/0x150\n  ? __pfx___netif_receive_skb_one_core+0x10/0x10\n  ? __kasan_check_write+0x18/0x20\n  ? _raw_spin_lock_irq+0x8c/0xe0\n  __netif_receive_skb+0x23/0xb0\n  process_backlog+0x107/0x260\n  __napi_poll+0x69/0x310\n  net_rx_action+0x2a1/0x580\n  ? __pfx_net_rx_action+0x10/0x10\n  ? __pfx__raw_spin_lock+0x10/0x10\n  ? handle_irq_event+0x7d/0xa0\n  __do_softirq+0xf3/0x3f8\n  do_softirq+0x53/0x80\n  </IRQ>\n  <TASK>\n  __local_bh_enable_ip+0x6e/0x70\n  netif_rx+0x16b/0x180\n  can_send+0x32b/0x520 [can]\n  ? __pfx_can_send+0x10/0x10 [can]\n  ? __check_object_size+0x299/0x410\n  raw_sendmsg+0x572/0x6d0 [can_raw]\n  ? __pfx_raw_sendmsg+0x10/0x10 [can_raw]\n  ? apparmor_socket_sendmsg+0x2f/0x40\n  ? __pfx_raw_sendmsg+0x10/0x10 [can_raw]\n  sock_sendmsg+0xef/0x100\n  sock_write_iter+0x162/0x220\n  ? __pfx_sock_write_iter+0x10/0x10\n  ? __rtnl_unlock+0x47/0x80\n  ? security_file_permission+0x54/0x320\n  vfs_write+0x6ba/0x750\n  ? __pfx_vfs_write+0x10/0x10\n  ? __fget_light+0x1ca/0x1f0\n  ? __rcu_read_unlock+0x5b/0x280\n  ksys_write+0x143/0x170\n  ? __pfx_ksys_write+0x10/0x10\n  ? __kasan_check_read+0x15/0x20\n  ? fpregs_assert_state_consistent+0x62/0x70\n  __x64_sys_write+0x47/0x60\n  do_syscall_64+0x60/0x90\n  ? do_syscall_64+0x6d/0x90\n  ? irqentry_exit+0x3f/0x50\n  ? exc_page_fault+0x79/0xf0\n  entry_SYSCALL_64_after_hwframe+0x6e/0xd8\n\n Allocated by task 348:\n  kasan_save_stack+0x2a/0x50\n  kasan_set_track+0x29/0x40\n  kasan_save_alloc_info+0x1f/0x30\n  __kasan_kmalloc+0xb5/0xc0\n  __kmalloc_node_track_caller+0x67/0x160\n  j1939_sk_setsockopt+0x284/0x450 [can_j1939]\n  __sys_setsockopt+0x15c/0x2f0\n  __x64_sys_setsockopt+0x6b/0x80\n  do_syscall_64+0x60/0x90\n  entry_SYSCALL_64_after_hwframe+0x6e/0xd8\n\n Freed by task 349:\n  kasan_save_stack+0x2a/0x50\n  kasan_set_track+0x29/0x40\n  kasan_save_free_info+0x2f/0x50\n  __kasan_slab_free+0x12e/0x1c0\n  __kmem_cache_free+0x1b9/0x380\n  kfree+0x7a/0x120\n  j1939_sk_setsockopt+0x3b2/0x450 [can_j1939]\n  __sys_setsockopt+0x15c/0x2f0\n  __x64_sys_setsockopt+0x6b/0x80\n  do_syscall_64+0x60/0x90\n  entry_SYSCALL_64_after_hwframe+0x6e/0xd8"
    },
    {
        "Modified": "2024-06-25T22:15:00",
        "Published": "2024-04-03T17:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26751",
        "impact": {},
        "last-modified": "2024-06-25T22:15:00",
        "references": [
            "https://git.kernel.org/stable/c/9e200a06ae2abb321939693008290af32b33dd6e",
            "https://git.kernel.org/stable/c/999a8bb70da2946336327b4480824d1691cae1fa",
            "https://git.kernel.org/stable/c/70d92abbe29692a3de8697ae082c60f2d21ab482",
            "https://git.kernel.org/stable/c/eec6cbbfa1e8d685cc245cfd5626d0715a127a48",
            "https://git.kernel.org/stable/c/786f089086b505372fb3f4f008d57e7845fff0d8",
            "https://git.kernel.org/stable/c/97ba7c1f9c0a2401e644760d857b2386aa895997",
            "https://git.kernel.org/stable/c/6abe0895b63c20de06685c8544b908c7e413efa8",
            "https://git.kernel.org/stable/c/fdf87a0dc26d0550c60edc911cda42f9afec3557",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nARM: ep93xx: Add terminator to gpiod_lookup_table\n\nWithout the terminator, if a con_id is passed to gpio_find() that\ndoes not exist in the lookup table the function will not stop looping\ncorrectly, and eventually cause an oops."
    },
    {
        "Modified": "2024-06-25T22:15:00",
        "Published": "2024-04-03T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26698",
        "impact": {},
        "last-modified": "2024-06-25T22:15:00",
        "references": [
            "https://git.kernel.org/stable/c/9ec807e7b6f5fcf9499f3baa69f254bb239a847f",
            "https://git.kernel.org/stable/c/7656372ae190e54e8c8cf1039725a5ea59fdf84a",
            "https://git.kernel.org/stable/c/48a8ccccffbae10c91d31fc872db5c31aba07518",
            "https://git.kernel.org/stable/c/22a77c0f5b8233237731df3288d067af51a2fd7b",
            "https://git.kernel.org/stable/c/0e8875de9dad12805ff66e92cd5edea6a421f1cd",
            "https://git.kernel.org/stable/c/e0526ec5360a48ad3ab2e26e802b0532302a7e11",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nhv_netvsc: Fix race condition between netvsc_probe and netvsc_remove\n\nIn commit ac5047671758 (\"hv_netvsc: Disable NAPI before closing the\nVMBus channel\"), napi_disable was getting called for all channels,\nincluding all subchannels without confirming if they are enabled or not.\n\nThis caused hv_netvsc getting hung at napi_disable, when netvsc_probe()\nhas finished running but nvdev->subchan_work has not started yet.\nnetvsc_subchan_work() -> rndis_set_subchannel() has not created the\nsub-channels and because of that netvsc_sc_open() is not running.\nnetvsc_remove() calls cancel_work_sync(&nvdev->subchan_work), for which\nnetvsc_subchan_work did not run.\n\nnetif_napi_add() sets the bit NAPI_STATE_SCHED because it ensures NAPI\ncannot be scheduled. Then netvsc_sc_open() -> napi_enable will clear the\nNAPIF_STATE_SCHED bit, so it can be scheduled. napi_disable() does the\nopposite.\n\nNow during netvsc_device_remove(), when napi_disable is called for those\nsubchannels, napi_disable gets stuck on infinite msleep.\n\nThis fix addresses this problem by ensuring that napi_disable() is not\ngetting called for non-enabled NAPI struct.\nBut netif_napi_del() is still necessary for these non-enabled NAPI struct\nfor cleanup purpose.\n\nCall trace:\n[  654.559417] task:modprobe        state:D stack:    0 pid: 2321 ppid:  1091 flags:0x00004002\n[  654.568030] Call Trace:\n[  654.571221]  <TASK>\n[  654.573790]  __schedule+0x2d6/0x960\n[  654.577733]  schedule+0x69/0xf0\n[  654.581214]  schedule_timeout+0x87/0x140\n[  654.585463]  ? __bpf_trace_tick_stop+0x20/0x20\n[  654.590291]  msleep+0x2d/0x40\n[  654.593625]  napi_disable+0x2b/0x80\n[  654.597437]  netvsc_device_remove+0x8a/0x1f0 [hv_netvsc]\n[  654.603935]  rndis_filter_device_remove+0x194/0x1c0 [hv_netvsc]\n[  654.611101]  ? do_wait_intr+0xb0/0xb0\n[  654.615753]  netvsc_remove+0x7c/0x120 [hv_netvsc]\n[  654.621675]  vmbus_remove+0x27/0x40 [hv_vmbus]"
    },
    {
        "Modified": "2024-06-25T22:15:00",
        "Published": "2024-04-03T17:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26754",
        "impact": {},
        "last-modified": "2024-06-25T22:15:00",
        "references": [
            "https://git.kernel.org/stable/c/f0ecdfa679189d26aedfe24212d4e69e42c2c861",
            "https://git.kernel.org/stable/c/f8cbd1791900b5d96466eede8e9439a5b9ca4de7",
            "https://git.kernel.org/stable/c/2e534fd15e5c2ca15821c897352cf0e8a3e30dca",
            "https://git.kernel.org/stable/c/a576308800be28f2eaa099e7caad093b97d66e77",
            "https://git.kernel.org/stable/c/3963f16cc7643b461271989b712329520374ad2a",
            "https://git.kernel.org/stable/c/ba6b8b02a3314e62571a540efa96560888c5f03e",
            "https://git.kernel.org/stable/c/5013bd54d283eda5262c9ae3bcc966d01daf8576",
            "https://git.kernel.org/stable/c/136cfaca22567a03bbb3bf53a43d8cb5748b80ec",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ngtp: fix use-after-free and null-ptr-deref in gtp_genl_dump_pdp()\n\nThe gtp_net_ops pernet operations structure for the subsystem must be\nregistered before registering the generic netlink family.\n\nSyzkaller hit 'general protection fault in gtp_genl_dump_pdp' bug:\n\ngeneral protection fault, probably for non-canonical address\n0xdffffc0000000002: 0000 [#1] PREEMPT SMP KASAN NOPTI\nKASAN: null-ptr-deref in range [0x0000000000000010-0x0000000000000017]\nCPU: 1 PID: 5826 Comm: gtp Not tainted 6.8.0-rc3-std-def-alt1 #1\nHardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.16.0-alt1 04/01/2014\nRIP: 0010:gtp_genl_dump_pdp+0x1be/0x800 [gtp]\nCode: c6 89 c6 e8 64 e9 86 df 58 45 85 f6 0f 85 4e 04 00 00 e8 c5 ee 86\n      df 48 8b 54 24 18 48 b8 00 00 00 00 00 fc ff df 48 c1 ea 03 <80>\n      3c 02 00 0f 85 de 05 00 00 48 8b 44 24 18 4c 8b 30 4c 39 f0 74\nRSP: 0018:ffff888014107220 EFLAGS: 00010202\nRAX: dffffc0000000000 RBX: 0000000000000000 RCX: 0000000000000000\nRDX: 0000000000000002 RSI: 0000000000000000 RDI: 0000000000000000\nRBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000\nR13: ffff88800fcda588 R14: 0000000000000001 R15: 0000000000000000\nFS:  00007f1be4eb05c0(0000) GS:ffff88806ce80000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f1be4e766cf CR3: 000000000c33e000 CR4: 0000000000750ef0\nPKRU: 55555554\nCall Trace:\n <TASK>\n ? show_regs+0x90/0xa0\n ? die_addr+0x50/0xd0\n ? exc_general_protection+0x148/0x220\n ? asm_exc_general_protection+0x22/0x30\n ? gtp_genl_dump_pdp+0x1be/0x800 [gtp]\n ? __alloc_skb+0x1dd/0x350\n ? __pfx___alloc_skb+0x10/0x10\n genl_dumpit+0x11d/0x230\n netlink_dump+0x5b9/0xce0\n ? lockdep_hardirqs_on_prepare+0x253/0x430\n ? __pfx_netlink_dump+0x10/0x10\n ? kasan_save_track+0x10/0x40\n ? __kasan_kmalloc+0x9b/0xa0\n ? genl_start+0x675/0x970\n __netlink_dump_start+0x6fc/0x9f0\n genl_family_rcv_msg_dumpit+0x1bb/0x2d0\n ? __pfx_genl_family_rcv_msg_dumpit+0x10/0x10\n ? genl_op_from_small+0x2a/0x440\n ? cap_capable+0x1d0/0x240\n ? __pfx_genl_start+0x10/0x10\n ? __pfx_genl_dumpit+0x10/0x10\n ? __pfx_genl_done+0x10/0x10\n ? security_capable+0x9d/0xe0"
    },
    {
        "Modified": "2024-06-25T22:15:00",
        "Published": "2024-04-03T17:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26764",
        "impact": {},
        "last-modified": "2024-06-25T22:15:00",
        "references": [
            "https://git.kernel.org/stable/c/337b543e274fe7a8f47df3c8293cc6686ffa620f",
            "https://git.kernel.org/stable/c/b4eea7a05ee0ab5ab0514421e6ba8c5d249cf942",
            "https://git.kernel.org/stable/c/ea1cd64d59f22d6d13f367d62ec6e27b9344695f",
            "https://git.kernel.org/stable/c/d7b6fa97ec894edd02f64b83e5e72e1aa352f353",
            "https://git.kernel.org/stable/c/18f614369def2a11a52f569fe0f910b199d13487",
            "https://git.kernel.org/stable/c/e7e23fc5d5fe422827c9a43ecb579448f73876c7",
            "https://git.kernel.org/stable/c/1dc7d74fe456944a9b1c57bd776280249f441ac6",
            "https://git.kernel.org/stable/c/b820de741ae48ccf50dd95e297889c286ff4f760",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nfs/aio: Restrict kiocb_set_cancel_fn() to I/O submitted via libaio\n\nIf kiocb_set_cancel_fn() is called for I/O submitted via io_uring, the\nfollowing kernel warning appears:\n\nWARNING: CPU: 3 PID: 368 at fs/aio.c:598 kiocb_set_cancel_fn+0x9c/0xa8\nCall trace:\n kiocb_set_cancel_fn+0x9c/0xa8\n ffs_epfile_read_iter+0x144/0x1d0\n io_read+0x19c/0x498\n io_issue_sqe+0x118/0x27c\n io_submit_sqes+0x25c/0x5fc\n __arm64_sys_io_uring_enter+0x104/0xab0\n invoke_syscall+0x58/0x11c\n el0_svc_common+0xb4/0xf4\n do_el0_svc+0x2c/0xb0\n el0_svc+0x2c/0xa4\n el0t_64_sync_handler+0x68/0xb4\n el0t_64_sync+0x1a4/0x1a8\n\nFix this by setting the IOCB_AIO_RW flag for read and write I/O that is\nsubmitted by libaio."
    },
    {
        "Modified": "2024-06-25T22:15:00",
        "Published": "2024-04-02T07:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-26659",
        "impact": {},
        "last-modified": "2024-06-25T22:15:00",
        "references": [
            "https://git.kernel.org/stable/c/696e4112e5c1ee61996198f0ebb6ca3fab55166e",
            "https://git.kernel.org/stable/c/2aa7bcfdbb46241c701811bbc0d64d7884e3346c",
            "https://git.kernel.org/stable/c/2e3ec80ea7ba58bbb210e83b5a0afefee7c171d3",
            "https://git.kernel.org/stable/c/f5e7ffa9269a448a720e21f1ed1384d118298c97",
            "https://git.kernel.org/stable/c/418456c0ce56209610523f21734c5612ee634134",
            "https://git.kernel.org/stable/c/7c4650ded49e5b88929ecbbb631efb8b0838e811",
            "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nxhci: handle isoc Babble and Buffer Overrun events properly\n\nxHCI 4.9 explicitly forbids assuming that the xHC has released its\nownership of a multi-TRB TD when it reports an error on one of the\nearly TRBs. Yet the driver makes such assumption and releases the TD,\nallowing the remaining TRBs to be freed or overwritten by new TDs.\n\nThe xHC should also report completion of the final TRB due to its IOC\nflag being set by us, regardless of prior errors. This event cannot\nbe recognized if the TD has already been freed earlier, resulting in\n\"Transfer event TRB DMA ptr not part of current TD\" error message.\n\nFix this by reusing the logic for processing isoc Transaction Errors.\nThis also handles hosts which fail to report the final completion.\n\nFix transfer length reporting on Babble errors. They may be caused by\ndevice malfunction, no guarantee that the buffer has been filled."
    }
]