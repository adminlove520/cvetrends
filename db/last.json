[
    {
        "Modified": "2024-10-21T19:50:00",
        "Published": "2024-02-13T09:15:00",
        "access": {},
        "assigner": "productcert@siemens.com",
        "cvss": null,
        "cwe": "NVD-CWE-noinfo",
        "id": "CVE-2024-22042",
        "impact": {},
        "last-modified": "2024-10-21T19:50:00",
        "references": [
            "https://cert-portal.siemens.com/productcert/html/ssa-543502.html"
        ],
        "summary": "A vulnerability has been identified in Unicam FX (All versions). The windows installer agent used in affected product contains incorrect use of privileged APIs that trigger the Windows Console Host (conhost.exe) as a child process with SYSTEM privileges. This could be exploited by an attacker to perform a local privilege escalation attack."
    },
    {
        "Modified": "2024-10-21T19:41:00",
        "Published": "2024-10-15T10:15:00",
        "access": {},
        "assigner": "security-research@sec-consult.com",
        "cvss": null,
        "cwe": "CWE-331",
        "id": "CVE-2024-47945",
        "impact": {},
        "last-modified": "2024-10-21T19:41:00",
        "references": [
            "https://r.sec-consult.com/rittaliot",
            "https://www.rittal.com/de-de/products/deep/3124300"
        ],
        "summary": "The devices are vulnerable to session hijacking due to insufficient \nentropy in its session ID generation algorithm. The session IDs are \npredictable, with only 32,768 possible values per user, which allows \nattackers to pre-generate valid session IDs, leading to unauthorized \naccess to user sessions. This is not only due to the use of an \n(insecure) rand() function call but also because of missing \ninitialization via srand(). As a result only the PIDs are effectively \nused as seed."
    },
    {
        "Modified": "2024-10-21T19:35:00",
        "Published": "2024-10-21T19:15:00",
        "access": {},
        "assigner": "cve@mitre.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-48709",
        "impact": {},
        "last-modified": "2024-10-21T19:35:00",
        "references": [
            "https://github.com/anoncoder01/PHP_CodeAstro_Stored_XSS/blob/master/vulnerabilities/XSS_2.md"
        ],
        "summary": "CodeAstro Membership Management System v1.0 is vulnerable to Cross Site Scripting (XSS) via the membershipType parameter in edit_type.php"
    },
    {
        "Modified": "2024-10-21T19:35:00",
        "Published": "2024-10-21T19:15:00",
        "access": {},
        "assigner": "cve@mitre.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-46236",
        "impact": {},
        "last-modified": "2024-10-21T19:35:00",
        "references": [
            "https://github.com/anoncoder01/PHP_CodeAstro_Stored_XSS/blob/master/vulnerabilities/XSS_1.md"
        ],
        "summary": "CodeAstro Membership Management System v1.0 is vulnerable to Cross Site Scripting (XSS) via the address parameter in add_members.php and edit_member.php."
    },
    {
        "Modified": "2024-10-21T19:35:00",
        "Published": "2024-10-21T12:15:00",
        "access": {},
        "assigner": "cve@mitre.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-48231",
        "impact": {},
        "last-modified": "2024-10-21T19:35:00",
        "references": [
            "https://github.com/funadmin/funadmin/issues/29"
        ],
        "summary": "Funadmin 5.0.2 is vulnerable to SQL Injection via the selectFields parameter in the index method of \\backend\\controller\\auth\\Auth.php."
    },
    {
        "Modified": "2024-10-21T19:24:00",
        "Published": "2023-08-01T15:15:00",
        "access": {},
        "assigner": "security@mozilla.org",
        "cvss": null,
        "cwe": "NVD-CWE-noinfo",
        "id": "CVE-2023-4046",
        "impact": {},
        "last-modified": "2024-10-21T19:24:00",
        "references": [
            "https://bugzilla.mozilla.org/show_bug.cgi?id=1837686",
            "https://www.mozilla.org/security/advisories/mfsa2023-30/",
            "https://www.mozilla.org/security/advisories/mfsa2023-31/",
            "https://www.mozilla.org/security/advisories/mfsa2023-29/",
            "https://www.debian.org/security/2023/dsa-5464",
            "https://www.debian.org/security/2023/dsa-5469",
            "https://lists.debian.org/debian-lts-announce/2023/08/msg00008.html",
            "https://lists.debian.org/debian-lts-announce/2023/08/msg00010.html"
        ],
        "summary": "In some circumstances, a stale value could have been used for a global variable in WASM JIT analysis. This resulted in incorrect compilation and a potentially exploitable crash in the content process. This vulnerability affects Firefox < 116, Firefox ESR < 102.14, and Firefox ESR < 115.1."
    },
    {
        "Modified": "2024-10-21T19:24:00",
        "Published": "2023-08-01T15:15:00",
        "access": {},
        "assigner": "security@mozilla.org",
        "cvss": null,
        "cwe": "CWE-362",
        "id": "CVE-2023-4049",
        "impact": {},
        "last-modified": "2024-10-21T19:24:00",
        "references": [
            "https://bugzilla.mozilla.org/show_bug.cgi?id=1842658",
            "https://www.mozilla.org/security/advisories/mfsa2023-30/",
            "https://www.mozilla.org/security/advisories/mfsa2023-31/",
            "https://www.mozilla.org/security/advisories/mfsa2023-29/",
            "https://www.debian.org/security/2023/dsa-5464",
            "https://www.debian.org/security/2023/dsa-5469",
            "https://lists.debian.org/debian-lts-announce/2023/08/msg00008.html",
            "https://lists.debian.org/debian-lts-announce/2023/08/msg00010.html"
        ],
        "summary": "Race conditions in reference counting code were found through code inspection. These could have resulted in potentially exploitable use-after-free vulnerabilities. This vulnerability affects Firefox < 116, Firefox ESR < 102.14, and Firefox ESR < 115.1."
    },
    {
        "Modified": "2024-10-21T19:24:00",
        "Published": "2023-08-01T15:15:00",
        "access": {},
        "assigner": "security@mozilla.org",
        "cvss": null,
        "cwe": "CWE-346",
        "id": "CVE-2023-4045",
        "impact": {},
        "last-modified": "2024-10-21T19:24:00",
        "references": [
            "https://www.mozilla.org/security/advisories/mfsa2023-30/",
            "https://www.mozilla.org/security/advisories/mfsa2023-31/",
            "https://www.mozilla.org/security/advisories/mfsa2023-29/",
            "https://bugzilla.mozilla.org/show_bug.cgi?id=1833876",
            "https://www.debian.org/security/2023/dsa-5464",
            "https://www.debian.org/security/2023/dsa-5469",
            "https://lists.debian.org/debian-lts-announce/2023/08/msg00008.html",
            "https://lists.debian.org/debian-lts-announce/2023/08/msg00010.html"
        ],
        "summary": "Offscreen Canvas did not properly track cross-origin tainting, which could have been used to access image data from another site in violation of same-origin policy. This vulnerability affects Firefox < 116, Firefox ESR < 102.14, and Firefox ESR < 115.1."
    },
    {
        "Modified": "2024-10-21T19:24:00",
        "Published": "2023-08-01T15:15:00",
        "access": {},
        "assigner": "security@mozilla.org",
        "cvss": null,
        "cwe": "NVD-CWE-noinfo",
        "id": "CVE-2023-4047",
        "impact": {},
        "last-modified": "2024-10-21T19:24:00",
        "references": [
            "https://www.mozilla.org/security/advisories/mfsa2023-30/",
            "https://www.mozilla.org/security/advisories/mfsa2023-31/",
            "https://bugzilla.mozilla.org/show_bug.cgi?id=1839073",
            "https://www.mozilla.org/security/advisories/mfsa2023-29/",
            "https://www.debian.org/security/2023/dsa-5464",
            "https://www.debian.org/security/2023/dsa-5469",
            "https://lists.debian.org/debian-lts-announce/2023/08/msg00008.html",
            "https://lists.debian.org/debian-lts-announce/2023/08/msg00010.html"
        ],
        "summary": "A bug in popup notifications delay calculation could have made it possible for an attacker to trick a user into granting permissions. This vulnerability affects Firefox < 116, Firefox ESR < 102.14, and Firefox ESR < 115.1."
    },
    {
        "Modified": "2024-10-21T19:24:00",
        "Published": "2023-08-01T15:15:00",
        "access": {},
        "assigner": "security@mozilla.org",
        "cvss": null,
        "cwe": "CWE-125",
        "id": "CVE-2023-4048",
        "impact": {},
        "last-modified": "2024-10-21T19:24:00",
        "references": [
            "https://bugzilla.mozilla.org/show_bug.cgi?id=1841368",
            "https://www.mozilla.org/security/advisories/mfsa2023-30/",
            "https://www.mozilla.org/security/advisories/mfsa2023-31/",
            "https://www.mozilla.org/security/advisories/mfsa2023-29/",
            "https://www.debian.org/security/2023/dsa-5464",
            "https://www.debian.org/security/2023/dsa-5469",
            "https://lists.debian.org/debian-lts-announce/2023/08/msg00008.html",
            "https://lists.debian.org/debian-lts-announce/2023/08/msg00010.html"
        ],
        "summary": "An out-of-bounds read could have led to an exploitable crash when parsing HTML with DOMParser in low memory situations. This vulnerability affects Firefox < 116, Firefox ESR < 102.14, and Firefox ESR < 115.1."
    },
    {
        "Modified": "2024-10-21T19:24:00",
        "Published": "2023-08-01T15:15:00",
        "access": {},
        "assigner": "security@mozilla.org",
        "cvss": null,
        "cwe": "CWE-787",
        "id": "CVE-2023-4050",
        "impact": {},
        "last-modified": "2024-10-21T19:24:00",
        "references": [
            "https://www.mozilla.org/security/advisories/mfsa2023-30/",
            "https://www.mozilla.org/security/advisories/mfsa2023-31/",
            "https://bugzilla.mozilla.org/show_bug.cgi?id=1843038",
            "https://www.mozilla.org/security/advisories/mfsa2023-29/",
            "https://www.debian.org/security/2023/dsa-5464",
            "https://www.debian.org/security/2023/dsa-5469",
            "https://lists.debian.org/debian-lts-announce/2023/08/msg00008.html",
            "https://lists.debian.org/debian-lts-announce/2023/08/msg00010.html"
        ],
        "summary": "In some cases, an untrusted input stream was copied to a stack buffer without checking its size. This resulted in a potentially exploitable crash which could have led to a sandbox escape. This vulnerability affects Firefox < 116, Firefox ESR < 102.14, and Firefox ESR < 115.1."
    },
    {
        "Modified": "2024-10-21T19:24:00",
        "Published": "2023-08-01T16:15:00",
        "access": {},
        "assigner": "security@mozilla.org",
        "cvss": null,
        "cwe": "NVD-CWE-noinfo",
        "id": "CVE-2023-4054",
        "impact": {},
        "last-modified": "2024-10-21T19:24:00",
        "references": [
            "https://www.mozilla.org/security/advisories/mfsa2023-30/",
            "https://www.mozilla.org/security/advisories/mfsa2023-31/",
            "https://bugzilla.mozilla.org/show_bug.cgi?id=1840777",
            "https://www.mozilla.org/security/advisories/mfsa2023-29/",
            "https://www.mozilla.org/security/advisories/mfsa2023-33/",
            "https://www.mozilla.org/security/advisories/mfsa2023-32/"
        ],
        "summary": "When opening appref-ms files, Firefox did not warn the user that these files may contain malicious code. \n*This bug only affects Firefox on Windows. Other operating systems are unaffected.* This vulnerability affects Firefox < 116, Firefox ESR < 102.14, Firefox ESR < 115.1, Thunderbird < 102.14, and Thunderbird < 115.1."
    },
    {
        "Modified": "2024-10-21T19:24:00",
        "Published": "2023-08-01T16:15:00",
        "access": {},
        "assigner": "security@mozilla.org",
        "cvss": null,
        "cwe": "NVD-CWE-noinfo",
        "id": "CVE-2023-4055",
        "impact": {},
        "last-modified": "2024-10-21T19:24:00",
        "references": [
            "https://www.mozilla.org/security/advisories/mfsa2023-30/",
            "https://www.mozilla.org/security/advisories/mfsa2023-31/",
            "https://bugzilla.mozilla.org/show_bug.cgi?id=1782561",
            "https://www.mozilla.org/security/advisories/mfsa2023-29/",
            "https://www.debian.org/security/2023/dsa-5464",
            "https://www.debian.org/security/2023/dsa-5469",
            "https://lists.debian.org/debian-lts-announce/2023/08/msg00008.html",
            "https://lists.debian.org/debian-lts-announce/2023/08/msg00010.html"
        ],
        "summary": "When the number of cookies per domain was exceeded in `document.cookie`, the actual cookie jar sent to the host was no longer consistent with expected cookie jar state. This could have caused requests to be sent with some cookies missing. This vulnerability affects Firefox < 116, Firefox ESR < 102.14, and Firefox ESR < 115.1."
    },
    {
        "Modified": "2024-10-21T19:24:00",
        "Published": "2023-08-01T16:15:00",
        "access": {},
        "assigner": "security@mozilla.org",
        "cvss": null,
        "cwe": "CWE-787",
        "id": "CVE-2023-4056",
        "impact": {},
        "last-modified": "2024-10-21T19:24:00",
        "references": [
            "https://bugzilla.mozilla.org/buglist.cgi?bug_id=1820587%2C1824634%2C1839235%2C1842325%2C1843847",
            "https://www.mozilla.org/security/advisories/mfsa2023-30/",
            "https://www.mozilla.org/security/advisories/mfsa2023-31/",
            "https://www.mozilla.org/security/advisories/mfsa2023-29/",
            "https://www.debian.org/security/2023/dsa-5464",
            "https://www.debian.org/security/2023/dsa-5469",
            "https://lists.debian.org/debian-lts-announce/2023/08/msg00008.html",
            "https://lists.debian.org/debian-lts-announce/2023/08/msg00010.html"
        ],
        "summary": "Memory safety bugs present in Firefox 115, Firefox ESR 115.0, Firefox ESR 102.13, Thunderbird 115.0, and Thunderbird 102.13. Some of these bugs showed evidence of memory corruption and we presume that with enough effort some of these could have been exploited to run arbitrary code. This vulnerability affects Firefox < 116, Firefox ESR < 102.14, and Firefox ESR < 115.1."
    },
    {
        "Modified": "2024-10-21T19:21:00",
        "Published": "2024-10-15T11:15:00",
        "access": {},
        "assigner": "info@cert.vde.com",
        "cvss": null,
        "cwe": "NVD-CWE-noinfo",
        "id": "CVE-2024-45271",
        "impact": {},
        "last-modified": "2024-10-21T19:21:00",
        "references": [
            "https://cert.vde.com/en/advisories/VDE-2024-056",
            "https://cert.vde.com/en/advisories/VDE-2024-066"
        ],
        "summary": "An unauthenticated local attacker can gain admin privileges by deploying a config file due to improper input validation."
    },
    {
        "Modified": "2024-10-21T19:15:00",
        "Published": "2024-10-21T19:15:00",
        "access": {},
        "assigner": "cve@mitre.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-46238",
        "impact": {},
        "last-modified": "2024-10-21T19:15:00",
        "references": [
            "https://github.com/anoncoder01/PHP_Gurukul_Hospital_Management_System_XSS/blob/master/vulnerabilities/XSS2.md"
        ],
        "summary": "Multiple Cross Site Scripting (XSS) vulnerabilities exist in PHPGurukul Hospital Management System 4.0 via the docname parameter in /admin/add-doctor.php and /admin/edit-doctor.php"
    },
    {
        "Modified": "2024-10-21T19:15:00",
        "Published": "2024-10-21T19:15:00",
        "access": {},
        "assigner": "cve@mitre.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-46239",
        "impact": {},
        "last-modified": "2024-10-21T19:15:00",
        "references": [
            "https://github.com/anoncoder01/PHP_Gurukul_Hospital_Management_System_XSS/blob/master/vulnerabilities/XSS3.md"
        ],
        "summary": "Multiple cross-site scripting vulnerabilities exist in PHPGurukul Hospital Management System 4.0 via the docname parameter in /doctor/edit-profile.php and adminremark parameter in /admin/query-details.php."
    },
    {
        "Modified": "2024-10-21T19:15:00",
        "Published": "2024-10-21T19:15:00",
        "access": {},
        "assigner": "security-advisories@github.com",
        "cvss": null,
        "cwe": "CWE-276",
        "id": "CVE-2024-47825",
        "impact": {},
        "last-modified": "2024-10-21T19:15:00",
        "references": [
            "https://github.com/cilium/cilium/security/advisories/GHSA-3wwx-63fv-pfq6"
        ],
        "summary": "Cilium is a networking, observability, and security solution with an eBPF-based dataplane. Starting in version 1.14.0 and prior to versions 1.14.16 and 1.15.10, a policy rule denying a prefix that is broader than `/32` may be ignored if there is a policy rule referencing a more narrow prefix (`CIDRSet` or `toFQDN`) and this narrower policy rule specifies either `enableDefaultDeny: false` or `- toEntities: all`. Note that a rule specifying `toEntities: world` or `toEntities: 0.0.0.0/0` is insufficient, it must be to entity `all`.This issue has been patched in Cilium v1.14.16 and v1.15.10. As this issue only affects policies using `enableDefaultDeny: false` or that set `toEntities` to `all`, some workarounds are available. For users with policies using `enableDefaultDeny: false`, remove this configuration option and explicitly define any allow rules required. For users with egress policies that explicitly specify `toEntities: all`, use `toEntities: world`."
    },
    {
        "Modified": "2024-10-21T19:15:00",
        "Published": "2024-10-21T19:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-50003",
        "impact": {},
        "last-modified": "2024-10-21T19:15:00",
        "references": [
            "https://git.kernel.org/stable/c/eb9329cd882aa274e92bdb1003bc088433fdee86",
            "https://git.kernel.org/stable/c/722d2d8fc423108597b97efbf165187d16d9aa1e",
            "https://git.kernel.org/stable/c/68d603f467a75618eeae5bfe8af32cda47097010",
            "https://git.kernel.org/stable/c/73e441be033d3ed0bdff09b575da3e7d4606ffc9",
            "https://git.kernel.org/stable/c/c2356296f546326f9f06c109e201d42201e1e783",
            "https://git.kernel.org/stable/c/52d4e3fb3d340447dcdac0e14ff21a764f326907"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Fix system hang while resume with TBT monitor\n\n[Why]\nConnected with a Thunderbolt monitor and do the suspend and the system\nmay hang while resume.\n\nThe TBT monitor HPD will be triggered during the resume procedure\nand call the drm_client_modeset_probe() while\nstruct drm_connector connector->dev->master is NULL.\n\nIt will mess up the pipe topology after resume.\n\n[How]\nSkip the TBT monitor HPD during the resume procedure because we\ncurrently will probe the connectors after resume by default.\n\n(cherry picked from commit 453f86a26945207a16b8f66aaed5962dc2b95b85)"
    },
    {
        "Modified": "2024-10-21T19:15:00",
        "Published": "2024-10-21T19:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-50004",
        "impact": {},
        "last-modified": "2024-10-21T19:15:00",
        "references": [
            "https://git.kernel.org/stable/c/945dc25eda88b5d6e30c9686dc619ab981c22d0e",
            "https://git.kernel.org/stable/c/4010efc8516899981cc3b57be2d4a2d5d9e50228",
            "https://git.kernel.org/stable/c/0d5e5e8a0aa49ea2163abf128da3b509a6c58286"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: update DML2 policy EnhancedPrefetchScheduleAccelerationFinal DCN35\n\n[WHY & HOW]\nMismatch in DCN35 DML2 cause bw validation failed to acquire unexpected DPP pipe to cause\ngrey screen and system hang. Remove EnhancedPrefetchScheduleAccelerationFinal value override\nto match HW spec.\n\n(cherry picked from commit 9dad21f910fcea2bdcff4af46159101d7f9cd8ba)"
    },
    {
        "Modified": "2024-10-21T19:15:00",
        "Published": "2024-10-21T19:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-50005",
        "impact": {},
        "last-modified": "2024-10-21T19:15:00",
        "references": [
            "https://git.kernel.org/stable/c/e676e4ea76bbe7f1156d8c326b9b6753849481c2",
            "https://git.kernel.org/stable/c/540138377b22f601f06f55ebfa3ca171dcab471a",
            "https://git.kernel.org/stable/c/d18f669461811dfe2915d5554ab2a9834f810013",
            "https://git.kernel.org/stable/c/bff1709b3980bd7f80be6786f64cc9a9ee9e56da"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmac802154: Fix potential RCU dereference issue in mac802154_scan_worker\n\nIn the `mac802154_scan_worker` function, the `scan_req->type` field was\naccessed after the RCU read-side critical section was unlocked. According\nto RCU usage rules, this is illegal and can lead to unpredictable\nbehavior, such as accessing memory that has been updated or causing\nuse-after-free issues.\n\nThis possible bug was identified using a static analysis tool developed\nby myself, specifically designed to detect RCU-related issues.\n\nTo address this, the `scan_req->type` value is now stored in a local\nvariable `scan_req_type` while still within the RCU read-side critical\nsection. The `scan_req_type` is then used after the RCU lock is released,\nensuring that the type value is safely accessed without violating RCU\nrules."
    },
    {
        "Modified": "2024-10-21T19:15:00",
        "Published": "2024-10-21T19:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-50006",
        "impact": {},
        "last-modified": "2024-10-21T19:15:00",
        "references": [
            "https://git.kernel.org/stable/c/53b1999cfd2c7addf2e581a32865fe8835467b44",
            "https://git.kernel.org/stable/c/ef05572da0c0eb89614ed01cc17d3c882bdbd1ff",
            "https://git.kernel.org/stable/c/9fedf51ab8cf7b69bff08f37fe0989fec7f5d870",
            "https://git.kernel.org/stable/c/d43776b907659affef1de888525847d64b244194",
            "https://git.kernel.org/stable/c/6252cb6bde7fc76cb8dcb49d1def7c326b190820",
            "https://git.kernel.org/stable/c/d58a00e981d3118b91d503da263e640b7cde6729",
            "https://git.kernel.org/stable/c/cc749e61c011c255d81b192a822db650c68b313f"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix i_data_sem unlock order in ext4_ind_migrate()\n\nFuzzing reports a possible deadlock in jbd2_log_wait_commit.\n\nThis issue is triggered when an EXT4_IOC_MIGRATE ioctl is set to require\nsynchronous updates because the file descriptor is opened with O_SYNC.\nThis can lead to the jbd2_journal_stop() function calling\njbd2_might_wait_for_commit(), potentially causing a deadlock if the\nEXT4_IOC_MIGRATE call races with a write(2) system call.\n\nThis problem only arises when CONFIG_PROVE_LOCKING is enabled. In this\ncase, the jbd2_might_wait_for_commit macro locks jbd2_handle in the\njbd2_journal_stop function while i_data_sem is locked. This triggers\nlockdep because the jbd2_journal_start function might also lock the same\njbd2_handle simultaneously.\n\nFound by Linux Verification Center (linuxtesting.org) with syzkaller.\n\nRule: add"
    },
    {
        "Modified": "2024-10-21T19:15:00",
        "Published": "2024-10-21T19:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-50007",
        "impact": {},
        "last-modified": "2024-10-21T19:15:00",
        "references": [
            "https://git.kernel.org/stable/c/219587bca2678e31700ef09ecec178ba1f735674",
            "https://git.kernel.org/stable/c/36ee4021bcc37b834996e79740d095d6f8dd948f",
            "https://git.kernel.org/stable/c/e658227d9d4f4e122d81690fdbc0d438b10288f5",
            "https://git.kernel.org/stable/c/7a55740996701f7b2bc46dc988b60ef2e416a747",
            "https://git.kernel.org/stable/c/ad7248a5e92587b9266c62db8bcc4e58de53e372",
            "https://git.kernel.org/stable/c/876d04bf5a8ac1d6af5afd258cd37ab83ab2cf3d",
            "https://git.kernel.org/stable/c/7b986c7430a6bb68d523dac7bfc74cbd5b44ef96"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: asihpi: Fix potential OOB array access\n\nASIHPI driver stores some values in the static array upon a response\nfrom the driver, and its index depends on the firmware.  We shouldn't\ntrust it blindly.\n\nThis patch adds a sanity check of the array index to fit in the array\nsize."
    },
    {
        "Modified": "2024-10-21T19:15:00",
        "Published": "2024-10-21T19:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-50008",
        "impact": {},
        "last-modified": "2024-10-21T19:15:00",
        "references": [
            "https://git.kernel.org/stable/c/1756918f51e9ab247a0f4782cc28853c2bb457c1",
            "https://git.kernel.org/stable/c/e59bdb1ba594104cd0ee0af3ee9e4435d842a8fe",
            "https://git.kernel.org/stable/c/17199b69a84798efffc475040fbef44374ef1de1",
            "https://git.kernel.org/stable/c/fef7b51f22cf2049b0ca6740adeb0ba6f2e671dc",
            "https://git.kernel.org/stable/c/71267bd4e8c752d7af6c6b96bb83984a6a95273d",
            "https://git.kernel.org/stable/c/a3a12c30f9510f3753286fadbc6cdb7dad78c1d5",
            "https://git.kernel.org/stable/c/498365e52bebcbc36a93279fe7e9d6aec8479cee"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: mwifiex: Fix memcpy() field-spanning write warning in mwifiex_cmd_802_11_scan_ext()\n\nReplace one-element array with a flexible-array member in\n`struct host_cmd_ds_802_11_scan_ext`.\n\nWith this, fix the following warning:\n\nelo 16 17:51:58 surfacebook kernel: ------------[ cut here ]------------\nelo 16 17:51:58 surfacebook kernel: memcpy: detected field-spanning write (size 243) of single field \"ext_scan->tlv_buffer\" at drivers/net/wireless/marvell/mwifiex/scan.c:2239 (size 1)\nelo 16 17:51:58 surfacebook kernel: WARNING: CPU: 0 PID: 498 at drivers/net/wireless/marvell/mwifiex/scan.c:2239 mwifiex_cmd_802_11_scan_ext+0x83/0x90 [mwifiex]"
    },
    {
        "Modified": "2024-10-21T19:15:00",
        "Published": "2024-10-21T19:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-50009",
        "impact": {},
        "last-modified": "2024-10-21T19:15:00",
        "references": [
            "https://git.kernel.org/stable/c/5f250d44b8191d612355dd97b89b37bbc1b5d2cb",
            "https://git.kernel.org/stable/c/5493f9714e4cdaf0ee7cec15899a231400cb1a9f"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ncpufreq: amd-pstate: add check for cpufreq_cpu_get's return value\n\ncpufreq_cpu_get may return NULL. To avoid NULL-dereference check it\nand return in case of error.\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE."
    },
    {
        "Modified": "2024-10-21T19:15:00",
        "Published": "2024-10-21T19:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-50010",
        "impact": {},
        "last-modified": "2024-10-21T19:15:00",
        "references": [
            "https://git.kernel.org/stable/c/d62ba2a5536df83473a2ac15ab302258e3845251",
            "https://git.kernel.org/stable/c/0d196e7589cefe207d5d41f37a0a28a1fdeeb7c6"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nexec: don't WARN for racy path_noexec check\n\nBoth i_mode and noexec checks wrapped in WARN_ON stem from an artifact\nof the previous implementation. They used to legitimately check for the\ncondition, but that got moved up in two commits:\n633fb6ac3980 (\"exec: move S_ISREG() check earlier\")\n0fd338b2d2cd (\"exec: move path_noexec() check earlier\")\n\nInstead of being removed said checks are WARN_ON'ed instead, which\nhas some debug value.\n\nHowever, the spurious path_noexec check is racy, resulting in\nunwarranted warnings should someone race with setting the noexec flag.\n\nOne can note there is more to perm-checking whether execve is allowed\nand none of the conditions are guaranteed to still hold after they were\ntested for.\n\nAdditionally this does not validate whether the code path did any perm\nchecking to begin with -- it will pass if the inode happens to be\nregular.\n\nKeep the redundant path_noexec() check even though it's mindless\nnonsense checking for guarantee that isn't given so drop the WARN.\n\nReword the commentary and do small tidy ups while here.\n\n[brauner: keep redundant path_noexec() check]"
    },
    {
        "Modified": "2024-10-21T19:15:00",
        "Published": "2024-10-21T19:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-50011",
        "impact": {},
        "last-modified": "2024-10-21T19:15:00",
        "references": [
            "https://git.kernel.org/stable/c/aa3109ee91fe09e696274e6ac44813df8d13678f",
            "https://git.kernel.org/stable/c/5afc29ba44fdd1bcbad4e07246c395d946301580"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nASoC: Intel: soc-acpi-intel-rpl-match: add missing empty item\n\nThere is no links_num in struct snd_soc_acpi_mach {}, and we test\n!link->num_adr as a condition to end the loop in hda_sdw_machine_select().\nSo an empty item in struct snd_soc_acpi_link_adr array is required."
    },
    {
        "Modified": "2024-10-21T19:15:00",
        "Published": "2024-10-21T19:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-50012",
        "impact": {},
        "last-modified": "2024-10-21T19:15:00",
        "references": [
            "https://git.kernel.org/stable/c/0f41f383b5a61a2bf6429a449ebba7fb08179d81",
            "https://git.kernel.org/stable/c/77f88b17387a017416babf1e6488fa17682287e2",
            "https://git.kernel.org/stable/c/47cb1d9278f179df8250304ec41009e3e836a926",
            "https://git.kernel.org/stable/c/c0f02536fffbbec71aced36d52a765f8c4493dc2"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ncpufreq: Avoid a bad reference count on CPU node\n\nIn the parse_perf_domain function, if the call to\nof_parse_phandle_with_args returns an error, then the reference to the\nCPU device node that was acquired at the start of the function would not\nbe properly decremented.\n\nAddress this by declaring the variable with the __free(device_node)\ncleanup attribute."
    },
    {
        "Modified": "2024-10-21T19:15:00",
        "Published": "2024-10-21T19:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-50013",
        "impact": {},
        "last-modified": "2024-10-21T19:15:00",
        "references": [
            "https://git.kernel.org/stable/c/f692160d3e1e5450605071b8df8f7d08d9b09a83",
            "https://git.kernel.org/stable/c/ddf704c2ce3b73f38d2dd8cf1bb0f7ec038bdf63",
            "https://git.kernel.org/stable/c/4e1813e52f86eb8db0c6c9570251f2fcbc571f5d",
            "https://git.kernel.org/stable/c/bf0b3b35259475d1fe377bcaa565488e26684f7a",
            "https://git.kernel.org/stable/c/dca359db1eb37f334267ebd7e3cab9a66d191d5b",
            "https://git.kernel.org/stable/c/89081e8407e637463db5880d168e3652fb9f4330",
            "https://git.kernel.org/stable/c/d2b537b3e533f28e0d97293fe9293161fe8cd137"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nexfat: fix memory leak in exfat_load_bitmap()\n\nIf the first directory entry in the root directory is not a bitmap\ndirectory entry, 'bh' will not be released and reassigned, which\nwill cause a memory leak."
    },
    {
        "Modified": "2024-10-21T19:15:00",
        "Published": "2024-10-21T19:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-50014",
        "impact": {},
        "last-modified": "2024-10-21T19:15:00",
        "references": [
            "https://git.kernel.org/stable/c/d157fc20ca5239fd56965a5a8aa1a0e25919891a",
            "https://git.kernel.org/stable/c/b002031d585a14eed511117dda8c6452a804d508",
            "https://git.kernel.org/stable/c/23dfdb56581ad92a9967bcd720c8c23356af74c1"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix access to uninitialised lock in fc replay path\n\nThe following kernel trace can be triggered with fstest generic/629 when\nexecuted against a filesystem with fast-commit feature enabled:\n\nINFO: trying to register non-static key.\nThe code is fine but needs lockdep annotation, or maybe\nyou didn't initialize this object before use?\nturning off the locking correctness validator.\nCPU: 0 PID: 866 Comm: mount Not tainted 6.10.0+ #11\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.2-3-gd478f380-prebuilt.qemu.org 04/01/2014\nCall Trace:\n <TASK>\n dump_stack_lvl+0x66/0x90\n register_lock_class+0x759/0x7d0\n __lock_acquire+0x85/0x2630\n ? __find_get_block+0xb4/0x380\n lock_acquire+0xd1/0x2d0\n ? __ext4_journal_get_write_access+0xd5/0x160\n _raw_spin_lock+0x33/0x40\n ? __ext4_journal_get_write_access+0xd5/0x160\n __ext4_journal_get_write_access+0xd5/0x160\n ext4_reserve_inode_write+0x61/0xb0\n __ext4_mark_inode_dirty+0x79/0x270\n ? ext4_ext_replay_set_iblocks+0x2f8/0x450\n ext4_ext_replay_set_iblocks+0x330/0x450\n ext4_fc_replay+0x14c8/0x1540\n ? jread+0x88/0x2e0\n ? rcu_is_watching+0x11/0x40\n do_one_pass+0x447/0xd00\n jbd2_journal_recover+0x139/0x1b0\n jbd2_journal_load+0x96/0x390\n ext4_load_and_init_journal+0x253/0xd40\n ext4_fill_super+0x2cc6/0x3180\n...\n\nIn the replay path there's an attempt to lock sbi->s_bdev_wb_lock in\nfunction ext4_check_bdev_write_error().  Unfortunately, at this point this\nspinlock has not been initialized yet.  Moving it's initialization to an\nearlier point in __ext4_fill_super() fixes this splat."
    },
    {
        "Modified": "2024-10-21T19:15:00",
        "Published": "2024-10-21T19:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-50015",
        "impact": {},
        "last-modified": "2024-10-21T19:15:00",
        "references": [
            "https://git.kernel.org/stable/c/f8a7c342326f6ad1dfdb30a18dd013c70f5e9669",
            "https://git.kernel.org/stable/c/8c30a9a8610c314554997f86370140746aa35661",
            "https://git.kernel.org/stable/c/abfaa876b948baaea4d14f21a1963789845c8b4c",
            "https://git.kernel.org/stable/c/5efccdee4a7d507a483f20f880b809cc4eaef14d",
            "https://git.kernel.org/stable/c/a9f331f51515bdb3ebc8d0963131af367ef468f6",
            "https://git.kernel.org/stable/c/ec0dd451e236c46e4858d53e9e82bae7797a7af5",
            "https://git.kernel.org/stable/c/dda898d7ffe85931f9cca6d702a51f33717c501e"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: dax: fix overflowing extents beyond inode size when partially writing\n\nThe dax_iomap_rw() does two things in each iteration: map written blocks\nand copy user data to blocks. If the process is killed by user(See signal\nhandling in dax_iomap_iter()), the copied data will be returned and added\non inode size, which means that the length of written extents may exceed\nthe inode size, then fsck will fail. An example is given as:\n\ndd if=/dev/urandom of=file bs=4M count=1\n dax_iomap_rw\n  iomap_iter // round 1\n   ext4_iomap_begin\n    ext4_iomap_alloc // allocate 0~2M extents(written flag)\n  dax_iomap_iter // copy 2M data\n  iomap_iter // round 2\n   iomap_iter_advance\n    iter->pos += iter->processed // iter->pos = 2M\n   ext4_iomap_begin\n    ext4_iomap_alloc // allocate 2~4M extents(written flag)\n  dax_iomap_iter\n   fatal_signal_pending\n  done = iter->pos - iocb->ki_pos // done = 2M\n ext4_handle_inode_extension\n  ext4_update_inode_size // inode size = 2M\n\nfsck reports: Inode 13, i_size is 2097152, should be 4194304.  Fix?\n\nFix the problem by truncating extents if the written length is smaller\nthan expected."
    },
    {
        "Modified": "2024-10-21T19:15:00",
        "Published": "2024-10-21T19:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-50016",
        "impact": {},
        "last-modified": "2024-10-21T19:15:00",
        "references": [
            "https://git.kernel.org/stable/c/a1495acc6234fa79b775599d3f49009afd53299f",
            "https://git.kernel.org/stable/c/26ced9d86240868f5b41708ceee02e6ec2924498",
            "https://git.kernel.org/stable/c/adeed800bc30ef718478b28c08f79231e5980e3d",
            "https://git.kernel.org/stable/c/a15268787b79fd183dd526cc16bec9af4f4e49a1"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Avoid overflow assignment in link_dp_cts\n\nsampling_rate is an uint8_t but is assigned an unsigned int, and thus it\ncan overflow. As a result, sampling_rate is changed to uint32_t.\n\nSimilarly, LINK_QUAL_PATTERN_SET has a size of 2 bits, and it should\nonly be assigned to a value less or equal than 4.\n\nThis fixes 2 INTEGER_OVERFLOW issues reported by Coverity."
    },
    {
        "Modified": "2024-10-21T19:15:00",
        "Published": "2024-10-21T19:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-50017",
        "impact": {},
        "last-modified": "2024-10-21T19:15:00",
        "references": [
            "https://git.kernel.org/stable/c/d80a99892f7a992d103138fa4636b2c33abd6740",
            "https://git.kernel.org/stable/c/a23823098ab2c277c14fc110b97d8d5c83597195",
            "https://git.kernel.org/stable/c/cc31744a294584a36bf764a0ffa3255a8e69f036"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/mm/ident_map: Use gbpages only where full GB page should be mapped.\n\nWhen ident_pud_init() uses only GB pages to create identity maps, large\nranges of addresses not actually requested can be included in the resulting\ntable; a 4K request will map a full GB.  This can include a lot of extra\naddress space past that requested, including areas marked reserved by the\nBIOS.  That allows processor speculation into reserved regions, that on UV\nsystems can cause system halts.\n\nOnly use GB pages when map creation requests include the full GB page of\nspace.  Fall back to using smaller 2M pages when only portions of a GB page\nare included in the request.\n\nNo attempt is made to coalesce mapping requests. If a request requires a\nmap entry at the 2M (pmd) level, subsequent mapping requests within the\nsame 1G region will also be at the pmd level, even if adjacent or\noverlapping such requests could have been combined to map a full GB page.\nExisting usage starts with larger regions and then adds smaller regions, so\nthis should not have any great consequence."
    },
    {
        "Modified": "2024-10-21T19:15:00",
        "Published": "2024-10-21T19:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-50018",
        "impact": {},
        "last-modified": "2024-10-21T19:15:00",
        "references": [
            "https://git.kernel.org/stable/c/d694ad8b7e5004df86ecd415cb2320d543723672",
            "https://git.kernel.org/stable/c/5e753b743d3b38a3e10be666c32c5434423d0093",
            "https://git.kernel.org/stable/c/08062af0a52107a243f7608fd972edb54ca5b7f8"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: napi: Prevent overflow of napi_defer_hard_irqs\n\nIn commit 6f8b12d661d0 (\"net: napi: add hard irqs deferral feature\")\nnapi_defer_irqs was added to net_device and napi_defer_irqs_count was\nadded to napi_struct, both as type int.\n\nThis value never goes below zero, so there is not reason for it to be a\nsigned int. Change the type for both from int to u32, and add an\noverflow check to sysfs to limit the value to S32_MAX.\n\nThe limit of S32_MAX was chosen because the practical limit before this\npatch was S32_MAX (anything larger was an overflow) and thus there are\nno behavioral changes introduced. If the extra bit is needed in the\nfuture, the limit can be raised.\n\nBefore this patch:\n\n$ sudo bash -c 'echo 2147483649 > /sys/class/net/eth4/napi_defer_hard_irqs'\n$ cat /sys/class/net/eth4/napi_defer_hard_irqs\n-2147483647\n\nAfter this patch:\n\n$ sudo bash -c 'echo 2147483649 > /sys/class/net/eth4/napi_defer_hard_irqs'\nbash: line 0: echo: write error: Numerical result out of range\n\nSimilarly, /sys/class/net/XXXXX/tx_queue_len is defined as unsigned:\n\ninclude/linux/netdevice.h:      unsigned int            tx_queue_len;\n\nAnd has an overflow check:\n\ndev_change_tx_queue_len(..., unsigned long new_len):\n\n  if (new_len != (unsigned int)new_len)\n          return -ERANGE;"
    },
    {
        "Modified": "2024-10-21T19:15:00",
        "Published": "2024-10-09T14:15:00",
        "access": {},
        "assigner": "cve@mitre.org",
        "cvss": null,
        "cwe": "CWE-79",
        "id": "CVE-2024-46237",
        "impact": {},
        "last-modified": "2024-10-21T19:15:00",
        "references": [
            "https://github.com/npemma2/PHP_Gurukul_Hospital_Management_System_XSS",
            "https://github.com/anoncoder01/PHP_Gurukul_Hospital_Management_System_XSS/blob/master/vulnerabilities/XSS1.md"
        ],
        "summary": "PHPGurukul Hospital Management System 4.0 is vulnerable to Cross Site Scripting (XSS) via the patname, pataddress, and medhis parameters in doctor/add-patient.php and doctor/edit-patient.php."
    },
    {
        "Modified": "2024-10-21T19:05:00",
        "Published": "2024-02-13T23:15:00",
        "access": {},
        "assigner": "cve@mitre.org",
        "cvss": null,
        "cwe": "CWE-276",
        "id": "CVE-2023-38960",
        "impact": {},
        "last-modified": "2024-10-21T19:05:00",
        "references": [
            "https://rodelllemit.medium.com/insecure-permissions-vulnerability-in-raidenftpd-v2-4-build-4005-2016-04-01-ea7389be3d33"
        ],
        "summary": "Insecure Permissions issue in Raiden Professional Server RaidenFTPD v.2.4 build 4005 allows a local attacker to gain privileges and execute arbitrary code via crafted executable running from the installation directory."
    },
    {
        "Modified": "2024-10-21T18:35:00",
        "Published": "2024-10-18T23:15:00",
        "access": {},
        "assigner": "support@hackerone.com",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-29213",
        "impact": {},
        "last-modified": "2024-10-21T18:35:00",
        "references": [
            "https://forums.ivanti.com/s/article/SA-2024-07-12-CVE-2024-29213"
        ],
        "summary": "Ivanti DSM < version 2024.2 allows authenticated users on the local machine to run code with elevated privileges due to insecure ACL via unspecified attack vector."
    },
    {
        "Modified": "2024-10-21T18:35:00",
        "Published": "2024-10-18T23:15:00",
        "access": {},
        "assigner": "support@hackerone.com",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-29821",
        "impact": {},
        "last-modified": "2024-10-21T18:35:00",
        "references": [
            "https://forums.ivanti.com/s/article/SA-2024-07-12-CVE-2024-29821"
        ],
        "summary": "Ivanti DSM < version 2024.2 allows authenticated users on the local machine to run code with elevated privileges due to insecure ACL via unspecified attack vector."
    },
    {
        "Modified": "2024-10-21T18:35:00",
        "Published": "2024-10-18T19:15:00",
        "access": {},
        "assigner": "cve@mitre.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-45944",
        "impact": {},
        "last-modified": "2024-10-21T18:35:00",
        "references": [
            "https://github.com/dromara/J2EEFAST",
            "https://gitee.com/dromara/J2EEFAST",
            "https://github.com/lazy-forever/CVE-Reference/tree/main/2024/45944"
        ],
        "summary": "In J2eeFAST <=2.7, the backend function has unsafe filtering, which allows an attacker to trigger certain sensitive functions resulting in arbitrary code execution."
    },
    {
        "Modified": "2024-10-21T18:35:00",
        "Published": "2024-10-16T22:15:00",
        "access": {},
        "assigner": "psirt@autodesk.com",
        "cvss": null,
        "cwe": "CWE-787",
        "id": "CVE-2024-7994",
        "impact": {},
        "last-modified": "2024-10-21T18:35:00",
        "references": [
            "https://autodesk.com/trust/security-advisories/adsk-sa-2024-0017"
        ],
        "summary": "A maliciously crafted RFA file, when parsed through Autodesk Revit, can force a Stack-Based Buffer Overflow. A malicious actor can leverage this vulnerability to cause a crash, read sensitive data, or execute arbitrary code in the context of the current process."
    },
    {
        "Modified": "2024-10-21T18:35:00",
        "Published": "2024-02-13T22:15:00",
        "access": {},
        "assigner": "security@grafana.com",
        "cvss": null,
        "cwe": "CWE-863",
        "id": "CVE-2023-6152",
        "impact": {},
        "last-modified": "2024-10-21T18:35:00",
        "references": [
            "https://grafana.com/security/security-advisories/cve-2023-6152/",
            "https://github.com/grafana/bugbounty/security/advisories/GHSA-3hv4-r2fm-h27f"
        ],
        "summary": "A user changing their email after signing up and verifying it can change it without verification in profile settings.\n\nThe configuration option \"verify_email_enabled\" will only validate email only on sign up.\n\n"
    },
    {
        "Modified": "2024-10-21T18:35:00",
        "Published": "2023-09-04T03:15:00",
        "access": {},
        "assigner": "security@mediatek.com",
        "cvss": null,
        "cwe": "CWE-787",
        "id": "CVE-2023-32806",
        "impact": {},
        "last-modified": "2024-10-21T18:35:00",
        "references": [
            "https://corp.mediatek.com/product-security-bulletin/September-2023"
        ],
        "summary": "In wlan driver, there is a possible out of bounds write due to improper input validation. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07441589; Issue ID: ALPS07441589."
    },
    {
        "Modified": "2024-10-21T18:35:00",
        "Published": "2023-09-04T03:15:00",
        "access": {},
        "assigner": "security@mediatek.com",
        "cvss": null,
        "cwe": "CWE-787",
        "id": "CVE-2023-20841",
        "impact": {},
        "last-modified": "2024-10-21T18:35:00",
        "references": [
            "https://corp.mediatek.com/product-security-bulletin/September-2023"
        ],
        "summary": "In imgsys, there is a possible out of bounds write due to a missing valid range checking. This could lead to local escalation of privilege with System execution privileges needed. User interaction is needed for exploitation. Patch ID: ALPS07326455; Issue ID: ALPS07326441."
    },
    {
        "Modified": "2024-10-21T18:35:00",
        "Published": "2023-09-04T03:15:00",
        "access": {},
        "assigner": "security@mediatek.com",
        "cvss": null,
        "cwe": "CWE-125",
        "id": "CVE-2023-20848",
        "impact": {},
        "last-modified": "2024-10-21T18:35:00",
        "references": [
            "https://corp.mediatek.com/product-security-bulletin/September-2023"
        ],
        "summary": "In imgsys_cmdq, there is a possible out of bounds read due to a missing valid range checking. This could lead to local escalation of privilege with System execution privileges needed. User interaction is needed for exploitation. Patch ID: ALPS07340433; Issue ID: ALPS07340433."
    },
    {
        "Modified": "2024-10-21T18:35:00",
        "Published": "2023-09-04T03:15:00",
        "access": {},
        "assigner": "security@mediatek.com",
        "cvss": null,
        "cwe": "CWE-787",
        "id": "CVE-2023-20842",
        "impact": {},
        "last-modified": "2024-10-21T18:35:00",
        "references": [
            "https://corp.mediatek.com/product-security-bulletin/September-2023"
        ],
        "summary": "In imgsys_cmdq, there is a possible out of bounds write due to a missing\u00a0valid range checking. This could lead to local escalation of privilege with System execution privileges needed. User interaction is needed for exploitation. Patch ID: ALPS07354259; Issue ID: ALPS07340477."
    },
    {
        "Modified": "2024-10-21T18:35:00",
        "Published": "2023-09-04T03:15:00",
        "access": {},
        "assigner": "security@mediatek.com",
        "cvss": null,
        "cwe": "CWE-787",
        "id": "CVE-2023-20840",
        "impact": {},
        "last-modified": "2024-10-21T18:35:00",
        "references": [
            "https://corp.mediatek.com/product-security-bulletin/September-2023"
        ],
        "summary": "In imgsys, there is a possible out of bounds read and write due to a missing valid range checking. This could lead to local escalation of privilege with System execution privileges needed. User interaction is needed for exploitation. Patch ID: ALPS07326430; Issue ID: ALPS07326430."
    },
    {
        "Modified": "2024-10-21T18:35:00",
        "Published": "2023-09-04T03:15:00",
        "access": {},
        "assigner": "security@mediatek.com",
        "cvss": null,
        "cwe": "CWE-787",
        "id": "CVE-2023-20837",
        "impact": {},
        "last-modified": "2024-10-21T18:35:00",
        "references": [
            "https://corp.mediatek.com/product-security-bulletin/September-2023"
        ],
        "summary": "In seninf, there is a possible out of bounds write due to a missing bounds check. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS07992786; Issue ID: ALPS07992786."
    },
    {
        "Modified": "2024-10-21T18:35:00",
        "Published": "2023-09-04T03:15:00",
        "access": {},
        "assigner": "security@mediatek.com",
        "cvss": null,
        "cwe": "CWE-787",
        "id": "CVE-2023-32812",
        "impact": {},
        "last-modified": "2024-10-21T18:35:00",
        "references": [
            "https://corp.mediatek.com/product-security-bulletin/September-2023"
        ],
        "summary": "In gnss service, there is a possible out of bounds write due to improper input validation. This could lead to local esclation of privileges with System execution privileges needed. User interaction is not needed for exploitation. Patch ID: ALPS08017365; Issue ID: ALPS08017365."
    },
    {
        "Modified": "2024-10-21T18:27:00",
        "Published": "2024-10-16T22:15:00",
        "access": {},
        "assigner": "psirt@autodesk.com",
        "cvss": null,
        "cwe": "CWE-787",
        "id": "CVE-2024-7993",
        "impact": {},
        "last-modified": "2024-10-21T18:27:00",
        "references": [
            "https://autodesk.com/trust/security-advisories/adsk-sa-2024-0018"
        ],
        "summary": "A maliciously crafted PDF file, when parsed through Autodesk Revit, can force an Out-of-Bounds Write. A malicious actor can leverage this vulnerability to cause a crash, write sensitive data, or execute arbitrary code in the context of the current process."
    },
    {
        "Modified": "2024-10-21T18:27:00",
        "Published": "2024-10-15T20:15:00",
        "access": {},
        "assigner": "secalert_us@oracle.com",
        "cvss": null,
        "cwe": "NVD-CWE-noinfo",
        "id": "CVE-2024-21261",
        "impact": {},
        "last-modified": "2024-10-21T18:27:00",
        "references": [
            "https://www.oracle.com/security-alerts/cpuoct2024.html"
        ],
        "summary": "Vulnerability in Oracle Application Express (component: General).  Supported versions that are affected are 23.2 and  24.1. Difficult to exploit vulnerability allows low privileged attacker with network access via HTTP to compromise Oracle Application Express.  While the vulnerability is in Oracle Application Express, attacks may significantly impact additional products (scope change).  Successful attacks of this vulnerability can result in  unauthorized update, insert or delete access to some of Oracle Application Express accessible data as well as  unauthorized read access to a subset of Oracle Application Express accessible data. CVSS 3.1 Base Score 4.9 (Confidentiality and Integrity impacts).  CVSS Vector: (CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:L/I:L/A:N)."
    },
    {
        "Modified": "2024-10-21T18:20:00",
        "Published": "2024-10-16T17:15:00",
        "access": {},
        "assigner": "security@vmware.com",
        "cvss": null,
        "cwe": "CWE-89",
        "id": "CVE-2024-38814",
        "impact": {},
        "last-modified": "2024-10-21T18:20:00",
        "references": [
            "https://support.broadcom.com/web/ecx/support-content-notification/-/external/content/SecurityAdvisories/0/25019"
        ],
        "summary": "An authenticated SQL injection vulnerability in VMware HCX was privately reported to VMware. A\n malicious authenticated user with non-administrator privileges may be \nable to enter specially crafted SQL queries and perform unauthorized \nremote code execution on the HCX manager.\u00a0\nUpdates are available to remediate this vulnerability in affected VMware products."
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49880",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/0d80d2b8bf613398baf7185009e35f9d0459ecb0",
            "https://git.kernel.org/stable/c/acb559d6826116cc113598640d105094620c2526",
            "https://git.kernel.org/stable/c/6121258c2b33ceac3d21f6a221452692c465df88"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix off by one issue in alloc_flex_gd()\n\nWesley reported an issue:\n\n==================================================================\nEXT4-fs (dm-5): resizing filesystem from 7168 to 786432 blocks\n------------[ cut here ]------------\nkernel BUG at fs/ext4/resize.c:324!\nCPU: 9 UID: 0 PID: 3576 Comm: resize2fs Not tainted 6.11.0+ #27\nRIP: 0010:ext4_resize_fs+0x1212/0x12d0\nCall Trace:\n __ext4_ioctl+0x4e0/0x1800\n ext4_ioctl+0x12/0x20\n __x64_sys_ioctl+0x99/0xd0\n x64_sys_call+0x1206/0x20d0\n do_syscall_64+0x72/0x110\n entry_SYSCALL_64_after_hwframe+0x76/0x7e\n==================================================================\n\nWhile reviewing the patch, Honza found that when adjusting resize_bg in\nalloc_flex_gd(), it was possible for flex_gd->resize_bg to be bigger than\nflexbg_size.\n\nThe reproduction of the problem requires the following:\n\n o_group = flexbg_size * 2 * n;\n o_size = (o_group + 1) * group_size;\n n_group: [o_group + flexbg_size, o_group + flexbg_size * 2)\n o_size = (n_group + 1) * group_size;\n\nTake n=0,flexbg_size=16 as an example:\n\n              last:15\n|o---------------|--------------n-|\no_group:0    resize to      n_group:30\n\nThe corresponding reproducer is:\n\nimg=test.img\nrm -f $img\ntruncate -s 600M $img\nmkfs.ext4 -F $img -b 1024 -G 16 8M\ndev=`losetup -f --show $img`\nmkdir -p /tmp/test\nmount $dev /tmp/test\nresize2fs $dev 248M\n\nDelete the problematic plus 1 to fix the issue, and add a WARN_ON_ONCE()\nto prevent the issue from happening again.\n\n[ Note: another reproucer which this commit fixes is:\n\n  img=test.img\n  rm -f $img\n  truncate -s 25MiB $img\n  mkfs.ext4 -b 4096 -E nodiscard,lazy_itable_init=0,lazy_journal_init=0 $img\n  truncate -s 3GiB $img\n  dev=`losetup -f --show $img`\n  mkdir -p /tmp/test\n  mount $dev /tmp/test\n  resize2fs $dev 3G\n  umount $dev\n  losetup -d $dev\n\n  -- TYT ]"
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49882",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/b6c29c8f3d7cb67b505f3b2f6c242d52298d1f2e",
            "https://git.kernel.org/stable/c/32bbb59e3f18facd7201bef110010bf35819b8c3",
            "https://git.kernel.org/stable/c/78bbc3d15b6f443acb26e94418c445bac940d414",
            "https://git.kernel.org/stable/c/68a69cf60660c73990c1875f94a5551600b04775",
            "https://git.kernel.org/stable/c/7633407ca4ab8be2916ab214eb44ccebc6a50e1a",
            "https://git.kernel.org/stable/c/230ee0535d01478bad9a3037292043f39b9be10b",
            "https://git.kernel.org/stable/c/dcaa6c31134c0f515600111c38ed7750003e1b9c"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix double brelse() the buffer of the extents path\n\nIn ext4_ext_try_to_merge_up(), set path[1].p_bh to NULL after it has been\nreleased, otherwise it may be released twice. An example of what triggers\nthis is as follows:\n\n  split2    map    split1\n|--------|-------|--------|\n\next4_ext_map_blocks\n ext4_ext_handle_unwritten_extents\n  ext4_split_convert_extents\n   // path->p_depth == 0\n   ext4_split_extent\n     // 1. do split1\n     ext4_split_extent_at\n       |ext4_ext_insert_extent\n       |  ext4_ext_create_new_leaf\n       |    ext4_ext_grow_indepth\n       |      le16_add_cpu(&neh->eh_depth, 1)\n       |    ext4_find_extent\n       |      // return -ENOMEM\n       |// get error and try zeroout\n       |path = ext4_find_extent\n       |  path->p_depth = 1\n       |ext4_ext_try_to_merge\n       |  ext4_ext_try_to_merge_up\n       |    path->p_depth = 0\n       |    brelse(path[1].p_bh)  ---> not set to NULL here\n       |// zeroout success\n     // 2. update path\n     ext4_find_extent\n     // 3. do split2\n     ext4_split_extent_at\n       ext4_ext_insert_extent\n         ext4_ext_create_new_leaf\n           ext4_ext_grow_indepth\n             le16_add_cpu(&neh->eh_depth, 1)\n           ext4_find_extent\n             path[0].p_bh = NULL;\n             path->p_depth = 1\n             read_extent_tree_block  ---> return err\n             // path[1].p_bh is still the old value\n             ext4_free_ext_path\n               ext4_ext_drop_refs\n                 // path->p_depth == 1\n                 brelse(path[1].p_bh)  ---> brelse a buffer twice\n\nFinally got the following WARRNING when removing the buffer from lru:\n\n============================================\nVFS: brelse: Trying to free free buffer\nWARNING: CPU: 2 PID: 72 at fs/buffer.c:1241 __brelse+0x58/0x90\nCPU: 2 PID: 72 Comm: kworker/u19:1 Not tainted 6.9.0-dirty #716\nRIP: 0010:__brelse+0x58/0x90\nCall Trace:\n <TASK>\n __find_get_block+0x6e7/0x810\n bdev_getblk+0x2b/0x480\n __ext4_get_inode_loc+0x48a/0x1240\n ext4_get_inode_loc+0xb2/0x150\n ext4_reserve_inode_write+0xb7/0x230\n __ext4_mark_inode_dirty+0x144/0x6a0\n ext4_ext_insert_extent+0x9c8/0x3230\n ext4_ext_map_blocks+0xf45/0x2dc0\n ext4_map_blocks+0x724/0x1700\n ext4_do_writepages+0x12d6/0x2a70\n[...]\n============================================"
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49867",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/70b60c8d9b42763d6629e44f448aa5d8ae477d61",
            "https://git.kernel.org/stable/c/4c98fe0dfa2ae83c4631699695506d8941db4bfe",
            "https://git.kernel.org/stable/c/9da40aea63f8769f28afb91aea0fac4cf6fbbb65",
            "https://git.kernel.org/stable/c/ed87190e9d9c80aad220fb6b0b03a84d22e2c95b",
            "https://git.kernel.org/stable/c/bf0de0f9a0544c11f96f93206da04ab87dcea1f4",
            "https://git.kernel.org/stable/c/65d11eb276836d49003a8060cf31fa2284ad1047",
            "https://git.kernel.org/stable/c/41fd1e94066a815a7ab0a7025359e9b40e4b3576"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: wait for fixup workers before stopping cleaner kthread during umount\n\nDuring unmount, at close_ctree(), we have the following steps in this order:\n\n1) Park the cleaner kthread - this doesn't destroy the kthread, it basically\n   halts its execution (wake ups against it work but do nothing);\n\n2) We stop the cleaner kthread - this results in freeing the respective\n   struct task_struct;\n\n3) We call btrfs_stop_all_workers() which waits for any jobs running in all\n   the work queues and then free the work queues.\n\nSyzbot reported a case where a fixup worker resulted in a crash when doing\na delayed iput on its inode while attempting to wake up the cleaner at\nbtrfs_add_delayed_iput(), because the task_struct of the cleaner kthread\nwas already freed. This can happen during unmount because we don't wait\nfor any fixup workers still running before we call kthread_stop() against\nthe cleaner kthread, which stops and free all its resources.\n\nFix this by waiting for any fixup workers at close_ctree() before we call\nkthread_stop() against the cleaner and run pending delayed iputs.\n\nThe stack traces reported by syzbot were the following:\n\n  BUG: KASAN: slab-use-after-free in __lock_acquire+0x77/0x2050 kernel/locking/lockdep.c:5065\n  Read of size 8 at addr ffff8880272a8a18 by task kworker/u8:3/52\n\n  CPU: 1 UID: 0 PID: 52 Comm: kworker/u8:3 Not tainted 6.12.0-rc1-syzkaller #0\n  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024\n  Workqueue: btrfs-fixup btrfs_work_helper\n  Call Trace:\n   <TASK>\n   __dump_stack lib/dump_stack.c:94 [inline]\n   dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120\n   print_address_description mm/kasan/report.c:377 [inline]\n   print_report+0x169/0x550 mm/kasan/report.c:488\n   kasan_report+0x143/0x180 mm/kasan/report.c:601\n   __lock_acquire+0x77/0x2050 kernel/locking/lockdep.c:5065\n   lock_acquire+0x1ed/0x550 kernel/locking/lockdep.c:5825\n   __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:110 [inline]\n   _raw_spin_lock_irqsave+0xd5/0x120 kernel/locking/spinlock.c:162\n   class_raw_spinlock_irqsave_constructor include/linux/spinlock.h:551 [inline]\n   try_to_wake_up+0xb0/0x1480 kernel/sched/core.c:4154\n   btrfs_writepage_fixup_worker+0xc16/0xdf0 fs/btrfs/inode.c:2842\n   btrfs_work_helper+0x390/0xc50 fs/btrfs/async-thread.c:314\n   process_one_work kernel/workqueue.c:3229 [inline]\n   process_scheduled_works+0xa63/0x1850 kernel/workqueue.c:3310\n   worker_thread+0x870/0xd30 kernel/workqueue.c:3391\n   kthread+0x2f0/0x390 kernel/kthread.c:389\n   ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147\n   ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n   </TASK>\n\n  Allocated by task 2:\n   kasan_save_stack mm/kasan/common.c:47 [inline]\n   kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n   unpoison_slab_object mm/kasan/common.c:319 [inline]\n   __kasan_slab_alloc+0x66/0x80 mm/kasan/common.c:345\n   kasan_slab_alloc include/linux/kasan.h:247 [inline]\n   slab_post_alloc_hook mm/slub.c:4086 [inline]\n   slab_alloc_node mm/slub.c:4135 [inline]\n   kmem_cache_alloc_node_noprof+0x16b/0x320 mm/slub.c:4187\n   alloc_task_struct_node kernel/fork.c:180 [inline]\n   dup_task_struct+0x57/0x8c0 kernel/fork.c:1107\n   copy_process+0x5d1/0x3d50 kernel/fork.c:2206\n   kernel_clone+0x223/0x880 kernel/fork.c:2787\n   kernel_thread+0x1bc/0x240 kernel/fork.c:2849\n   create_kthread kernel/kthread.c:412 [inline]\n   kthreadd+0x60d/0x810 kernel/kthread.c:765\n   ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147\n   ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244\n\n  Freed by task 61:\n   kasan_save_stack mm/kasan/common.c:47 [inline]\n   kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n   kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:579\n   poison_slab_object mm/kasan/common.c:247 [inline]\n   __kasan_slab_free+0x59/0x70 mm/kasan/common.c:264\n   kasan_slab_free include/linux/kasan.h:230 [inline]\n   slab_free_h\n---truncated---"
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49884",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/e52f933598b781d291b9297e39c463536da0e185",
            "https://git.kernel.org/stable/c/cafcc1bd62934547c76abf46c6d0d54f135006fe",
            "https://git.kernel.org/stable/c/a5401d4c3e2a3d25643c567d26e6de327774a2c9",
            "https://git.kernel.org/stable/c/8fe117790b37c84c651e2bad9efc0e7fda73c0e3",
            "https://git.kernel.org/stable/c/5d949ea75bb529ea6342e83465938a3b0ac51238",
            "https://git.kernel.org/stable/c/915ac3630488af0ca194dc63b86d99802b4f6e18",
            "https://git.kernel.org/stable/c/c26ab35702f8cd0cdc78f96aa5856bfb77be798f"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix slab-use-after-free in ext4_split_extent_at()\n\nWe hit the following use-after-free:\n\n==================================================================\nBUG: KASAN: slab-use-after-free in ext4_split_extent_at+0xba8/0xcc0\nRead of size 2 at addr ffff88810548ed08 by task kworker/u20:0/40\nCPU: 0 PID: 40 Comm: kworker/u20:0 Not tainted 6.9.0-dirty #724\nCall Trace:\n <TASK>\n kasan_report+0x93/0xc0\n ext4_split_extent_at+0xba8/0xcc0\n ext4_split_extent.isra.0+0x18f/0x500\n ext4_split_convert_extents+0x275/0x750\n ext4_ext_handle_unwritten_extents+0x73e/0x1580\n ext4_ext_map_blocks+0xe20/0x2dc0\n ext4_map_blocks+0x724/0x1700\n ext4_do_writepages+0x12d6/0x2a70\n[...]\n\nAllocated by task 40:\n __kmalloc_noprof+0x1ac/0x480\n ext4_find_extent+0xf3b/0x1e70\n ext4_ext_map_blocks+0x188/0x2dc0\n ext4_map_blocks+0x724/0x1700\n ext4_do_writepages+0x12d6/0x2a70\n[...]\n\nFreed by task 40:\n kfree+0xf1/0x2b0\n ext4_find_extent+0xa71/0x1e70\n ext4_ext_insert_extent+0xa22/0x3260\n ext4_split_extent_at+0x3ef/0xcc0\n ext4_split_extent.isra.0+0x18f/0x500\n ext4_split_convert_extents+0x275/0x750\n ext4_ext_handle_unwritten_extents+0x73e/0x1580\n ext4_ext_map_blocks+0xe20/0x2dc0\n ext4_map_blocks+0x724/0x1700\n ext4_do_writepages+0x12d6/0x2a70\n[...]\n==================================================================\n\nThe flow of issue triggering is as follows:\n\next4_split_extent_at\n  path = *ppath\n  ext4_ext_insert_extent(ppath)\n    ext4_ext_create_new_leaf(ppath)\n      ext4_find_extent(orig_path)\n        path = *orig_path\n        read_extent_tree_block\n          // return -ENOMEM or -EIO\n        ext4_free_ext_path(path)\n          kfree(path)\n        *orig_path = NULL\n  a. If err is -ENOMEM:\n  ext4_ext_dirty(path + path->p_depth)\n  // path use-after-free !!!\n  b. If err is -EIO and we have EXT_DEBUG defined:\n  ext4_ext_show_leaf(path)\n    eh = path[depth].p_hdr\n    // path also use-after-free !!!\n\nSo when trying to zeroout or fix the extent length, call ext4_find_extent()\nto update the path.\n\nIn addition we use *ppath directly as an ext4_ext_show_leaf() input to\navoid possible use-after-free when EXT_DEBUG is defined, and to avoid\nunnecessary path updates."
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49864",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/cdf4bbbdb956d7426f687f38757ebca2a2759a0f",
            "https://git.kernel.org/stable/c/56e415202b8a17de6496f4023e545fcb66f118ec",
            "https://git.kernel.org/stable/c/c64f5fc95e9612fdf75587c8e21e494e614c18e2",
            "https://git.kernel.org/stable/c/bc212465326e8587325f520a052346f0b57360e6"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nrxrpc: Fix a race between socket set up and I/O thread creation\n\nIn rxrpc_open_socket(), it sets up the socket and then sets up the I/O\nthread that will handle it.  This is a problem, however, as there's a gap\nbetween the two phases in which a packet may come into rxrpc_encap_rcv()\nfrom the UDP packet but we oops when trying to wake the not-yet created I/O\nthread.\n\nAs a quick fix, just make rxrpc_encap_rcv() discard the packet if there's\nno I/O thread yet.\n\nA better, but more intrusive fix would perhaps be to rearrange things such\nthat the socket creation is done by the I/O thread."
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49901",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/9288a9676c529ad9c856096db68fad812499bc4a",
            "https://git.kernel.org/stable/c/9773737375b20070ea935203fd66cb9fa17c5acb",
            "https://git.kernel.org/stable/c/e8ac2060597a5768e4699bb61d604b4c09927b85",
            "https://git.kernel.org/stable/c/16007768551d5bfe53426645401435ca8d2ef54f"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/msm/adreno: Assign msm_gpu->pdev earlier to avoid nullptrs\n\nThere are some cases, such as the one uncovered by Commit 46d4efcccc68\n(\"drm/msm/a6xx: Avoid a nullptr dereference when speedbin setting fails\")\nwhere\n\nmsm_gpu_cleanup() : platform_set_drvdata(gpu->pdev, NULL);\n\nis called on gpu->pdev == NULL, as the GPU device has not been fully\ninitialized yet.\n\nTurns out that there's more than just the aforementioned path that\ncauses this to happen (e.g. the case when there's speedbin data in the\ncatalog, but opp-supported-hw is missing in DT).\n\nAssigning msm_gpu->pdev earlier seems like the least painful solution\nto this, therefore do so.\n\nPatchwork: https://patchwork.freedesktop.org/patch/602742/"
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49866",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/322920b53dc11f9c2b33397eb3ae5bc6a175b60d",
            "https://git.kernel.org/stable/c/ce25f33ba89d6eefef64157655d318444580fa14",
            "https://git.kernel.org/stable/c/a6e9849063a6c8f4cb2f652a437e44e3ed24356c",
            "https://git.kernel.org/stable/c/a0d9c0cd5856191e095cf43a2e141b73945b7716",
            "https://git.kernel.org/stable/c/f72b451dc75578f644a3019c1489e9ae2c14e6c4",
            "https://git.kernel.org/stable/c/829e0c9f0855f26b3ae830d17b24aec103f7e915"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing/timerlat: Fix a race during cpuhp processing\n\nThere is another found exception that the \"timerlat/1\" thread was\nscheduled on CPU0, and lead to timer corruption finally:\n\n```\nODEBUG: init active (active state 0) object: ffff888237c2e108 object type: hrtimer hint: timerlat_irq+0x0/0x220\nWARNING: CPU: 0 PID: 426 at lib/debugobjects.c:518 debug_print_object+0x7d/0xb0\nModules linked in:\nCPU: 0 UID: 0 PID: 426 Comm: timerlat/1 Not tainted 6.11.0-rc7+ #45\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014\nRIP: 0010:debug_print_object+0x7d/0xb0\n...\nCall Trace:\n <TASK>\n ? __warn+0x7c/0x110\n ? debug_print_object+0x7d/0xb0\n ? report_bug+0xf1/0x1d0\n ? prb_read_valid+0x17/0x20\n ? handle_bug+0x3f/0x70\n ? exc_invalid_op+0x13/0x60\n ? asm_exc_invalid_op+0x16/0x20\n ? debug_print_object+0x7d/0xb0\n ? debug_print_object+0x7d/0xb0\n ? __pfx_timerlat_irq+0x10/0x10\n __debug_object_init+0x110/0x150\n hrtimer_init+0x1d/0x60\n timerlat_main+0xab/0x2d0\n ? __pfx_timerlat_main+0x10/0x10\n kthread+0xb7/0xe0\n ? __pfx_kthread+0x10/0x10\n ret_from_fork+0x2d/0x40\n ? __pfx_kthread+0x10/0x10\n ret_from_fork_asm+0x1a/0x30\n </TASK>\n```\n\nAfter tracing the scheduling event, it was discovered that the migration\nof the \"timerlat/1\" thread was performed during thread creation. Further\nanalysis confirmed that it is because the CPU online processing for\nosnoise is implemented through workers, which is asynchronous with the\noffline processing. When the worker was scheduled to create a thread, the\nCPU may has already been removed from the cpu_online_mask during the offline\nprocess, resulting in the inability to select the right CPU:\n\nT1                       | T2\n[CPUHP_ONLINE]           | cpu_device_down()\nosnoise_hotplug_workfn() |\n                         |     cpus_write_lock()\n                         |     takedown_cpu(1)\n                         |     cpus_write_unlock()\n[CPUHP_OFFLINE]          |\n    cpus_read_lock()     |\n    start_kthread(1)     |\n    cpus_read_unlock()   |\n\nTo fix this, skip online processing if the CPU is already offline."
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49871",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/4449fedb8a710043fc0925409eba844c192d4337",
            "https://git.kernel.org/stable/c/34e304cc53ae5d3c8e3f08b41dd11e0d4f3e01ed",
            "https://git.kernel.org/stable/c/7c3f04223aaf82489472d614c6decee5a1ce8d7f",
            "https://git.kernel.org/stable/c/9a38791ee79bd17d225c15a6d1479448be127a59",
            "https://git.kernel.org/stable/c/122b160561f6429701a0559a0f39b0ae309488c6",
            "https://git.kernel.org/stable/c/fb5cc65f973661241e4a2b7390b429aa7b330c69"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nInput: adp5589-keys - fix NULL pointer dereference\n\nWe register a devm action to call adp5589_clear_config() and then pass\nthe i2c client as argument so that we can call i2c_get_clientdata() in\norder to get our device object. However, i2c_set_clientdata() is only\nbeing set at the end of the probe function which means that we'll get a\nNULL pointer dereference in case the probe function fails early."
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49903",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/fd026b6b6758d5569705c02540b40f3bbf822b9a",
            "https://git.kernel.org/stable/c/e7ae14f7ee76c6ef5a48aebab1a278ad78f42619",
            "https://git.kernel.org/stable/c/0c238da83f56bb895cab1e5851d034ac45b158d1",
            "https://git.kernel.org/stable/c/4218b31ecc7af7e191768d32e32ed4386d8f9b76",
            "https://git.kernel.org/stable/c/a9603a6f75df2fd8125cd208c98cfaa0fe3f7505",
            "https://git.kernel.org/stable/c/95accb7183badca387f7a8d19a2475cf3089f148",
            "https://git.kernel.org/stable/c/d6c1b3599b2feb5c7291f5ac3a36e5fa7cedb234"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\njfs: Fix uaf in dbFreeBits\n\n[syzbot reported]\n==================================================================\nBUG: KASAN: slab-use-after-free in __mutex_lock_common kernel/locking/mutex.c:587 [inline]\nBUG: KASAN: slab-use-after-free in __mutex_lock+0xfe/0xd70 kernel/locking/mutex.c:752\nRead of size 8 at addr ffff8880229254b0 by task syz-executor357/5216\n\nCPU: 0 UID: 0 PID: 5216 Comm: syz-executor357 Not tainted 6.11.0-rc3-syzkaller-00156-gd7a5aa4b3c00 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 06/27/2024\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:93 [inline]\n dump_stack_lvl+0x241/0x360 lib/dump_stack.c:119\n print_address_description mm/kasan/report.c:377 [inline]\n print_report+0x169/0x550 mm/kasan/report.c:488\n kasan_report+0x143/0x180 mm/kasan/report.c:601\n __mutex_lock_common kernel/locking/mutex.c:587 [inline]\n __mutex_lock+0xfe/0xd70 kernel/locking/mutex.c:752\n dbFreeBits+0x7ea/0xd90 fs/jfs/jfs_dmap.c:2390\n dbFreeDmap fs/jfs/jfs_dmap.c:2089 [inline]\n dbFree+0x35b/0x680 fs/jfs/jfs_dmap.c:409\n dbDiscardAG+0x8a9/0xa20 fs/jfs/jfs_dmap.c:1650\n jfs_ioc_trim+0x433/0x670 fs/jfs/jfs_discard.c:100\n jfs_ioctl+0x2d0/0x3e0 fs/jfs/ioctl.c:131\n vfs_ioctl fs/ioctl.c:51 [inline]\n __do_sys_ioctl fs/ioctl.c:907 [inline]\n __se_sys_ioctl+0xfc/0x170 fs/ioctl.c:893\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n\nFreed by task 5218:\n kasan_save_stack mm/kasan/common.c:47 [inline]\n kasan_save_track+0x3f/0x80 mm/kasan/common.c:68\n kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:579\n poison_slab_object+0xe0/0x150 mm/kasan/common.c:240\n __kasan_slab_free+0x37/0x60 mm/kasan/common.c:256\n kasan_slab_free include/linux/kasan.h:184 [inline]\n slab_free_hook mm/slub.c:2252 [inline]\n slab_free mm/slub.c:4473 [inline]\n kfree+0x149/0x360 mm/slub.c:4594\n dbUnmount+0x11d/0x190 fs/jfs/jfs_dmap.c:278\n jfs_mount_rw+0x4ac/0x6a0 fs/jfs/jfs_mount.c:247\n jfs_remount+0x3d1/0x6b0 fs/jfs/super.c:454\n reconfigure_super+0x445/0x880 fs/super.c:1083\n vfs_cmd_reconfigure fs/fsopen.c:263 [inline]\n vfs_fsconfig_locked fs/fsopen.c:292 [inline]\n __do_sys_fsconfig fs/fsopen.c:473 [inline]\n __se_sys_fsconfig+0xb6e/0xf80 fs/fsopen.c:345\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\n[Analysis]\nThere are two paths (dbUnmount and jfs_ioc_trim) that generate race\ncondition when accessing bmap, which leads to the occurrence of uaf.\n\nUse the lock s_umount to synchronize them, in order to avoid uaf caused\nby race condition."
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49873",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/570dd14bfecf281fa467c80f8ec92b26370ee36a",
            "https://git.kernel.org/stable/c/c225c4f6056b46a8a5bf2ed35abf17a2d6887691"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/filemap: fix filemap_get_folios_contig THP panic\n\nPatch series \"memfd-pin huge page fixes\".\n\nFix multiple bugs that occur when using memfd_pin_folios with hugetlb\npages and THP.  The hugetlb bugs only bite when the page is not yet\nfaulted in when memfd_pin_folios is called.  The THP bug bites when the\nstarting offset passed to memfd_pin_folios is not huge page aligned.  See\nthe commit messages for details.\n\n\nThis patch (of 5):\n\nmemfd_pin_folios on memory backed by THP panics if the requested start\noffset is not huge page aligned:\n\nBUG: kernel NULL pointer dereference, address: 0000000000000036\nRIP: 0010:filemap_get_folios_contig+0xdf/0x290\nRSP: 0018:ffffc9002092fbe8 EFLAGS: 00010202\nRAX: 0000000000000002 RBX: 0000000000000002 RCX: 0000000000000002\n\nThe fault occurs here, because xas_load returns a folio with value 2:\n\n    filemap_get_folios_contig()\n        for (folio = xas_load(&xas); folio && xas.xa_index <= end;\n                        folio = xas_next(&xas)) {\n                ...\n                if (!folio_try_get(folio))   <-- BOOM\n\n\"2\" is an xarray sibling entry.  We get it because memfd_pin_folios does\nnot round the indices passed to filemap_get_folios_contig to huge page\nboundaries for THP, so we load from the middle of a huge page range see a\nsibling.  (It does round for hugetlbfs, at the is_file_hugepages test).\n\nTo fix, if the folio is a sibling, then return the next index as the\nstarting point for the next call to filemap_get_folios_contig."
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49913",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/1ebfa6663807c144be8c8b6727375012409d2356",
            "https://git.kernel.org/stable/c/8ab59527852a6f7780aad6185729550ca0569122",
            "https://git.kernel.org/stable/c/40193ff73630adf76bc0d82398f7d90fb576dba4",
            "https://git.kernel.org/stable/c/e47e563c6f0db7d792a559301862c19ead0dfc2f",
            "https://git.kernel.org/stable/c/3929e382e4758aff42da0102a60d13337c99d3b8",
            "https://git.kernel.org/stable/c/73efd2a611b62fee71a7b7f27d9d08bb60da8a72",
            "https://git.kernel.org/stable/c/66d71a72539e173a9b00ca0b1852cbaa5f5bf1ad"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Add null check for top_pipe_to_program in commit_planes_for_stream\n\nThis commit addresses a null pointer dereference issue in the\n`commit_planes_for_stream` function at line 4140. The issue could occur\nwhen `top_pipe_to_program` is null.\n\nThe fix adds a check to ensure `top_pipe_to_program` is not null before\naccessing its stream_res. This prevents a null pointer dereference.\n\nReported by smatch:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/core/dc.c:4140 commit_planes_for_stream() error: we previously assumed 'top_pipe_to_program' could be null (see line 3906)"
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49897",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/1decf695ce08e23d9ded6ce83d121b2282ce9899",
            "https://git.kernel.org/stable/c/3ba1219e299ab5462b5cb374c2fa2a67af0ea190",
            "https://git.kernel.org/stable/c/3718a619a8c0a53152e76bb6769b6c414e1e83f4"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Check phantom_stream before it is used\n\ndcn32_enable_phantom_stream can return null, so returned value\nmust be checked before used.\n\nThis fixes 1 NULL_RETURNS issue reported by Coverity."
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49921",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/5b35bf1a82eb29841b67ff5643ba83762250fc24",
            "https://git.kernel.org/stable/c/be1fb44389ca3038ad2430dac4234669bc177ee3"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Check null pointers before used\n\n[WHAT & HOW]\nPoniters, such as dc->clk_mgr, are null checked previously in the same\nfunction, so Coverity warns \"implies that \"dc->clk_mgr\" might be null\".\nAs a result, these pointers need to be checked when used again.\n\nThis fixes 10 FORWARD_NULL issues reported by Coverity."
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49899",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/7f8e93b862aba08d540f1e9e03e0ceb4d0cfd5fb",
            "https://git.kernel.org/stable/c/b995c0a6de6c74656a0c39cd57a0626351b13e3c"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Initialize denominators' default to 1\n\n[WHAT & HOW]\nVariables used as denominators and maybe not assigned to other values,\nshould not be 0. Change their default to 1 so they are never 0.\n\nThis fixes 10 DIVIDE_BY_ZERO issues reported by Coverity."
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49911",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/02411e9359297512946705b1cd8cf5e6b0806fa0",
            "https://git.kernel.org/stable/c/827380b114f83c30b3e56d1a675980b6d65f7c88",
            "https://git.kernel.org/stable/c/62ed6f0f198da04e884062264df308277628004f"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Add NULL check for function pointer in dcn20_set_output_transfer_func\n\nThis commit adds a null check for the set_output_gamma function pointer\nin the dcn20_set_output_transfer_func function. Previously,\nset_output_gamma was being checked for null at line 1030, but then it\nwas being dereferenced without any null check at line 1048. This could\npotentially lead to a null pointer dereference error if set_output_gamma\nis null.\n\nTo fix this, we now ensure that set_output_gamma is not null before\ndereferencing it. We do this by adding a null check for set_output_gamma\nbefore the call to set_output_gamma at line 1048."
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49926",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/3104bddc666ff64b90491868bbc4c7ebdd90aedf",
            "https://git.kernel.org/stable/c/05095271a4fb0f6497121a057f9a2edf386d5d96",
            "https://git.kernel.org/stable/c/fd70e9f1d85f5323096ad313ba73f5fe3d15ea41"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nrcu-tasks: Fix access non-existent percpu rtpcp variable in rcu_tasks_need_gpcb()\n\nFor kernels built with CONFIG_FORCE_NR_CPUS=y, the nr_cpu_ids is\ndefined as NR_CPUS instead of the number of possible cpus, this\nwill cause the following system panic:\n\nsmpboot: Allowing 4 CPUs, 0 hotplug CPUs\n...\nsetup_percpu: NR_CPUS:512 nr_cpumask_bits:512 nr_cpu_ids:512 nr_node_ids:1\n...\nBUG: unable to handle page fault for address: ffffffff9911c8c8\nOops: 0000 [#1] PREEMPT SMP PTI\nCPU: 0 PID: 15 Comm: rcu_tasks_trace Tainted: G W\n6.6.21 #1 5dc7acf91a5e8e9ac9dcfc35bee0245691283ea6\nRIP: 0010:rcu_tasks_need_gpcb+0x25d/0x2c0\nRSP: 0018:ffffa371c00a3e60 EFLAGS: 00010082\nCR2: ffffffff9911c8c8 CR3: 000000040fa20005 CR4: 00000000001706f0\nCall Trace:\n<TASK>\n? __die+0x23/0x80\n? page_fault_oops+0xa4/0x180\n? exc_page_fault+0x152/0x180\n? asm_exc_page_fault+0x26/0x40\n? rcu_tasks_need_gpcb+0x25d/0x2c0\n? __pfx_rcu_tasks_kthread+0x40/0x40\nrcu_tasks_one_gp+0x69/0x180\nrcu_tasks_kthread+0x94/0xc0\nkthread+0xe8/0x140\n? __pfx_kthread+0x40/0x40\nret_from_fork+0x34/0x80\n? __pfx_kthread+0x40/0x40\nret_from_fork_asm+0x1b/0x80\n</TASK>\n\nConsidering that there may be holes in the CPU numbers, use the\nmaximum possible cpu number, instead of nr_cpu_ids, for configuring\nenqueue and dequeue limits.\n\n[ neeraj.upadhyay: Fix htmldocs build error reported by Stephen Rothwell ]"
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49918",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/4f47292f488fa7041284dca1f1244116c18721f1",
            "https://git.kernel.org/stable/c/96d4c2ee18d732a248d053aae8c4a27cb1d68d1c",
            "https://git.kernel.org/stable/c/ac2140449184a26eac99585b7f69814bd3ba8f2d"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Add null check for head_pipe in dcn32_acquire_idle_pipe_for_head_pipe_in_layer\n\nThis commit addresses a potential null pointer dereference issue in the\n`dcn32_acquire_idle_pipe_for_head_pipe_in_layer` function. The issue\ncould occur when `head_pipe` is null.\n\nThe fix adds a check to ensure `head_pipe` is not null before asserting\nit. If `head_pipe` is null, the function returns NULL to prevent a\npotential null pointer dereference.\n\nReported by smatch:\ndrivers/gpu/drm/amd/amdgpu/../display/dc/resource/dcn32/dcn32_resource.c:2690 dcn32_acquire_idle_pipe_for_head_pipe_in_layer() error: we previously assumed 'head_pipe' could be null (see line 2681)"
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49922",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/65e1d2c291553ef3f433a0b7109cc3002a5f40ae",
            "https://git.kernel.org/stable/c/5e9386baa3033c369564d55de4bab62423e8a1d3",
            "https://git.kernel.org/stable/c/1ff12bcd7deaeed25efb5120433c6a45dd5504a8"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Check null pointers before using them\n\n[WHAT & HOW]\nThese pointers are null checked previously in the same function,\nindicating they might be null as reported by Coverity. As a result,\nthey need to be checked when used again.\n\nThis fixes 3 FORWARD_NULL issue reported by Coverity."
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49935",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/92e5661b7d0727ab912b76625a88b33fdb9b609a",
            "https://git.kernel.org/stable/c/68a599da16ebad442ce295d8d2d5c488e3992822",
            "https://git.kernel.org/stable/c/68a8e45743d6a120f863fb14b72dc59616597019",
            "https://git.kernel.org/stable/c/03593dbb0b272ef7b0358b099841e65735422aca",
            "https://git.kernel.org/stable/c/27c045f868f0e5052c6b532868a65e0cd250c8fc",
            "https://git.kernel.org/stable/c/0a2ed70a549e61c5181bad5db418d223b68ae932"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nACPI: PAD: fix crash in exit_round_robin()\n\nThe kernel occasionally crashes in cpumask_clear_cpu(), which is called\nwithin exit_round_robin(), because when executing clear_bit(nr, addr) with\nnr set to 0xffffffff, the address calculation may cause misalignment within\nthe memory, leading to access to an invalid memory address.\n\n----------\nBUG: unable to handle kernel paging request at ffffffffe0740618\n        ...\nCPU: 3 PID: 2919323 Comm: acpi_pad/14 Kdump: loaded Tainted: G           OE  X --------- -  - 4.18.0-425.19.2.el8_7.x86_64 #1\n        ...\nRIP: 0010:power_saving_thread+0x313/0x411 [acpi_pad]\nCode: 89 cd 48 89 d3 eb d1 48 c7 c7 55 70 72 c0 e8 64 86 b0 e4 c6 05 0d a1 02 00 01 e9 bc fd ff ff 45 89 e4 42 8b 04 a5 20 82 72 c0 <f0> 48 0f b3 05 f4 9c 01 00 42 c7 04 a5 20 82 72 c0 ff ff ff ff 31\nRSP: 0018:ff72a5d51fa77ec8 EFLAGS: 00010202\nRAX: 00000000ffffffff RBX: ff462981e5d8cb80 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: 0000000000000246 RDI: 0000000000000246\nRBP: ff46297556959d80 R08: 0000000000000382 R09: ff46297c8d0f38d8\nR10: 0000000000000000 R11: 0000000000000001 R12: 000000000000000e\nR13: 0000000000000000 R14: ffffffffffffffff R15: 000000000000000e\nFS:  0000000000000000(0000) GS:ff46297a800c0000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: ffffffffe0740618 CR3: 0000007e20410004 CR4: 0000000000771ee0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nPKRU: 55555554\nCall Trace:\n ? acpi_pad_add+0x120/0x120 [acpi_pad]\n kthread+0x10b/0x130\n ? set_kthread_struct+0x50/0x50\n ret_from_fork+0x1f/0x40\n        ...\nCR2: ffffffffe0740618\n\ncrash> dis -lr ffffffffc0726923\n        ...\n/usr/src/debug/kernel-4.18.0-425.19.2.el8_7/linux-4.18.0-425.19.2.el8_7.x86_64/./include/linux/cpumask.h: 114\n0xffffffffc0726918 <power_saving_thread+776>:\tmov    %r12d,%r12d\n/usr/src/debug/kernel-4.18.0-425.19.2.el8_7/linux-4.18.0-425.19.2.el8_7.x86_64/./include/linux/cpumask.h: 325\n0xffffffffc072691b <power_saving_thread+779>:\tmov    -0x3f8d7de0(,%r12,4),%eax\n/usr/src/debug/kernel-4.18.0-425.19.2.el8_7/linux-4.18.0-425.19.2.el8_7.x86_64/./arch/x86/include/asm/bitops.h: 80\n0xffffffffc0726923 <power_saving_thread+787>:\tlock btr %rax,0x19cf4(%rip)        # 0xffffffffc0740620 <pad_busy_cpus_bits>\n\ncrash> px tsk_in_cpu[14]\n$66 = 0xffffffff\n\ncrash> px 0xffffffffc072692c+0x19cf4\n$99 = 0xffffffffc0740620\n\ncrash> sym 0xffffffffc0740620\nffffffffc0740620 (b) pad_busy_cpus_bits [acpi_pad]\n\ncrash> px pad_busy_cpus_bits[0]\n$42 = 0xfffc0\n----------\n\nTo fix this, ensure that tsk_in_cpu[tsk_index] != -1 before calling\ncpumask_clear_cpu() in exit_round_robin(), just as it is done in\nround_robin_cpu().\n\n[ rjw: Subject edit, avoid updates to the same value ]"
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49936",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/a7f0073fcd12ed7de185ef2c0af9d0fa1ddef22c",
            "https://git.kernel.org/stable/c/a0465723b8581cad27164c9073fd780904cd22d4",
            "https://git.kernel.org/stable/c/efcff6ce7467f01f0753609f420333f3f2ceceda",
            "https://git.kernel.org/stable/c/143edf098b80669d05245b2f2367dd156a83a2c5",
            "https://git.kernel.org/stable/c/d408889d4b54f5501e4becc4dbbb9065143fbf4e",
            "https://git.kernel.org/stable/c/54d8639af5568fc41c0e274fc3ec9cf86c59fcbb",
            "https://git.kernel.org/stable/c/0fa5e94a1811d68fbffa0725efe6d4ca62c03d12"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/xen-netback: prevent UAF in xenvif_flush_hash()\n\nDuring the list_for_each_entry_rcu iteration call of xenvif_flush_hash,\nkfree_rcu does not exist inside the rcu read critical section, so if\nkfree_rcu is called when the rcu grace period ends during the iteration,\nUAF occurs when accessing head->next after the entry becomes free.\n\nTherefore, to solve this, you need to change it to list_for_each_entry_safe."
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49937",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/95f32191e50b75e0f75fae1bb925cdf51d8df0a3",
            "https://git.kernel.org/stable/c/04053e55dd50741cf6c59b9bbaa4238218c05c70",
            "https://git.kernel.org/stable/c/f4dbfda159e43d49b43003cc3c2914751939035f",
            "https://git.kernel.org/stable/c/c628026563f4ea9e0413dd4b69429e4a1db240b1",
            "https://git.kernel.org/stable/c/20361712880396e44ce80aaeec2d93d182035651"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: cfg80211: Set correct chandef when starting CAC\n\nWhen starting CAC in a mode other than AP mode, it return a\n\"WARNING: CPU: 0 PID: 63 at cfg80211_chandef_dfs_usable+0x20/0xaf [cfg80211]\"\ncaused by the chandef.chan being null at the end of CAC.\n\nSolution: Ensure the channel definition is set for the different modes\nwhen starting CAC to avoid getting a NULL 'chan' at the end of CAC.\n\n Call Trace:\n  ? show_regs.part.0+0x14/0x16\n  ? __warn+0x67/0xc0\n  ? cfg80211_chandef_dfs_usable+0x20/0xaf [cfg80211]\n  ? report_bug+0xa7/0x130\n  ? exc_overflow+0x30/0x30\n  ? handle_bug+0x27/0x50\n  ? exc_invalid_op+0x18/0x60\n  ? handle_exception+0xf6/0xf6\n  ? exc_overflow+0x30/0x30\n  ? cfg80211_chandef_dfs_usable+0x20/0xaf [cfg80211]\n  ? exc_overflow+0x30/0x30\n  ? cfg80211_chandef_dfs_usable+0x20/0xaf [cfg80211]\n  ? regulatory_propagate_dfs_state.cold+0x1b/0x4c [cfg80211]\n  ? cfg80211_propagate_cac_done_wk+0x1a/0x30 [cfg80211]\n  ? process_one_work+0x165/0x280\n  ? worker_thread+0x120/0x3f0\n  ? kthread+0xc2/0xf0\n  ? process_one_work+0x280/0x280\n  ? kthread_complete_and_exit+0x20/0x20\n  ? ret_from_fork+0x19/0x24\n\n[shorten subject, remove OCB, reorder cases to match previous list]"
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49938",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/b02eb7c86ff2ef1411c3095ec8a52b13f68db04f",
            "https://git.kernel.org/stable/c/012ae530afa0785102360de452745d33c99a321b",
            "https://git.kernel.org/stable/c/6a875220670475d9247e576c15dc29823100a4e4",
            "https://git.kernel.org/stable/c/e37e348835032d6940ec89308cc8996ded691d2d",
            "https://git.kernel.org/stable/c/2c230210ec0ae6ed08306ac70dc21c24b817bb95",
            "https://git.kernel.org/stable/c/a9f4e28e8adaf0715bd4e01462af0a52ee46b01f",
            "https://git.kernel.org/stable/c/94745807f3ebd379f23865e6dab196f220664179"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: ath9k_htc: Use __skb_set_length() for resetting urb before resubmit\n\nSyzbot points out that skb_trim() has a sanity check on the existing length of\nthe skb, which can be uninitialised in some error paths. The intent here is\nclearly just to reset the length to zero before resubmitting, so switch to\ncalling __skb_set_length(skb, 0) directly. In addition, __skb_set_length()\nalready contains a call to skb_reset_tail_pointer(), so remove the redundant\ncall.\n\nThe syzbot report came from ath9k_hif_usb_reg_in_cb(), but there's a similar\nusage of skb_trim() in ath9k_hif_usb_rx_cb(), change both while we're at it."
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49932",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/f7a1218a983ab98aba140dc20b25f60b39ee4033",
            "https://git.kernel.org/stable/c/04915240e2c3a018e4c7f23418478d27226c8957"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: don't readahead the relocation inode on RST\n\nOn relocation we're doing readahead on the relocation inode, but if the\nfilesystem is backed by a RAID stripe tree we can get ENOENT (e.g. due to\npreallocated extents not being mapped in the RST) from the lookup.\n\nBut readahead doesn't handle the error and submits invalid reads to the\ndevice, causing an assertion in the scatter-gather list code:\n\n  BTRFS info (device nvme1n1): balance: start -d -m -s\n  BTRFS info (device nvme1n1): relocating block group 6480920576 flags data|raid0\n  BTRFS error (device nvme1n1): cannot find raid-stripe for logical [6481928192, 6481969152] devid 2, profile raid0\n  ------------[ cut here ]------------\n  kernel BUG at include/linux/scatterlist.h:115!\n  Oops: invalid opcode: 0000 [#1] PREEMPT SMP PTI\n  CPU: 0 PID: 1012 Comm: btrfs Not tainted 6.10.0-rc7+ #567\n  RIP: 0010:__blk_rq_map_sg+0x339/0x4a0\n  RSP: 0018:ffffc90001a43820 EFLAGS: 00010202\n  RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffea00045d4802\n  RDX: 0000000117520000 RSI: 0000000000000000 RDI: ffff8881027d1000\n  RBP: 0000000000003000 R08: ffffea00045d4902 R09: 0000000000000000\n  R10: 0000000000000000 R11: 0000000000001000 R12: ffff8881003d10b8\n  R13: ffffc90001a438f0 R14: 0000000000000000 R15: 0000000000003000\n  FS:  00007fcc048a6900(0000) GS:ffff88813bc00000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 000000002cd11000 CR3: 00000001109ea001 CR4: 0000000000370eb0\n  Call Trace:\n   <TASK>\n   ? __die_body.cold+0x14/0x25\n   ? die+0x2e/0x50\n   ? do_trap+0xca/0x110\n   ? do_error_trap+0x65/0x80\n   ? __blk_rq_map_sg+0x339/0x4a0\n   ? exc_invalid_op+0x50/0x70\n   ? __blk_rq_map_sg+0x339/0x4a0\n   ? asm_exc_invalid_op+0x1a/0x20\n   ? __blk_rq_map_sg+0x339/0x4a0\n   nvme_prep_rq.part.0+0x9d/0x770\n   nvme_queue_rq+0x7d/0x1e0\n   __blk_mq_issue_directly+0x2a/0x90\n   ? blk_mq_get_budget_and_tag+0x61/0x90\n   blk_mq_try_issue_list_directly+0x56/0xf0\n   blk_mq_flush_plug_list.part.0+0x52b/0x5d0\n   __blk_flush_plug+0xc6/0x110\n   blk_finish_plug+0x28/0x40\n   read_pages+0x160/0x1c0\n   page_cache_ra_unbounded+0x109/0x180\n   relocate_file_extent_cluster+0x611/0x6a0\n   ? btrfs_search_slot+0xba4/0xd20\n   ? balance_dirty_pages_ratelimited_flags+0x26/0xb00\n   relocate_data_extent.constprop.0+0x134/0x160\n   relocate_block_group+0x3f2/0x500\n   btrfs_relocate_block_group+0x250/0x430\n   btrfs_relocate_chunk+0x3f/0x130\n   btrfs_balance+0x71b/0xef0\n   ? kmalloc_trace_noprof+0x13b/0x280\n   btrfs_ioctl+0x2c2e/0x3030\n   ? kvfree_call_rcu+0x1e6/0x340\n   ? list_lru_add_obj+0x66/0x80\n   ? mntput_no_expire+0x3a/0x220\n   __x64_sys_ioctl+0x96/0xc0\n   do_syscall_64+0x54/0x110\n   entry_SYSCALL_64_after_hwframe+0x76/0x7e\n  RIP: 0033:0x7fcc04514f9b\n  Code: Unable to access opcode bytes at 0x7fcc04514f71.\n  RSP: 002b:00007ffeba923370 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\n  RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 00007fcc04514f9b\n  RDX: 00007ffeba923460 RSI: 00000000c4009420 RDI: 0000000000000003\n  RBP: 0000000000000000 R08: 0000000000000013 R09: 0000000000000001\n  R10: 00007fcc043fbba8 R11: 0000000000000246 R12: 00007ffeba924fc5\n  R13: 00007ffeba923460 R14: 0000000000000002 R15: 00000000004d4bb0\n   </TASK>\n  Modules linked in:\n  ---[ end trace 0000000000000000 ]---\n  RIP: 0010:__blk_rq_map_sg+0x339/0x4a0\n  RSP: 0018:ffffc90001a43820 EFLAGS: 00010202\n  RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffea00045d4802\n  RDX: 0000000117520000 RSI: 0000000000000000 RDI: ffff8881027d1000\n  RBP: 0000000000003000 R08: ffffea00045d4902 R09: 0000000000000000\n  R10: 0000000000000000 R11: 0000000000001000 R12: ffff8881003d10b8\n  R13: ffffc90001a438f0 R14: 0000000000000000 R15: 0000000000003000\n  FS:  00007fcc048a6900(0000) GS:ffff88813bc00000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 00007fcc04514f71 CR3: 00000001109ea001 CR4: 0000000000370eb0\n  Kernel p\n---truncated---"
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49941",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/9ee4b907d7a5d7a53b4ff7727c371ff3d44ccbbb",
            "https://git.kernel.org/stable/c/7b99b5ab885993bff010ebcd93be5e511c56e28a"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ngpiolib: Fix potential NULL pointer dereference in gpiod_get_label()\n\nIn `gpiod_get_label()`, it is possible that `srcu_dereference_check()` may\nreturn a NULL pointer, leading to a scenario where `label->str` is accessed\nwithout verifying if `label` itself is NULL.\n\nThis patch adds a proper NULL check for `label` before accessing\n`label->str`. The check for `label->str != NULL` is removed because\n`label->str` can never be NULL if `label` is not NULL.\n\nThis fixes the issue where the label name was being printed as `(efault)`\nwhen dumping the sysfs GPIO file when `label == NULL`."
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49865",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/09cf8901fc0225898311b375cfcc67bae37ed5da",
            "https://git.kernel.org/stable/c/74231870cf4976f69e83aa24f48edb16619f652f"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/xe/vm: move xa_alloc to prevent UAF\n\nEvil user can guess the next id of the vm before the ioctl completes and\nthen call vm destroy ioctl to trigger UAF since create ioctl is still\nreferencing the same vm. Move the xa_alloc all the way to the end to\nprevent this.\n\nv2:\n - Rebase\n\n(cherry picked from commit dcfd3971327f3ee92765154baebbaece833d3ca9)"
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49942",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/16e0267db156f8a4ea16bfb3ac3f5743c9698df3",
            "https://git.kernel.org/stable/c/8f5199b6971f0717c2d31685953971fa2e1b9e1a",
            "https://git.kernel.org/stable/c/7257d9c9a3c6cfe26c428e9b7ae21d61f2f55a79"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/xe: Prevent null pointer access in xe_migrate_copy\n\nxe_migrate_copy designed to copy content of TTM resources. When source\nresource is null, it will trigger a NULL pointer dereference in\nxe_migrate_copy. To avoid this situation, update lacks source flag to\ntrue for this case, the flag will trigger xe_migrate_clear rather than\nxe_migrate_copy.\n\nIssue trace:\n<7> [317.089847] xe 0000:00:02.0: [drm:xe_migrate_copy [xe]] Pass 14,\n sizes: 4194304 & 4194304\n<7> [317.089945] xe 0000:00:02.0: [drm:xe_migrate_copy [xe]] Pass 15,\n sizes: 4194304 & 4194304\n<1> [317.128055] BUG: kernel NULL pointer dereference, address:\n 0000000000000010\n<1> [317.128064] #PF: supervisor read access in kernel mode\n<1> [317.128066] #PF: error_code(0x0000) - not-present page\n<6> [317.128069] PGD 0 P4D 0\n<4> [317.128071] Oops: Oops: 0000 [#1] PREEMPT SMP NOPTI\n<4> [317.128074] CPU: 1 UID: 0 PID: 1440 Comm: kunit_try_catch Tainted:\n G     U           N 6.11.0-rc7-xe #1\n<4> [317.128078] Tainted: [U]=USER, [N]=TEST\n<4> [317.128080] Hardware name: Intel Corporation Lunar Lake Client\n Platform/LNL-M LP5 RVP1, BIOS LNLMFWI1.R00.3221.D80.2407291239 07/29/2024\n<4> [317.128082] RIP: 0010:xe_migrate_copy+0x66/0x13e0 [xe]\n<4> [317.128158] Code: 00 00 48 89 8d e0 fe ff ff 48 8b 40 10 4c 89 85 c8\n fe ff ff 44 88 8d bd fe ff ff 65 48 8b 3c 25 28 00 00 00 48 89 7d d0 31\n ff <8b> 79 10 48 89 85 a0 fe ff ff 48 8b 00 48 89 b5 d8 fe ff ff 83 ff\n<4> [317.128162] RSP: 0018:ffffc9000167f9f0 EFLAGS: 00010246\n<4> [317.128164] RAX: ffff8881120d8028 RBX: ffff88814d070428 RCX:\n 0000000000000000\n<4> [317.128166] RDX: ffff88813cb99c00 RSI: 0000000004000000 RDI:\n 0000000000000000\n<4> [317.128168] RBP: ffffc9000167fbb8 R08: ffff88814e7b1f08 R09:\n 0000000000000001\n<4> [317.128170] R10: 0000000000000001 R11: 0000000000000001 R12:\n ffff88814e7b1f08\n<4> [317.128172] R13: ffff88814e7b1f08 R14: ffff88813cb99c00 R15:\n 0000000000000001\n<4> [317.128174] FS:  0000000000000000(0000) GS:ffff88846f280000(0000)\n knlGS:0000000000000000\n<4> [317.128176] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n<4> [317.128178] CR2: 0000000000000010 CR3: 000000011f676004 CR4:\n 0000000000770ef0\n<4> [317.128180] DR0: 0000000000000000 DR1: 0000000000000000 DR2:\n 0000000000000000\n<4> [317.128182] DR3: 0000000000000000 DR6: 00000000ffff07f0 DR7:\n 0000000000000400\n<4> [317.128184] PKRU: 55555554\n<4> [317.128185] Call Trace:\n<4> [317.128187]  <TASK>\n<4> [317.128189]  ? show_regs+0x67/0x70\n<4> [317.128194]  ? __die_body+0x20/0x70\n<4> [317.128196]  ? __die+0x2b/0x40\n<4> [317.128198]  ? page_fault_oops+0x15f/0x4e0\n<4> [317.128203]  ? do_user_addr_fault+0x3fb/0x970\n<4> [317.128205]  ? lock_acquire+0xc7/0x2e0\n<4> [317.128209]  ? exc_page_fault+0x87/0x2b0\n<4> [317.128212]  ? asm_exc_page_fault+0x27/0x30\n<4> [317.128216]  ? xe_migrate_copy+0x66/0x13e0 [xe]\n<4> [317.128263]  ? __lock_acquire+0xb9d/0x26f0\n<4> [317.128265]  ? __lock_acquire+0xb9d/0x26f0\n<4> [317.128267]  ? sg_free_append_table+0x20/0x80\n<4> [317.128271]  ? lock_acquire+0xc7/0x2e0\n<4> [317.128273]  ? mark_held_locks+0x4d/0x80\n<4> [317.128275]  ? trace_hardirqs_on+0x1e/0xd0\n<4> [317.128278]  ? _raw_spin_unlock_irqrestore+0x31/0x60\n<4> [317.128281]  ? __pm_runtime_resume+0x60/0xa0\n<4> [317.128284]  xe_bo_move+0x682/0xc50 [xe]\n<4> [317.128315]  ? lock_is_held_type+0xaa/0x120\n<4> [317.128318]  ttm_bo_handle_move_mem+0xe5/0x1a0 [ttm]\n<4> [317.128324]  ttm_bo_validate+0xd1/0x1a0 [ttm]\n<4> [317.128328]  shrink_test_run_device+0x721/0xc10 [xe]\n<4> [317.128360]  ? find_held_lock+0x31/0x90\n<4> [317.128363]  ? lock_release+0xd1/0x2a0\n<4> [317.128365]  ? __pfx_kunit_generic_run_threadfn_adapter+0x10/0x10\n [kunit]\n<4> [317.128370]  xe_bo_shrink_kunit+0x11/0x20 [xe]\n<4> [317.128397]  kunit_try_run_case+0x6e/0x150 [kunit]\n<4> [317.128400]  ? trace_hardirqs_on+0x1e/0xd0\n<4> [317.128402]  ? _raw_spin_unlock_irqrestore+0x31/0x60\n<4> [317.128404]  kunit_generic_run_threadfn_adapter+0x1e/0x40 [ku\n---truncated---"
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49942",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/16e0267db156f8a4ea16bfb3ac3f5743c9698df3",
            "https://git.kernel.org/stable/c/8f5199b6971f0717c2d31685953971fa2e1b9e1a",
            "https://git.kernel.org/stable/c/7257d9c9a3c6cfe26c428e9b7ae21d61f2f55a79"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/xe: Prevent null pointer access in xe_migrate_copy\n\nxe_migrate_copy designed to copy content of TTM resources. When source\nresource is null, it will trigger a NULL pointer dereference in\nxe_migrate_copy. To avoid this situation, update lacks source flag to\ntrue for this case, the flag will trigger xe_migrate_clear rather than\nxe_migrate_copy.\n\nIssue trace:\n<7> [317.089847] xe 0000:00:02.0: [drm:xe_migrate_copy [xe]] Pass 14,\n sizes: 4194304 & 4194304\n<7> [317.089945] xe 0000:00:02.0: [drm:xe_migrate_copy [xe]] Pass 15,\n sizes: 4194304 & 4194304\n<1> [317.128055] BUG: kernel NULL pointer dereference, address:\n 0000000000000010\n<1> [317.128064] #PF: supervisor read access in kernel mode\n<1> [317.128066] #PF: error_code(0x0000) - not-present page\n<6> [317.128069] PGD 0 P4D 0\n<4> [317.128071] Oops: Oops: 0000 [#1] PREEMPT SMP NOPTI\n<4> [317.128074] CPU: 1 UID: 0 PID: 1440 Comm: kunit_try_catch Tainted:\n G     U           N 6.11.0-rc7-xe #1\n<4> [317.128078] Tainted: [U]=USER, [N]=TEST\n<4> [317.128080] Hardware name: Intel Corporation Lunar Lake Client\n Platform/LNL-M LP5 RVP1, BIOS LNLMFWI1.R00.3221.D80.2407291239 07/29/2024\n<4> [317.128082] RIP: 0010:xe_migrate_copy+0x66/0x13e0 [xe]\n<4> [317.128158] Code: 00 00 48 89 8d e0 fe ff ff 48 8b 40 10 4c 89 85 c8\n fe ff ff 44 88 8d bd fe ff ff 65 48 8b 3c 25 28 00 00 00 48 89 7d d0 31\n ff <8b> 79 10 48 89 85 a0 fe ff ff 48 8b 00 48 89 b5 d8 fe ff ff 83 ff\n<4> [317.128162] RSP: 0018:ffffc9000167f9f0 EFLAGS: 00010246\n<4> [317.128164] RAX: ffff8881120d8028 RBX: ffff88814d070428 RCX:\n 0000000000000000\n<4> [317.128166] RDX: ffff88813cb99c00 RSI: 0000000004000000 RDI:\n 0000000000000000\n<4> [317.128168] RBP: ffffc9000167fbb8 R08: ffff88814e7b1f08 R09:\n 0000000000000001\n<4> [317.128170] R10: 0000000000000001 R11: 0000000000000001 R12:\n ffff88814e7b1f08\n<4> [317.128172] R13: ffff88814e7b1f08 R14: ffff88813cb99c00 R15:\n 0000000000000001\n<4> [317.128174] FS:  0000000000000000(0000) GS:ffff88846f280000(0000)\n knlGS:0000000000000000\n<4> [317.128176] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n<4> [317.128178] CR2: 0000000000000010 CR3: 000000011f676004 CR4:\n 0000000000770ef0\n<4> [317.128180] DR0: 0000000000000000 DR1: 0000000000000000 DR2:\n 0000000000000000\n<4> [317.128182] DR3: 0000000000000000 DR6: 00000000ffff07f0 DR7:\n 0000000000000400\n<4> [317.128184] PKRU: 55555554\n<4> [317.128185] Call Trace:\n<4> [317.128187]  <TASK>\n<4> [317.128189]  ? show_regs+0x67/0x70\n<4> [317.128194]  ? __die_body+0x20/0x70\n<4> [317.128196]  ? __die+0x2b/0x40\n<4> [317.128198]  ? page_fault_oops+0x15f/0x4e0\n<4> [317.128203]  ? do_user_addr_fault+0x3fb/0x970\n<4> [317.128205]  ? lock_acquire+0xc7/0x2e0\n<4> [317.128209]  ? exc_page_fault+0x87/0x2b0\n<4> [317.128212]  ? asm_exc_page_fault+0x27/0x30\n<4> [317.128216]  ? xe_migrate_copy+0x66/0x13e0 [xe]\n<4> [317.128263]  ? __lock_acquire+0xb9d/0x26f0\n<4> [317.128265]  ? __lock_acquire+0xb9d/0x26f0\n<4> [317.128267]  ? sg_free_append_table+0x20/0x80\n<4> [317.128271]  ? lock_acquire+0xc7/0x2e0\n<4> [317.128273]  ? mark_held_locks+0x4d/0x80\n<4> [317.128275]  ? trace_hardirqs_on+0x1e/0xd0\n<4> [317.128278]  ? _raw_spin_unlock_irqrestore+0x31/0x60\n<4> [317.128281]  ? __pm_runtime_resume+0x60/0xa0\n<4> [317.128284]  xe_bo_move+0x682/0xc50 [xe]\n<4> [317.128315]  ? lock_is_held_type+0xaa/0x120\n<4> [317.128318]  ttm_bo_handle_move_mem+0xe5/0x1a0 [ttm]\n<4> [317.128324]  ttm_bo_validate+0xd1/0x1a0 [ttm]\n<4> [317.128328]  shrink_test_run_device+0x721/0xc10 [xe]\n<4> [317.128360]  ? find_held_lock+0x31/0x90\n<4> [317.128363]  ? lock_release+0xd1/0x2a0\n<4> [317.128365]  ? __pfx_kunit_generic_run_threadfn_adapter+0x10/0x10\n [kunit]\n<4> [317.128370]  xe_bo_shrink_kunit+0x11/0x20 [xe]\n<4> [317.128397]  kunit_try_run_case+0x6e/0x150 [kunit]\n<4> [317.128400]  ? trace_hardirqs_on+0x1e/0xd0\n<4> [317.128402]  ? _raw_spin_unlock_irqrestore+0x31/0x60\n<4> [317.128404]  kunit_generic_run_threadfn_adapter+0x1e/0x40 [ku\n---truncated---"
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49943",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/d88f9bab7e62dd0dbe983fa70cf040042a60cc84",
            "https://git.kernel.org/stable/c/790533e44bfc7af929842fccd9674c9f424d4627"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/xe/guc_submit: add missing locking in wedged_fini\n\nAny non-wedged queue can have a zero refcount here and can be running\nconcurrently with an async queue destroy, therefore dereferencing the\nqueue ptr to check wedge status after the lookup can trigger UAF if\nqueue is not wedged.  Fix this by keeping the submission_state lock held\naround the check to postpone the free and make the check safe, before\ndropping again around the put() to avoid the deadlock.\n\n(cherry picked from commit d28af0b6b9580b9f90c265a7da0315b0ad20bbfd)"
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49943",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/d88f9bab7e62dd0dbe983fa70cf040042a60cc84",
            "https://git.kernel.org/stable/c/790533e44bfc7af929842fccd9674c9f424d4627"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/xe/guc_submit: add missing locking in wedged_fini\n\nAny non-wedged queue can have a zero refcount here and can be running\nconcurrently with an async queue destroy, therefore dereferencing the\nqueue ptr to check wedge status after the lookup can trigger UAF if\nqueue is not wedged.  Fix this by keeping the submission_state lock held\naround the check to postpone the free and make the check safe, before\ndropping again around the put() to avoid the deadlock.\n\n(cherry picked from commit d28af0b6b9580b9f90c265a7da0315b0ad20bbfd)"
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49944",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/dd70c8a89ef99c3d53127fe19e51ef47c3f860fa",
            "https://git.kernel.org/stable/c/e7a8442195e8ebd97df467ce4742980ab57edcce",
            "https://git.kernel.org/stable/c/9230a59eda0878d7ecaa901d876aec76f57bd455",
            "https://git.kernel.org/stable/c/7f64cb5b4d8c872296eda0fdce3bcf099eec7aa7",
            "https://git.kernel.org/stable/c/f032e1dac30b3376c7d6026fb01a8c403c47a80d",
            "https://git.kernel.org/stable/c/e914bf68dab88815a7ae7b7a3a5e8913c8ff14a5",
            "https://git.kernel.org/stable/c/8beee4d8dee76b67c75dc91fd8185d91e845c160"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nsctp: set sk_state back to CLOSED if autobind fails in sctp_listen_start\n\nIn sctp_listen_start() invoked by sctp_inet_listen(), it should set the\nsk_state back to CLOSED if sctp_autobind() fails due to whatever reason.\n\nOtherwise, next time when calling sctp_inet_listen(), if sctp_sk(sk)->reuse\nis already set via setsockopt(SCTP_REUSE_PORT), sctp_sk(sk)->bind_hash will\nbe dereferenced as sk_state is LISTENING, which causes a crash as bind_hash\nis NULL.\n\n  KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]\n  RIP: 0010:sctp_inet_listen+0x7f0/0xa20 net/sctp/socket.c:8617\n  Call Trace:\n   <TASK>\n   __sys_listen_socket net/socket.c:1883 [inline]\n   __sys_listen+0x1b7/0x230 net/socket.c:1894\n   __do_sys_listen net/socket.c:1902 [inline]"
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49863",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/6592347f06e2b19a624270a85ad4b3ae48c3b241",
            "https://git.kernel.org/stable/c/46128370a72c431df733af5ebb065c4d48c9ad39",
            "https://git.kernel.org/stable/c/ace9c778a214da9c98d7b69d904d1b0816f4f681",
            "https://git.kernel.org/stable/c/25613e6d9841a1f9fb985be90df921fa99f800de",
            "https://git.kernel.org/stable/c/00fb5b23e1c9cdbe496f5cd6b40367cb895f6c93",
            "https://git.kernel.org/stable/c/61517f33e76d2c5247c1e61e668693afe5b67e6f",
            "https://git.kernel.org/stable/c/221af82f606d928ccef19a16d35633c63026f1be"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nvhost/scsi: null-ptr-dereference in vhost_scsi_get_req()\n\nSince commit 3f8ca2e115e5 (\"vhost/scsi: Extract common handling code\nfrom control queue handler\") a null pointer dereference bug can be\ntriggered when guest sends an SCSI AN request.\n\nIn vhost_scsi_ctl_handle_vq(), `vc.target` is assigned with\n`&v_req.tmf.lun[1]` within a switch-case block and is then passed to\nvhost_scsi_get_req() which extracts `vc->req` and `tpg`. However, for\na `VIRTIO_SCSI_T_AN_*` request, tpg is not required, so `vc.target` is\nset to NULL in this branch. Later, in vhost_scsi_get_req(),\n`vc->target` is dereferenced without being checked, leading to a null\npointer dereference bug. This bug can be triggered from guest.\n\nWhen this bug occurs, the vhost_worker process is killed while holding\n`vq->mutex` and the corresponding tpg will remain occupied\nindefinitely.\n\nBelow is the KASAN report:\nOops: general protection fault, probably for non-canonical address\n0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN NOPTI\nKASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]\nCPU: 1 PID: 840 Comm: poc Not tainted 6.10.0+ #1\nHardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS\n1.16.3-debian-1.16.3-2 04/01/2014\nRIP: 0010:vhost_scsi_get_req+0x165/0x3a0\nCode: 00 fc ff df 48 89 fa 48 c1 ea 03 80 3c 02 00 0f 85 2b 02 00 00\n48 b8 00 00 00 00 00 fc ff df 4d 8b 65 30 4c 89 e2 48 c1 ea 03 <0f> b6\n04 02 4c 89 e2 83 e2 07 38 d0 7f 08 84 c0 0f 85 be 01 00 00\nRSP: 0018:ffff888017affb50 EFLAGS: 00010246\nRAX: dffffc0000000000 RBX: ffff88801b000000 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff888017affcb8\nRBP: ffff888017affb80 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000\nR13: ffff888017affc88 R14: ffff888017affd1c R15: ffff888017993000\nFS:  000055556e076500(0000) GS:ffff88806b100000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00000000200027c0 CR3: 0000000010ed0004 CR4: 0000000000370ef0\nCall Trace:\n <TASK>\n ? show_regs+0x86/0xa0\n ? die_addr+0x4b/0xd0\n ? exc_general_protection+0x163/0x260\n ? asm_exc_general_protection+0x27/0x30\n ? vhost_scsi_get_req+0x165/0x3a0\n vhost_scsi_ctl_handle_vq+0x2a4/0xca0\n ? __pfx_vhost_scsi_ctl_handle_vq+0x10/0x10\n ? __switch_to+0x721/0xeb0\n ? __schedule+0xda5/0x5710\n ? __kasan_check_write+0x14/0x30\n ? _raw_spin_lock+0x82/0xf0\n vhost_scsi_ctl_handle_kick+0x52/0x90\n vhost_run_work_list+0x134/0x1b0\n vhost_task_fn+0x121/0x350\n...\n </TASK>\n---[ end trace 0000000000000000 ]---\n\nLet's add a check in vhost_scsi_get_req.\n\n[whitespace fixes]"
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49944",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/dd70c8a89ef99c3d53127fe19e51ef47c3f860fa",
            "https://git.kernel.org/stable/c/e7a8442195e8ebd97df467ce4742980ab57edcce",
            "https://git.kernel.org/stable/c/9230a59eda0878d7ecaa901d876aec76f57bd455",
            "https://git.kernel.org/stable/c/7f64cb5b4d8c872296eda0fdce3bcf099eec7aa7",
            "https://git.kernel.org/stable/c/f032e1dac30b3376c7d6026fb01a8c403c47a80d",
            "https://git.kernel.org/stable/c/e914bf68dab88815a7ae7b7a3a5e8913c8ff14a5",
            "https://git.kernel.org/stable/c/8beee4d8dee76b67c75dc91fd8185d91e845c160"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nsctp: set sk_state back to CLOSED if autobind fails in sctp_listen_start\n\nIn sctp_listen_start() invoked by sctp_inet_listen(), it should set the\nsk_state back to CLOSED if sctp_autobind() fails due to whatever reason.\n\nOtherwise, next time when calling sctp_inet_listen(), if sctp_sk(sk)->reuse\nis already set via setsockopt(SCTP_REUSE_PORT), sctp_sk(sk)->bind_hash will\nbe dereferenced as sk_state is LISTENING, which causes a crash as bind_hash\nis NULL.\n\n  KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]\n  RIP: 0010:sctp_inet_listen+0x7f0/0xa20 net/sctp/socket.c:8617\n  Call Trace:\n   <TASK>\n   __sys_listen_socket net/socket.c:1883 [inline]\n   __sys_listen+0x1b7/0x230 net/socket.c:1894\n   __do_sys_listen net/socket.c:1902 [inline]"
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49946",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/176dd41e8c2bd997ed3d66568a3362e69ecce99b",
            "https://git.kernel.org/stable/c/635deca1800a68624f185dc1e04a8495b48cf185",
            "https://git.kernel.org/stable/c/f9620e2a665aa642625bd2501282bbddff556bd7",
            "https://git.kernel.org/stable/c/efe9cc0f7c0279216a5522271ec675b8288602e4",
            "https://git.kernel.org/stable/c/c837f8583535f094a39386308c2ccfd92c8596cd",
            "https://git.kernel.org/stable/c/aec7291003df78cb71fd461d7b672912bde55807"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nppp: do not assume bh is held in ppp_channel_bridge_input()\n\nNetworking receive path is usually handled from BH handler.\nHowever, some protocols need to acquire the socket lock, and\npackets might be stored in the socket backlog is the socket was\nowned by a user process.\n\nIn this case, release_sock(), __release_sock(), and sk_backlog_rcv()\nmight call the sk->sk_backlog_rcv() handler in process context.\n\nsybot caught ppp was not considering this case in\nppp_channel_bridge_input() :\n\nWARNING: inconsistent lock state\n6.11.0-rc7-syzkaller-g5f5673607153 #0 Not tainted\n--------------------------------\ninconsistent {SOFTIRQ-ON-W} -> {IN-SOFTIRQ-W} usage.\nksoftirqd/1/24 [HC0[0]:SC1[1]:HE1:SE0] takes:\n ffff0000db7f11e0 (&pch->downl){+.?.}-{2:2}, at: spin_lock include/linux/spinlock.h:351 [inline]\n ffff0000db7f11e0 (&pch->downl){+.?.}-{2:2}, at: ppp_channel_bridge_input drivers/net/ppp/ppp_generic.c:2272 [inline]\n ffff0000db7f11e0 (&pch->downl){+.?.}-{2:2}, at: ppp_input+0x16c/0x854 drivers/net/ppp/ppp_generic.c:2304\n{SOFTIRQ-ON-W} state was registered at:\n   lock_acquire+0x240/0x728 kernel/locking/lockdep.c:5759\n   __raw_spin_lock include/linux/spinlock_api_smp.h:133 [inline]\n   _raw_spin_lock+0x48/0x60 kernel/locking/spinlock.c:154\n   spin_lock include/linux/spinlock.h:351 [inline]\n   ppp_channel_bridge_input drivers/net/ppp/ppp_generic.c:2272 [inline]\n   ppp_input+0x16c/0x854 drivers/net/ppp/ppp_generic.c:2304\n   pppoe_rcv_core+0xfc/0x314 drivers/net/ppp/pppoe.c:379\n   sk_backlog_rcv include/net/sock.h:1111 [inline]\n   __release_sock+0x1a8/0x3d8 net/core/sock.c:3004\n   release_sock+0x68/0x1b8 net/core/sock.c:3558\n   pppoe_sendmsg+0xc8/0x5d8 drivers/net/ppp/pppoe.c:903\n   sock_sendmsg_nosec net/socket.c:730 [inline]\n   __sock_sendmsg net/socket.c:745 [inline]\n   __sys_sendto+0x374/0x4f4 net/socket.c:2204\n   __do_sys_sendto net/socket.c:2216 [inline]\n   __se_sys_sendto net/socket.c:2212 [inline]\n   __arm64_sys_sendto+0xd8/0xf8 net/socket.c:2212\n   __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline]\n   invoke_syscall+0x98/0x2b8 arch/arm64/kernel/syscall.c:49\n   el0_svc_common+0x130/0x23c arch/arm64/kernel/syscall.c:132\n   do_el0_svc+0x48/0x58 arch/arm64/kernel/syscall.c:151\n   el0_svc+0x54/0x168 arch/arm64/kernel/entry-common.c:712\n   el0t_64_sync_handler+0x84/0xfc arch/arm64/kernel/entry-common.c:730\n   el0t_64_sync+0x190/0x194 arch/arm64/kernel/entry.S:598\nirq event stamp: 282914\n hardirqs last  enabled at (282914): [<ffff80008b42e30c>] __raw_spin_unlock_irqrestore include/linux/spinlock_api_smp.h:151 [inline]\n hardirqs last  enabled at (282914): [<ffff80008b42e30c>] _raw_spin_unlock_irqrestore+0x38/0x98 kernel/locking/spinlock.c:194\n hardirqs last disabled at (282913): [<ffff80008b42e13c>] __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:108 [inline]\n hardirqs last disabled at (282913): [<ffff80008b42e13c>] _raw_spin_lock_irqsave+0x2c/0x7c kernel/locking/spinlock.c:162\n softirqs last  enabled at (282904): [<ffff8000801f8e88>] softirq_handle_end kernel/softirq.c:400 [inline]\n softirqs last  enabled at (282904): [<ffff8000801f8e88>] handle_softirqs+0xa3c/0xbfc kernel/softirq.c:582\n softirqs last disabled at (282909): [<ffff8000801fbdf8>] run_ksoftirqd+0x70/0x158 kernel/softirq.c:928\n\nother info that might help us debug this:\n Possible unsafe locking scenario:\n\n       CPU0\n       ----\n  lock(&pch->downl);\n  <Interrupt>\n    lock(&pch->downl);\n\n *** DEADLOCK ***\n\n1 lock held by ksoftirqd/1/24:\n  #0: ffff80008f74dfa0 (rcu_read_lock){....}-{1:2}, at: rcu_lock_acquire+0x10/0x4c include/linux/rcupdate.h:325\n\nstack backtrace:\nCPU: 1 UID: 0 PID: 24 Comm: ksoftirqd/1 Not tainted 6.11.0-rc7-syzkaller-g5f5673607153 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/06/2024\nCall trace:\n  dump_backtrace+0x1b8/0x1e4 arch/arm64/kernel/stacktrace.c:319\n  show_stack+0x2c/0x3c arch/arm64/kernel/stacktrace.c:326\n  __dump_sta\n---truncated---"
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49939",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/fdc73f2cfbe897f4733156df211d79ced649b23c",
            "https://git.kernel.org/stable/c/37c319503023de49a4c87301c8998c8d928112cb",
            "https://git.kernel.org/stable/c/490eddc836b2a6ec286e5df14bed4c7cf5e1f475",
            "https://git.kernel.org/stable/c/7dd5d2514a8ea58f12096e888b0bd050d7eae20a"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: rtw89: avoid to add interface to list twice when SER\n\nIf SER L2 occurs during the WoWLAN resume flow, the add interface flow\nis triggered by ieee80211_reconfig(). However, due to\nrtw89_wow_resume() return failure, it will cause the add interface flow\nto be executed again, resulting in a double add list and causing a kernel\npanic. Therefore, we have added a check to prevent double adding of the\nlist.\n\nlist_add double add: new=ffff99d6992e2010, prev=ffff99d6992e2010, next=ffff99d695302628.\n------------[ cut here ]------------\nkernel BUG at lib/list_debug.c:37!\ninvalid opcode: 0000 [#1] PREEMPT SMP NOPTI\nCPU: 0 PID: 9 Comm: kworker/0:1 Tainted: G        W  O       6.6.30-02659-gc18865c4dfbd #1 770df2933251a0e3c888ba69d1053a817a6376a7\nHardware name: HP Grunt/Grunt, BIOS Google_Grunt.11031.169.0 06/24/2021\nWorkqueue: events_freezable ieee80211_restart_work [mac80211]\nRIP: 0010:__list_add_valid_or_report+0x5e/0xb0\nCode: c7 74 18 48 39 ce 74 13 b0 01 59 5a 5e 5f 41 58 41 59 41 5a 5d e9 e2 d6 03 00 cc 48 c7 c7 8d 4f 17 83 48 89 c2 e8 02 c0 00 00 <0f> 0b 48 c7 c7 aa 8c 1c 83 e8 f4 bf 00 00 0f 0b 48 c7 c7 c8 bc 12\nRSP: 0018:ffffa91b8007bc50 EFLAGS: 00010246\nRAX: 0000000000000058 RBX: ffff99d6992e0900 RCX: a014d76c70ef3900\nRDX: ffffa91b8007bae8 RSI: 00000000ffffdfff RDI: 0000000000000001\nRBP: ffffa91b8007bc88 R08: 0000000000000000 R09: ffffa91b8007bae0\nR10: 00000000ffffdfff R11: ffffffff83a79800 R12: ffff99d695302060\nR13: ffff99d695300900 R14: ffff99d6992e1be0 R15: ffff99d6992e2010\nFS:  0000000000000000(0000) GS:ffff99d6aac00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 000078fbdba43480 CR3: 000000010e464000 CR4: 00000000001506f0\nCall Trace:\n <TASK>\n ? __die_body+0x1f/0x70\n ? die+0x3d/0x60\n ? do_trap+0xa4/0x110\n ? __list_add_valid_or_report+0x5e/0xb0\n ? do_error_trap+0x6d/0x90\n ? __list_add_valid_or_report+0x5e/0xb0\n ? handle_invalid_op+0x30/0x40\n ? __list_add_valid_or_report+0x5e/0xb0\n ? exc_invalid_op+0x3c/0x50\n ? asm_exc_invalid_op+0x16/0x20\n ? __list_add_valid_or_report+0x5e/0xb0\n rtw89_ops_add_interface+0x309/0x310 [rtw89_core 7c32b1ee6854761c0321027c8a58c5160e41f48f]\n drv_add_interface+0x5c/0x130 [mac80211 83e989e6e616bd5b4b8a2b0a9f9352a2c385a3bc]\n ieee80211_reconfig+0x241/0x13d0 [mac80211 83e989e6e616bd5b4b8a2b0a9f9352a2c385a3bc]\n ? finish_wait+0x3e/0x90\n ? synchronize_rcu_expedited+0x174/0x260\n ? sync_rcu_exp_done_unlocked+0x50/0x50\n ? wake_bit_function+0x40/0x40\n ieee80211_restart_work+0xf0/0x140 [mac80211 83e989e6e616bd5b4b8a2b0a9f9352a2c385a3bc]\n process_scheduled_works+0x1e5/0x480\n worker_thread+0xea/0x1e0\n kthread+0xdb/0x110\n ? move_linked_works+0x90/0x90\n ? kthread_associate_blkcg+0xa0/0xa0\n ret_from_fork+0x3b/0x50\n ? kthread_associate_blkcg+0xa0/0xa0\n ret_from_fork_asm+0x11/0x20\n </TASK>\nModules linked in: dm_integrity async_xor xor async_tx lz4 lz4_compress zstd zstd_compress zram zsmalloc rfcomm cmac uinput algif_hash algif_skcipher af_alg btusb btrtl iio_trig_hrtimer industrialio_sw_trigger btmtk industrialio_configfs btbcm btintel uvcvideo videobuf2_vmalloc iio_trig_sysfs videobuf2_memops videobuf2_v4l2 videobuf2_common uvc snd_hda_codec_hdmi veth snd_hda_intel snd_intel_dspcfg acpi_als snd_hda_codec industrialio_triggered_buffer kfifo_buf snd_hwdep industrialio i2c_piix4 snd_hda_core designware_i2s ip6table_nat snd_soc_max98357a xt_MASQUERADE xt_cgroup snd_soc_acp_rt5682_mach fuse rtw89_8922ae(O) rtw89_8922a(O) rtw89_pci(O) rtw89_core(O) 8021q mac80211(O) bluetooth ecdh_generic ecc cfg80211 r8152 mii joydev\ngsmi: Log Shutdown Reason 0x03\n---[ end trace 0000000000000000 ]---"
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49875",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/0ea4333c679f333e23956de743ad17387819d3f2",
            "https://git.kernel.org/stable/c/825789ca94602543101045ad3aad19b2b60c6b2a",
            "https://git.kernel.org/stable/c/6fe058502f8864649c3d614b06b2235223798f48",
            "https://git.kernel.org/stable/c/f7d8ee9db94372b8235f5f22bb24381891594c42",
            "https://git.kernel.org/stable/c/c76005adfa93d1a027433331252422078750321f",
            "https://git.kernel.org/stable/c/e9cfecca22a36b927a440abc6307efb9e138fed5",
            "https://git.kernel.org/stable/c/340e61e44c1d2a15c42ec72ade9195ad525fd048"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnfsd: map the EBADMSG to nfserr_io to avoid warning\n\nExt4 will throw -EBADMSG through ext4_readdir when a checksum error\noccurs, resulting in the following WARNING.\n\nFix it by mapping EBADMSG to nfserr_io.\n\nnfsd_buffered_readdir\n iterate_dir // -EBADMSG -74\n  ext4_readdir // .iterate_shared\n   ext4_dx_readdir\n    ext4_htree_fill_tree\n     htree_dirblock_to_tree\n      ext4_read_dirblock\n       __ext4_read_dirblock\n        ext4_dirblock_csum_verify\n         warn_no_space_for_csum\n          __warn_no_space_for_csum\n        return ERR_PTR(-EFSBADCRC) // -EBADMSG -74\n nfserrno // WARNING\n\n[  161.115610] ------------[ cut here ]------------\n[  161.116465] nfsd: non-standard errno: -74\n[  161.117315] WARNING: CPU: 1 PID: 780 at fs/nfsd/nfsproc.c:878 nfserrno+0x9d/0xd0\n[  161.118596] Modules linked in:\n[  161.119243] CPU: 1 PID: 780 Comm: nfsd Not tainted 5.10.0-00014-g79679361fd5d #138\n[  161.120684] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qe\nmu.org 04/01/2014\n[  161.123601] RIP: 0010:nfserrno+0x9d/0xd0\n[  161.124676] Code: 0f 87 da 30 dd 00 83 e3 01 b8 00 00 00 05 75 d7 44 89 ee 48 c7 c7 c0 57 24 98 89 44 24 04 c6\n 05 ce 2b 61 03 01 e8 99 20 d8 00 <0f> 0b 8b 44 24 04 eb b5 4c 89 e6 48 c7 c7 a0 6d a4 99 e8 cc 15 33\n[  161.127797] RSP: 0018:ffffc90000e2f9c0 EFLAGS: 00010286\n[  161.128794] RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000\n[  161.130089] RDX: 1ffff1103ee16f6d RSI: 0000000000000008 RDI: fffff520001c5f2a\n[  161.131379] RBP: 0000000000000022 R08: 0000000000000001 R09: ffff8881f70c1827\n[  161.132664] R10: ffffed103ee18304 R11: 0000000000000001 R12: 0000000000000021\n[  161.133949] R13: 00000000ffffffb6 R14: ffff8881317c0000 R15: ffffc90000e2fbd8\n[  161.135244] FS:  0000000000000000(0000) GS:ffff8881f7080000(0000) knlGS:0000000000000000\n[  161.136695] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  161.137761] CR2: 00007fcaad70b348 CR3: 0000000144256006 CR4: 0000000000770ee0\n[  161.139041] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  161.140291] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  161.141519] PKRU: 55555554\n[  161.142076] Call Trace:\n[  161.142575]  ? __warn+0x9b/0x140\n[  161.143229]  ? nfserrno+0x9d/0xd0\n[  161.143872]  ? report_bug+0x125/0x150\n[  161.144595]  ? handle_bug+0x41/0x90\n[  161.145284]  ? exc_invalid_op+0x14/0x70\n[  161.146009]  ? asm_exc_invalid_op+0x12/0x20\n[  161.146816]  ? nfserrno+0x9d/0xd0\n[  161.147487]  nfsd_buffered_readdir+0x28b/0x2b0\n[  161.148333]  ? nfsd4_encode_dirent_fattr+0x380/0x380\n[  161.149258]  ? nfsd_buffered_filldir+0xf0/0xf0\n[  161.150093]  ? wait_for_concurrent_writes+0x170/0x170\n[  161.151004]  ? generic_file_llseek_size+0x48/0x160\n[  161.151895]  nfsd_readdir+0x132/0x190\n[  161.152606]  ? nfsd4_encode_dirent_fattr+0x380/0x380\n[  161.153516]  ? nfsd_unlink+0x380/0x380\n[  161.154256]  ? override_creds+0x45/0x60\n[  161.155006]  nfsd4_encode_readdir+0x21a/0x3d0\n[  161.155850]  ? nfsd4_encode_readlink+0x210/0x210\n[  161.156731]  ? write_bytes_to_xdr_buf+0x97/0xe0\n[  161.157598]  ? __write_bytes_to_xdr_buf+0xd0/0xd0\n[  161.158494]  ? lock_downgrade+0x90/0x90\n[  161.159232]  ? nfs4svc_decode_voidarg+0x10/0x10\n[  161.160092]  nfsd4_encode_operation+0x15a/0x440\n[  161.160959]  nfsd4_proc_compound+0x718/0xe90\n[  161.161818]  nfsd_dispatch+0x18e/0x2c0\n[  161.162586]  svc_process_common+0x786/0xc50\n[  161.163403]  ? nfsd_svc+0x380/0x380\n[  161.164137]  ? svc_printk+0x160/0x160\n[  161.164846]  ? svc_xprt_do_enqueue.part.0+0x365/0x380\n[  161.165808]  ? nfsd_svc+0x380/0x380\n[  161.166523]  ? rcu_is_watching+0x23/0x40\n[  161.167309]  svc_process+0x1a5/0x200\n[  161.168019]  nfsd+0x1f5/0x380\n[  161.168663]  ? nfsd_shutdown_threads+0x260/0x260\n[  161.169554]  kthread+0x1c4/0x210\n[  161.170224]  ? kthread_insert_work_sanity_check+0x80/0x80\n[  161.171246]  ret_from_fork+0x1f/0x30"
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49940",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/f7415e60c25a6108cd7955a20b2e66b6251ffe02",
            "https://git.kernel.org/stable/c/24256415d18695b46da06c93135f5b51c548b950"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nl2tp: prevent possible tunnel refcount underflow\n\nWhen a session is created, it sets a backpointer to its tunnel. When\nthe session refcount drops to 0, l2tp_session_free drops the tunnel\nrefcount if session->tunnel is non-NULL. However, session->tunnel is\nset in l2tp_session_create, before the tunnel refcount is incremented\nby l2tp_session_register, which leaves a small window where\nsession->tunnel is non-NULL when the tunnel refcount hasn't been\nbumped.\n\nMoving the assignment to l2tp_session_register is trivial but\nl2tp_session_create calls l2tp_session_set_header_len which uses\nsession->tunnel to get the tunnel's encap. Add an encap arg to\nl2tp_session_set_header_len to avoid using session->tunnel.\n\nIf l2tpv3 sessions have colliding IDs, it is possible for\nl2tp_v3_session_get to race with l2tp_session_register and fetch a\nsession which doesn't yet have session->tunnel set. Add a check for\nthis case."
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49868",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/d73d48acf36f57362df7e4f9d76568168bf5e944",
            "https://git.kernel.org/stable/c/37fee9c220b92c3b7bf22b51c51dde5364e7590b",
            "https://git.kernel.org/stable/c/d13249c0df7aab885acb149695f82c54c0822a70",
            "https://git.kernel.org/stable/c/7ad0c5868f2f0418619089513d95230c66cb7eb4",
            "https://git.kernel.org/stable/c/dc02c1440705e3451abd1c2c8114a5c1bb188e9f",
            "https://git.kernel.org/stable/c/39356ec0e319ed07627b3a0f402d0608546509e6",
            "https://git.kernel.org/stable/c/c3b47f49e83197e8dffd023ec568403bcdbb774b"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix a NULL pointer dereference when failed to start a new trasacntion\n\n[BUG]\nSyzbot reported a NULL pointer dereference with the following crash:\n\n  FAULT_INJECTION: forcing a failure.\n   start_transaction+0x830/0x1670 fs/btrfs/transaction.c:676\n   prepare_to_relocate+0x31f/0x4c0 fs/btrfs/relocation.c:3642\n   relocate_block_group+0x169/0xd20 fs/btrfs/relocation.c:3678\n  ...\n  BTRFS info (device loop0): balance: ended with status: -12\n  Oops: general protection fault, probably for non-canonical address 0xdffffc00000000cc: 0000 [#1] PREEMPT SMP KASAN NOPTI\n  KASAN: null-ptr-deref in range [0x0000000000000660-0x0000000000000667]\n  RIP: 0010:btrfs_update_reloc_root+0x362/0xa80 fs/btrfs/relocation.c:926\n  Call Trace:\n   <TASK>\n   commit_fs_roots+0x2ee/0x720 fs/btrfs/transaction.c:1496\n   btrfs_commit_transaction+0xfaf/0x3740 fs/btrfs/transaction.c:2430\n   del_balance_item fs/btrfs/volumes.c:3678 [inline]\n   reset_balance_state+0x25e/0x3c0 fs/btrfs/volumes.c:3742\n   btrfs_balance+0xead/0x10c0 fs/btrfs/volumes.c:4574\n   btrfs_ioctl_balance+0x493/0x7c0 fs/btrfs/ioctl.c:3673\n   vfs_ioctl fs/ioctl.c:51 [inline]\n   __do_sys_ioctl fs/ioctl.c:907 [inline]\n   __se_sys_ioctl+0xf9/0x170 fs/ioctl.c:893\n   do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n   do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n   entry_SYSCALL_64_after_hwframe+0x77/0x7f\n\n[CAUSE]\nThe allocation failure happens at the start_transaction() inside\nprepare_to_relocate(), and during the error handling we call\nunset_reloc_control(), which makes fs_info->balance_ctl to be NULL.\n\nThen we continue the error path cleanup in btrfs_balance() by calling\nreset_balance_state() which will call del_balance_item() to fully delete\nthe balance item in the root tree.\n\nHowever during the small window between set_reloc_contrl() and\nunset_reloc_control(), we can have a subvolume tree update and created a\nreloc_root for that subvolume.\n\nThen we go into the final btrfs_commit_transaction() of\ndel_balance_item(), and into btrfs_update_reloc_root() inside\ncommit_fs_roots().\n\nThat function checks if fs_info->reloc_ctl is in the merge_reloc_tree\nstage, but since fs_info->reloc_ctl is NULL, it results a NULL pointer\ndereference.\n\n[FIX]\nJust add extra check on fs_info->reloc_ctl inside\nbtrfs_update_reloc_root(), before checking\nfs_info->reloc_ctl->merge_reloc_tree.\n\nThat DEAD_RELOC_TREE handling is to prevent further modification to the\nreloc tree during merge stage, but since there is no reloc_ctl at all,\nwe do not need to bother that."
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49945",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/f6ca58696749268181f43150b3553f2bafd71e42",
            "https://git.kernel.org/stable/c/dd41dab62f32d9e9e0669af8459d12a93834b238",
            "https://git.kernel.org/stable/c/a0ffa68c70b367358b2672cdab6fa5bc4c40de2c"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/ncsi: Disable the ncsi work before freeing the associated structure\n\nThe work function can run after the ncsi device is freed, resulting\nin use-after-free bugs or kernel panic."
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49869",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/843738ede6cb8b959fb22591fcbabe8b456d7216",
            "https://git.kernel.org/stable/c/96c6ca71572a3556ed0c37237305657ff47174b7"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: send: fix buffer overflow detection when copying path to cache entry\n\nStarting with commit c0247d289e73 (\"btrfs: send: annotate struct\nname_cache_entry with __counted_by()\") we annotated the variable length\narray \"name\" from the name_cache_entry structure with __counted_by() to\nimprove overflow detection. However that alone was not correct, because\nthe length of that array does not match the \"name_len\" field - it matches\nthat plus 1 to include the NUL string terminator, so that makes a\nfortified kernel think there's an overflow and report a splat like this:\n\n  strcpy: detected buffer overflow: 20 byte write of buffer size 19\n  WARNING: CPU: 3 PID: 3310 at __fortify_report+0x45/0x50\n  CPU: 3 UID: 0 PID: 3310 Comm: btrfs Not tainted 6.11.0-prnet #1\n  Hardware name: CompuLab Ltd.  sbc-ihsw/Intense-PC2 (IPC2), BIOS IPC2_3.330.7 X64 03/15/2018\n  RIP: 0010:__fortify_report+0x45/0x50\n  Code: 48 8b 34 (...)\n  RSP: 0018:ffff97ebc0d6f650 EFLAGS: 00010246\n  RAX: 7749924ef60fa600 RBX: ffff8bf5446a521a RCX: 0000000000000027\n  RDX: 00000000ffffdfff RSI: ffff97ebc0d6f548 RDI: ffff8bf84e7a1cc8\n  RBP: ffff8bf548574080 R08: ffffffffa8c40e10 R09: 0000000000005ffd\n  R10: 0000000000000004 R11: ffffffffa8c70e10 R12: ffff8bf551eef400\n  R13: 0000000000000000 R14: 0000000000000013 R15: 00000000000003a8\n  FS:  00007fae144de8c0(0000) GS:ffff8bf84e780000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 00007fae14691690 CR3: 00000001027a2003 CR4: 00000000001706f0\n  Call Trace:\n   <TASK>\n   ? __warn+0x12a/0x1d0\n   ? __fortify_report+0x45/0x50\n   ? report_bug+0x154/0x1c0\n   ? handle_bug+0x42/0x70\n   ? exc_invalid_op+0x1a/0x50\n   ? asm_exc_invalid_op+0x1a/0x20\n   ? __fortify_report+0x45/0x50\n   __fortify_panic+0x9/0x10\n  __get_cur_name_and_parent+0x3bc/0x3c0\n   get_cur_path+0x207/0x3b0\n   send_extent_data+0x709/0x10d0\n   ? find_parent_nodes+0x22df/0x25d0\n   ? mas_nomem+0x13/0x90\n   ? mtree_insert_range+0xa5/0x110\n   ? btrfs_lru_cache_store+0x5f/0x1e0\n   ? iterate_extent_inodes+0x52d/0x5a0\n   process_extent+0xa96/0x11a0\n   ? __pfx_lookup_backref_cache+0x10/0x10\n   ? __pfx_store_backref_cache+0x10/0x10\n   ? __pfx_iterate_backrefs+0x10/0x10\n   ? __pfx_check_extent_item+0x10/0x10\n   changed_cb+0x6fa/0x930\n   ? tree_advance+0x362/0x390\n   ? memcmp_extent_buffer+0xd7/0x160\n   send_subvol+0xf0a/0x1520\n   btrfs_ioctl_send+0x106b/0x11d0\n   ? __pfx___clone_root_cmp_sort+0x10/0x10\n   _btrfs_ioctl_send+0x1ac/0x240\n   btrfs_ioctl+0x75b/0x850\n   __se_sys_ioctl+0xca/0x150\n   do_syscall_64+0x85/0x160\n   ? __count_memcg_events+0x69/0x100\n   ? handle_mm_fault+0x1327/0x15c0\n   ? __se_sys_rt_sigprocmask+0xf1/0x180\n   ? syscall_exit_to_user_mode+0x75/0xa0\n   ? do_syscall_64+0x91/0x160\n   ? do_user_addr_fault+0x21d/0x630\n  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n  RIP: 0033:0x7fae145eeb4f\n  Code: 00 48 89 (...)\n  RSP: 002b:00007ffdf1cb09b0 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\n  RAX: ffffffffffffffda RBX: 0000000000000004 RCX: 00007fae145eeb4f\n  RDX: 00007ffdf1cb0ad0 RSI: 0000000040489426 RDI: 0000000000000004\n  RBP: 00000000000078fe R08: 00007fae144006c0 R09: 00007ffdf1cb0927\n  R10: 0000000000000008 R11: 0000000000000246 R12: 00007ffdf1cb1ce8\n  R13: 0000000000000003 R14: 000055c499fab2e0 R15: 0000000000000004\n   </TASK>\n\nFix this by not storing the NUL string terminator since we don't actually\nneed it for name cache entries, this way \"name_len\" corresponds to the\nactual size of the \"name\" array. This requires marking the \"name\" array\nfield with __nonstring and using memcpy() instead of strcpy() as\nrecommended by the guidelines at:\n\n   https://github.com/KSPP/linux/issues/90"
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49947",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/d9dfd41e32ccc5198033ddd1ff1516822dfefa5a",
            "https://git.kernel.org/stable/c/4cc0648e9e3240496835dc698ace1d046d8d57ea",
            "https://git.kernel.org/stable/c/7711c419a915ee0dd91c125d2b967bbf2a72e9ac",
            "https://git.kernel.org/stable/c/49d14b54a527289d09a9480f214b8c586322310a"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: test for not too small csum_start in virtio_net_hdr_to_skb()\n\nsyzbot was able to trigger this warning [1], after injecting a\nmalicious packet through af_packet, setting skb->csum_start and thus\nthe transport header to an incorrect value.\n\nWe can at least make sure the transport header is after\nthe end of the network header (with a estimated minimal size).\n\n[1]\n[   67.873027] skb len=4096 headroom=16 headlen=14 tailroom=0\nmac=(-1,-1) mac_len=0 net=(16,-6) trans=10\nshinfo(txflags=0 nr_frags=1 gso(size=0 type=0 segs=0))\ncsum(0xa start=10 offset=0 ip_summed=3 complete_sw=0 valid=0 level=0)\nhash(0x0 sw=0 l4=0) proto=0x0800 pkttype=0 iif=0\npriority=0x0 mark=0x0 alloc_cpu=10 vlan_all=0x0\nencapsulation=0 inner(proto=0x0000, mac=0, net=0, trans=0)\n[   67.877172] dev name=veth0_vlan feat=0x000061164fdd09e9\n[   67.877764] sk family=17 type=3 proto=0\n[   67.878279] skb linear:   00000000: 00 00 10 00 00 00 00 00 0f 00 00 00 08 00\n[   67.879128] skb frag:     00000000: 0e 00 07 00 00 00 28 00 08 80 1c 00 04 00 00 02\n[   67.879877] skb frag:     00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   67.880647] skb frag:     00000020: 00 00 02 00 00 00 08 00 1b 00 00 00 00 00 00 00\n[   67.881156] skb frag:     00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   67.881753] skb frag:     00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   67.882173] skb frag:     00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   67.882790] skb frag:     00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   67.883171] skb frag:     00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   67.883733] skb frag:     00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   67.884206] skb frag:     00000090: 00 00 00 00 00 00 00 00 00 00 69 70 76 6c 61 6e\n[   67.884704] skb frag:     000000a0: 31 00 00 00 00 00 00 00 00 00 2b 00 00 00 00 00\n[   67.885139] skb frag:     000000b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   67.885677] skb frag:     000000c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   67.886042] skb frag:     000000d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   67.886408] skb frag:     000000e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   67.887020] skb frag:     000000f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   67.887384] skb frag:     00000100: 00 00\n[   67.887878] ------------[ cut here ]------------\n[   67.887908] offset (-6) >= skb_headlen() (14)\n[   67.888445] WARNING: CPU: 10 PID: 2088 at net/core/dev.c:3332 skb_checksum_help (net/core/dev.c:3332 (discriminator 2))\n[   67.889353] Modules linked in: macsec macvtap macvlan hsr wireguard curve25519_x86_64 libcurve25519_generic libchacha20poly1305 chacha_x86_64 libchacha poly1305_x86_64 dummy bridge sr_mod cdrom evdev pcspkr i2c_piix4 9pnet_virtio 9p 9pnet netfs\n[   67.890111] CPU: 10 UID: 0 PID: 2088 Comm: b363492833 Not tainted 6.11.0-virtme #1011\n[   67.890183] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014\n[   67.890309] RIP: 0010:skb_checksum_help (net/core/dev.c:3332 (discriminator 2))\n[   67.891043] Call Trace:\n[   67.891173]  <TASK>\n[   67.891274] ? __warn (kernel/panic.c:741)\n[   67.891320] ? skb_checksum_help (net/core/dev.c:3332 (discriminator 2))\n[   67.891333] ? report_bug (lib/bug.c:180 lib/bug.c:219)\n[   67.891348] ? handle_bug (arch/x86/kernel/traps.c:239)\n[   67.891363] ? exc_invalid_op (arch/x86/kernel/traps.c:260 (discriminator 1))\n[   67.891372] ? asm_exc_invalid_op (./arch/x86/include/asm/idtentry.h:621)\n[   67.891388] ? skb_checksum_help (net/core/dev.c:3332 (discriminator 2))\n[   67.891399] ? skb_checksum_help (net/core/dev.c:3332 (discriminator 2))\n[   67.891416] ip_do_fragment (net/ipv4/ip_output.c:777 (discriminator 1))\n[   67.891448] ? __ip_local_out (./include/linux/skbuff.h:1146 ./include/net/l3mdev.h:196 ./include/net/l3mdev.h:213 ne\n---truncated---"
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49870",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/d32ff64c872d7e08e893c32ba6a2374583444410",
            "https://git.kernel.org/stable/c/c7d10fa7d7691558ff967668494672415f5fa151",
            "https://git.kernel.org/stable/c/e4a28489b310339b2b8187bec0a437709be551c1",
            "https://git.kernel.org/stable/c/7fa2382f97421978514a419c93054eca69f5247b",
            "https://git.kernel.org/stable/c/da6ef2dffe6056aad3435e6cf7c6471c2a62187c"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ncachefiles: fix dentry leak in cachefiles_open_file()\n\nA dentry leak may be caused when a lookup cookie and a cull are concurrent:\n\n            P1             |             P2\n-----------------------------------------------------------\ncachefiles_lookup_cookie\n  cachefiles_look_up_object\n    lookup_one_positive_unlocked\n     // get dentry\n                            cachefiles_cull\n                              inode->i_flags |= S_KERNEL_FILE;\n    cachefiles_open_file\n      cachefiles_mark_inode_in_use\n        __cachefiles_mark_inode_in_use\n          can_use = false\n          if (!(inode->i_flags & S_KERNEL_FILE))\n            can_use = true\n\t  return false\n        return false\n        // Returns an error but doesn't put dentry\n\nAfter that the following WARNING will be triggered when the backend folder\nis umounted:\n\n==================================================================\nBUG: Dentry 000000008ad87947{i=7a,n=Dx_1_1.img}  still in use (1) [unmount of ext4 sda]\nWARNING: CPU: 4 PID: 359261 at fs/dcache.c:1767 umount_check+0x5d/0x70\nCPU: 4 PID: 359261 Comm: umount Not tainted 6.6.0-dirty #25\nRIP: 0010:umount_check+0x5d/0x70\nCall Trace:\n <TASK>\n d_walk+0xda/0x2b0\n do_one_tree+0x20/0x40\n shrink_dcache_for_umount+0x2c/0x90\n generic_shutdown_super+0x20/0x160\n kill_block_super+0x1a/0x40\n ext4_kill_sb+0x22/0x40\n deactivate_locked_super+0x35/0x80\n cleanup_mnt+0x104/0x160\n==================================================================\n\nWhether cachefiles_open_file() returns true or false, the reference count\nobtained by lookup_positive_unlocked() in cachefiles_look_up_object()\nshould be released.\n\nTherefore release that reference count in cachefiles_look_up_object() to\nfix the above issue and simplify the code."
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49872",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/e28f39b359c0cfdcc011603e51187085a5f1e5e3",
            "https://git.kernel.org/stable/c/ce645b9fdc78ec5d28067286e92871ddae6817d5"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/gup: fix memfd_pin_folios alloc race panic\n\nIf memfd_pin_folios tries to create a hugetlb page, but someone else\nalready did, then folio gets the value -EEXIST here:\n\n        folio = memfd_alloc_folio(memfd, start_idx);\n        if (IS_ERR(folio)) {\n                ret = PTR_ERR(folio);\n                if (ret != -EEXIST)\n                        goto err;\n\nthen on the next trip through the \"while start_idx\" loop we panic here:\n\n        if (folio) {\n                folio_put(folio);\n\nTo fix, set the folio to NULL on error."
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49872",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/e28f39b359c0cfdcc011603e51187085a5f1e5e3",
            "https://git.kernel.org/stable/c/ce645b9fdc78ec5d28067286e92871ddae6817d5"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/gup: fix memfd_pin_folios alloc race panic\n\nIf memfd_pin_folios tries to create a hugetlb page, but someone else\nalready did, then folio gets the value -EEXIST here:\n\n        folio = memfd_alloc_folio(memfd, start_idx);\n        if (IS_ERR(folio)) {\n                ret = PTR_ERR(folio);\n                if (ret != -EEXIST)\n                        goto err;\n\nthen on the next trip through the \"while start_idx\" loop we panic here:\n\n        if (folio) {\n                folio_put(folio);\n\nTo fix, set the folio to NULL on error."
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49948",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/566a931a1436d0e0ad13708ea55479b95426213c",
            "https://git.kernel.org/stable/c/2415f465730e48b6e38da1c7c097317bf5dd2d20",
            "https://git.kernel.org/stable/c/27a8fabc54d2f960d47bdfbebf2bdc6e8a92a4c4",
            "https://git.kernel.org/stable/c/9b0ee571d20a238a22722126abdfde61f1b2bdd0",
            "https://git.kernel.org/stable/c/ff1c3cadcf405ab37dd91418a62a7acecf3bc5e2",
            "https://git.kernel.org/stable/c/1eebe602a8d8264a12e35e39d0645fa88dbbacdd",
            "https://git.kernel.org/stable/c/ab9a9a9e9647392a19e7a885b08000e89c86b535"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: add more sanity checks to qdisc_pkt_len_init()\n\nOne path takes care of SKB_GSO_DODGY, assuming\nskb->len is bigger than hdr_len.\n\nvirtio_net_hdr_to_skb() does not fully dissect TCP headers,\nit only make sure it is at least 20 bytes.\n\nIt is possible for an user to provide a malicious 'GSO' packet,\ntotal length of 80 bytes.\n\n- 20 bytes of IPv4 header\n- 60 bytes TCP header\n- a small gso_size like 8\n\nvirtio_net_hdr_to_skb() would declare this packet as a normal\nGSO packet, because it would see 40 bytes of payload,\nbigger than gso_size.\n\nWe need to make detect this case to not underflow\nqdisc_skb_cb(skb)->pkt_len."
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49876",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/272b0e78874586d6ccae04079d75b27b47705544",
            "https://git.kernel.org/stable/c/421c74670b0f9d5c007f1276d3647aa58f407fde",
            "https://git.kernel.org/stable/c/2d2be279f1ca9e7288282d4214f16eea8a727cdb"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/xe: fix UAF around queue destruction\n\nWe currently do stuff like queuing the final destruction step on a\nrandom system wq, which will outlive the driver instance. With bad\ntiming we can teardown the driver with one or more work workqueue still\nbeing alive leading to various UAF splats. Add a fini step to ensure\nuser queues are properly torn down. At this point GuC should already be\nnuked so queue itself should no longer be referenced from hw pov.\n\nv2 (Matt B)\n - Looks much safer to use a waitqueue and then just wait for the\n   xa_array to become empty before triggering the drain.\n\n(cherry picked from commit 861108666cc0e999cffeab6aff17b662e68774e3)"
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49877",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/61b84013e560382cbe7dd56758be3154d43a3988",
            "https://git.kernel.org/stable/c/df944dc46d06af65a75191183d52be017e6b9dbe",
            "https://git.kernel.org/stable/c/01cb2e751cc61ade454c9bc1aaa2eac1f8197112",
            "https://git.kernel.org/stable/c/d52c5652e7dcb7a0648bbb8642cc3e617070ab49",
            "https://git.kernel.org/stable/c/46b1edf0536a5291a8ad2337f88c926214b209d9",
            "https://git.kernel.org/stable/c/4846e72ab5a0726e49ad4188b9d9df091ae78c64",
            "https://git.kernel.org/stable/c/33b525cef4cff49e216e4133cc48452e11c0391e"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nocfs2: fix possible null-ptr-deref in ocfs2_set_buffer_uptodate\n\nWhen doing cleanup, if flags without OCFS2_BH_READAHEAD, it may trigger\nNULL pointer dereference in the following ocfs2_set_buffer_uptodate() if\nbh is NULL."
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49887",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/9f6e7a0512a57387d36f5e9e9635d6668cac13dd",
            "https://git.kernel.org/stable/c/645ec43760e86d3079fee2e8b51fde7060a540d0",
            "https://git.kernel.org/stable/c/65a6ce4726c27b45600303f06496fef46d00b57f"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nf2fs: fix to don't panic system for no free segment fault injection\n\nf2fs: fix to don't panic system for no free segment fault injection\n\nsyzbot reports a f2fs bug as below:\n\nF2FS-fs (loop0): inject no free segment in get_new_segment of __allocate_new_segment+0x1ce/0x940 fs/f2fs/segment.c:3167\nF2FS-fs (loop0): Stopped filesystem due to reason: 7\n------------[ cut here ]------------\nkernel BUG at fs/f2fs/segment.c:2748!\nCPU: 0 UID: 0 PID: 5109 Comm: syz-executor304 Not tainted 6.11.0-rc6-syzkaller-00363-g89f5e14d05b4 #0\nRIP: 0010:get_new_segment fs/f2fs/segment.c:2748 [inline]\nRIP: 0010:new_curseg+0x1f61/0x1f70 fs/f2fs/segment.c:2836\nCall Trace:\n __allocate_new_segment+0x1ce/0x940 fs/f2fs/segment.c:3167\n f2fs_allocate_new_section fs/f2fs/segment.c:3181 [inline]\n f2fs_allocate_pinning_section+0xfa/0x4e0 fs/f2fs/segment.c:3195\n f2fs_expand_inode_data+0x5d6/0xbb0 fs/f2fs/file.c:1799\n f2fs_fallocate+0x448/0x960 fs/f2fs/file.c:1903\n vfs_fallocate+0x553/0x6c0 fs/open.c:334\n do_vfs_ioctl+0x2592/0x2e50 fs/ioctl.c:886\n __do_sys_ioctl fs/ioctl.c:905 [inline]\n __se_sys_ioctl+0x81/0x170 fs/ioctl.c:893\n do_syscall_x64 arch/x86/entry/common.c:52 [inline]\n do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83\n entry_SYSCALL_64_after_hwframe+0x77/0x7f\nRIP: 0010:get_new_segment fs/f2fs/segment.c:2748 [inline]\nRIP: 0010:new_curseg+0x1f61/0x1f70 fs/f2fs/segment.c:2836\n\nThe root cause is when we inject no free segment fault into f2fs,\nwe should not panic system, fix it."
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49949",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/ba26060a29d3ca1bfc737aa79f7125128f35147c",
            "https://git.kernel.org/stable/c/939c88cbdc668dadd8cfa7a35d9066331239041c",
            "https://git.kernel.org/stable/c/d6114993e0a89fde84a60a60a8329a571580b174",
            "https://git.kernel.org/stable/c/25ab0b87dbd89cecef8a9c60a02bb97832e471d1",
            "https://git.kernel.org/stable/c/f959cce8a2a04ce776aa8b78e83ce339e0d7fbac",
            "https://git.kernel.org/stable/c/81fd007dcd47c34471766249853e4d4bce8eea4b",
            "https://git.kernel.org/stable/c/c20029db28399ecc50e556964eaba75c43b1e2f1"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: avoid potential underflow in qdisc_pkt_len_init() with UFO\n\nAfter commit 7c6d2ecbda83 (\"net: be more gentle about silly gso\nrequests coming from user\") virtio_net_hdr_to_skb() had sanity check\nto detect malicious attempts from user space to cook a bad GSO packet.\n\nThen commit cf9acc90c80ec (\"net: virtio_net_hdr_to_skb: count\ntransport header in UFO\") while fixing one issue, allowed user space\nto cook a GSO packet with the following characteristic :\n\nIPv4 SKB_GSO_UDP, gso_size=3, skb->len = 28.\n\nWhen this packet arrives in qdisc_pkt_len_init(), we end up\nwith hdr_len = 28 (IPv4 header + UDP header), matching skb->len\n\nThen the following sets gso_segs to 0 :\n\ngso_segs = DIV_ROUND_UP(skb->len - hdr_len,\n                        shinfo->gso_size);\n\nThen later we set qdisc_skb_cb(skb)->pkt_len to back to zero :/\n\nqdisc_skb_cb(skb)->pkt_len += (gso_segs - 1) * hdr_len;\n\nThis leads to the following crash in fq_codel [1]\n\nqdisc_pkt_len_init() is best effort, we only want an estimation\nof the bytes sent on the wire, not crashing the kernel.\n\nThis patch is fixing this particular issue, a following one\nadds more sanity checks for another potential bug.\n\n[1]\n[   70.724101] BUG: kernel NULL pointer dereference, address: 0000000000000000\n[   70.724561] #PF: supervisor read access in kernel mode\n[   70.724561] #PF: error_code(0x0000) - not-present page\n[   70.724561] PGD 10ac61067 P4D 10ac61067 PUD 107ee2067 PMD 0\n[   70.724561] Oops: Oops: 0000 [#1] SMP NOPTI\n[   70.724561] CPU: 11 UID: 0 PID: 2163 Comm: b358537762 Not tainted 6.11.0-virtme #991\n[   70.724561] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014\n[   70.724561] RIP: 0010:fq_codel_enqueue (net/sched/sch_fq_codel.c:120 net/sched/sch_fq_codel.c:168 net/sched/sch_fq_codel.c:230) sch_fq_codel\n[ 70.724561] Code: 24 08 49 c1 e1 06 44 89 7c 24 18 45 31 ed 45 31 c0 31 ff 89 44 24 14 4c 03 8b 90 01 00 00 eb 04 39 ca 73 37 4d 8b 39 83 c7 01 <49> 8b 17 49 89 11 41 8b 57 28 45 8b 5f 34 49 c7 07 00 00 00 00 49\nAll code\n========\n   0:\t24 08                \tand    $0x8,%al\n   2:\t49 c1 e1 06          \tshl    $0x6,%r9\n   6:\t44 89 7c 24 18       \tmov    %r15d,0x18(%rsp)\n   b:\t45 31 ed             \txor    %r13d,%r13d\n   e:\t45 31 c0             \txor    %r8d,%r8d\n  11:\t31 ff                \txor    %edi,%edi\n  13:\t89 44 24 14          \tmov    %eax,0x14(%rsp)\n  17:\t4c 03 8b 90 01 00 00 \tadd    0x190(%rbx),%r9\n  1e:\teb 04                \tjmp    0x24\n  20:\t39 ca                \tcmp    %ecx,%edx\n  22:\t73 37                \tjae    0x5b\n  24:\t4d 8b 39             \tmov    (%r9),%r15\n  27:\t83 c7 01             \tadd    $0x1,%edi\n  2a:*\t49 8b 17             \tmov    (%r15),%rdx\t\t<-- trapping instruction\n  2d:\t49 89 11             \tmov    %rdx,(%r9)\n  30:\t41 8b 57 28          \tmov    0x28(%r15),%edx\n  34:\t45 8b 5f 34          \tmov    0x34(%r15),%r11d\n  38:\t49 c7 07 00 00 00 00 \tmovq   $0x0,(%r15)\n  3f:\t49                   \trex.WB\n\nCode starting with the faulting instruction\n===========================================\n   0:\t49 8b 17             \tmov    (%r15),%rdx\n   3:\t49 89 11             \tmov    %rdx,(%r9)\n   6:\t41 8b 57 28          \tmov    0x28(%r15),%edx\n   a:\t45 8b 5f 34          \tmov    0x34(%r15),%r11d\n   e:\t49 c7 07 00 00 00 00 \tmovq   $0x0,(%r15)\n  15:\t49                   \trex.WB\n[   70.724561] RSP: 0018:ffff95ae85e6fb90 EFLAGS: 00000202\n[   70.724561] RAX: 0000000002000000 RBX: ffff95ae841de000 RCX: 0000000000000000\n[   70.724561] RDX: 0000000000000000 RSI: 0000000000000001 RDI: 0000000000000001\n[   70.724561] RBP: ffff95ae85e6fbf8 R08: 0000000000000000 R09: ffff95b710a30000\n[   70.724561] R10: 0000000000000000 R11: bdf289445ce31881 R12: ffff95ae85e6fc58\n[   70.724561] R13: 0000000000000000 R14: 0000000000000040 R15: 0000000000000000\n[   70.724561] FS:  000000002c5c1380(0000) GS:ffff95bd7fcc0000(0000) knlGS:0000000000000000\n[   70.724561] CS:  0010 DS: 0000 ES: 0000 C\n---truncated---"
    },
    {
        "Modified": "2024-10-21T18:15:00",
        "Published": "2024-10-21T18:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2024-49879",
        "impact": {},
        "last-modified": "2024-10-21T18:15:00",
        "references": [
            "https://git.kernel.org/stable/c/2bda89735199683b03f55b807bd1e31a3857520b",
            "https://git.kernel.org/stable/c/e60b0d3b5aa2e8d934deca9e11215af84e632bc9",
            "https://git.kernel.org/stable/c/f37a1d9e5e22d5489309c3cd2db476dcdcc6530c",
            "https://git.kernel.org/stable/c/b57b53e8ffcdfda87d954fc4187426a54fe75a3d",
            "https://git.kernel.org/stable/c/0d71916694aceb207fefecf62dfa811ec1108bbd",
            "https://git.kernel.org/stable/c/334de68eda2b99892ba869c15cb59bc956fd9f42",
            "https://git.kernel.org/stable/c/e794b7b9b92977365c693760a259f8eef940c536"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm: omapdrm: Add missing check for alloc_ordered_workqueue\n\nAs it may return NULL pointer and cause NULL pointer dereference. Add check\nfor the return value of alloc_ordered_workqueue."
    }
]