[
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47220",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/ff4c63f3e8cb7af2ce51cc56b031e08fd23c758b",
            "https://git.kernel.org/stable/c/58b5e02c6ca0e2b7c87cd8023ff786ef3c0eef74",
            "https://git.kernel.org/stable/c/7f9745ab342bcce5efd5d4d2297d0a3dd9db0eac",
            "https://git.kernel.org/stable/c/fd7c4bd582494934be15d41aebe0dbe23790605f",
            "https://git.kernel.org/stable/c/174c27583b3807ac96228c442735b02622d8d1c3",
            "https://git.kernel.org/stable/c/fa8c413e6b74ae5d12daf911c73238c5bdacd8e6",
            "https://git.kernel.org/stable/c/4bf584a03eec674975ee9fe36c8583d9d470dab1"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: dwc3: core: fix kernel panic when do reboot\n\nWhen do system reboot, it calls dwc3_shutdown and the whole debugfs\nfor dwc3 has removed first, when the gadget tries to do deinit, and\nremove debugfs for its endpoints, it meets NULL pointer dereference\nissue when call debugfs_lookup. Fix it by removing the whole dwc3\ndebugfs later than dwc3_drd_exit.\n\n[ 2924.958838] Unable to handle kernel NULL pointer dereference at virtual address 0000000000000002\n....\n[ 2925.030994] pstate: 60000005 (nZCv daif -PAN -UAO -TCO BTYPE=--)\n[ 2925.037005] pc : inode_permission+0x2c/0x198\n[ 2925.041281] lr : lookup_one_len_common+0xb0/0xf8\n[ 2925.045903] sp : ffff80001276ba70\n[ 2925.049218] x29: ffff80001276ba70 x28: ffff0000c01f0000 x27: 0000000000000000\n[ 2925.056364] x26: ffff800011791e70 x25: 0000000000000008 x24: dead000000000100\n[ 2925.063510] x23: dead000000000122 x22: 0000000000000000 x21: 0000000000000001\n[ 2925.070652] x20: ffff8000122c6188 x19: 0000000000000000 x18: 0000000000000000\n[ 2925.077797] x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000004\n[ 2925.084943] x14: ffffffffffffffff x13: 0000000000000000 x12: 0000000000000030\n[ 2925.092087] x11: 0101010101010101 x10: 7f7f7f7f7f7f7f7f x9 : ffff8000102b2420\n[ 2925.099232] x8 : 7f7f7f7f7f7f7f7f x7 : feff73746e2f6f64 x6 : 0000000000008080\n[ 2925.106378] x5 : 61c8864680b583eb x4 : 209e6ec2d263dbb7 x3 : 000074756f307065\n[ 2925.113523] x2 : 0000000000000001 x1 : 0000000000000000 x0 : ffff8000122c6188\n[ 2925.120671] Call trace:\n[ 2925.123119]  inode_permission+0x2c/0x198\n[ 2925.127042]  lookup_one_len_common+0xb0/0xf8\n[ 2925.131315]  lookup_one_len_unlocked+0x34/0xb0\n[ 2925.135764]  lookup_positive_unlocked+0x14/0x50\n[ 2925.140296]  debugfs_lookup+0x68/0xa0\n[ 2925.143964]  dwc3_gadget_free_endpoints+0x84/0xb0\n[ 2925.148675]  dwc3_gadget_exit+0x28/0x78\n[ 2925.152518]  dwc3_drd_exit+0x100/0x1f8\n[ 2925.156267]  dwc3_remove+0x11c/0x120\n[ 2925.159851]  dwc3_shutdown+0x14/0x20\n[ 2925.163432]  platform_shutdown+0x28/0x38\n[ 2925.167360]  device_shutdown+0x15c/0x378\n[ 2925.171291]  kernel_restart_prepare+0x3c/0x48\n[ 2925.175650]  kernel_restart+0x1c/0x68\n[ 2925.179316]  __do_sys_reboot+0x218/0x240\n[ 2925.183247]  __arm64_sys_reboot+0x28/0x30\n[ 2925.187262]  invoke_syscall+0x48/0x100\n[ 2925.191017]  el0_svc_common.constprop.0+0x48/0xc8\n[ 2925.195726]  do_el0_svc+0x28/0x88\n[ 2925.199045]  el0_svc+0x20/0x30\n[ 2925.202104]  el0_sync_handler+0xa8/0xb0\n[ 2925.205942]  el0_sync+0x148/0x180\n[ 2925.209270] Code: a9025bf5 2a0203f5 121f0056 370802b5 (79400660)\n[ 2925.215372] ---[ end trace 124254d8e485a58b ]---\n[ 2925.220012] Kernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b\n[ 2925.227676] Kernel Offset: disabled\n[ 2925.231164] CPU features: 0x00001001,20000846\n[ 2925.235521] Memory Limit: none\n[ 2925.238580] ---[ end Kernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b ]---\n\n(cherry picked from commit 2a042767814bd0edf2619f06fecd374e266ea068)"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47221",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/f6ed2357541612a13a5841b3af4dc32ed984a25f",
            "https://git.kernel.org/stable/c/ce6e8bee7a3883e8008b30f5887dbb426aac6a35",
            "https://git.kernel.org/stable/c/e41a49fadbc80b60b48d3c095d9e2ee7ef7c9a8e"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/slub: actually fix freelist pointer vs redzoning\n\nIt turns out that SLUB redzoning (\"slub_debug=Z\") checks from\ns->object_size rather than from s->inuse (which is normally bumped to\nmake room for the freelist pointer), so a cache created with an object\nsize less than 24 would have the freelist pointer written beyond\ns->object_size, causing the redzone to be corrupted by the freelist\npointer.  This was very visible with \"slub_debug=ZF\":\n\n  BUG test (Tainted: G    B            ): Right Redzone overwritten\n  -----------------------------------------------------------------------------\n\n  INFO: 0xffff957ead1c05de-0xffff957ead1c05df @offset=1502. First byte 0x1a instead of 0xbb\n  INFO: Slab 0xffffef3950b47000 objects=170 used=170 fp=0x0000000000000000 flags=0x8000000000000200\n  INFO: Object 0xffff957ead1c05d8 @offset=1496 fp=0xffff957ead1c0620\n\n  Redzone  (____ptrval____): bb bb bb bb bb bb bb bb               ........\n  Object   (____ptrval____): 00 00 00 00 00 f6 f4 a5               ........\n  Redzone  (____ptrval____): 40 1d e8 1a aa                        @....\n  Padding  (____ptrval____): 00 00 00 00 00 00 00 00               ........\n\nAdjust the offset to stay within s->object_size.\n\n(Note that no caches of in this size range are known to exist in the\nkernel currently.)"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47228",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/208bb686e7fa7fff16e8fa78ff0db34aa9acdbd7",
            "https://git.kernel.org/stable/c/b7a05aba39f733ec337c5b952e112dd2dc4fc404",
            "https://git.kernel.org/stable/c/8d651ee9c71bb12fc0c8eb2786b66cbe5aa3e43b"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/ioremap: Map EFI-reserved memory as encrypted for SEV\n\nSome drivers require memory that is marked as EFI boot services\ndata. In order for this memory to not be re-used by the kernel\nafter ExitBootServices(), efi_mem_reserve() is used to preserve it\nby inserting a new EFI memory descriptor and marking it with the\nEFI_MEMORY_RUNTIME attribute.\n\nUnder SEV, memory marked with the EFI_MEMORY_RUNTIME attribute needs to\nbe mapped encrypted by Linux, otherwise the kernel might crash at boot\nlike below:\n\n  EFI Variables Facility v0.08 2004-May-17\n  general protection fault, probably for non-canonical address 0x3597688770a868b2: 0000 [#1] SMP NOPTI\n  CPU: 13 PID: 1 Comm: swapper/0 Not tainted 5.12.4-2-default #1 openSUSE Tumbleweed\n  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015\n  RIP: 0010:efi_mokvar_entry_next\n  [...]\n  Call Trace:\n   efi_mokvar_sysfs_init\n   ? efi_mokvar_table_init\n   do_one_initcall\n   ? __kmalloc\n   kernel_init_freeable\n   ? rest_init\n   kernel_init\n   ret_from_fork\n\nExpand the __ioremap_check_other() function to additionally check for\nthis other type of boot data reserved at runtime and indicate that it\nshould be mapped encrypted for an SEV guest.\n\n [ bp: Massage commit message. ]"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47228",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/208bb686e7fa7fff16e8fa78ff0db34aa9acdbd7",
            "https://git.kernel.org/stable/c/b7a05aba39f733ec337c5b952e112dd2dc4fc404",
            "https://git.kernel.org/stable/c/8d651ee9c71bb12fc0c8eb2786b66cbe5aa3e43b"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/ioremap: Map EFI-reserved memory as encrypted for SEV\n\nSome drivers require memory that is marked as EFI boot services\ndata. In order for this memory to not be re-used by the kernel\nafter ExitBootServices(), efi_mem_reserve() is used to preserve it\nby inserting a new EFI memory descriptor and marking it with the\nEFI_MEMORY_RUNTIME attribute.\n\nUnder SEV, memory marked with the EFI_MEMORY_RUNTIME attribute needs to\nbe mapped encrypted by Linux, otherwise the kernel might crash at boot\nlike below:\n\n  EFI Variables Facility v0.08 2004-May-17\n  general protection fault, probably for non-canonical address 0x3597688770a868b2: 0000 [#1] SMP NOPTI\n  CPU: 13 PID: 1 Comm: swapper/0 Not tainted 5.12.4-2-default #1 openSUSE Tumbleweed\n  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015\n  RIP: 0010:efi_mokvar_entry_next\n  [...]\n  Call Trace:\n   efi_mokvar_sysfs_init\n   ? efi_mokvar_table_init\n   do_one_initcall\n   ? __kmalloc\n   kernel_init_freeable\n   ? rest_init\n   kernel_init\n   ret_from_fork\n\nExpand the __ioremap_check_other() function to additionally check for\nthis other type of boot data reserved at runtime and indicate that it\nshould be mapped encrypted for an SEV guest.\n\n [ bp: Massage commit message. ]"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47231",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/89df95ce32be204eef2e7d4b2f6fb552fb191a68",
            "https://git.kernel.org/stable/c/a115198caaab6d663bef75823a3c5f0802306d60",
            "https://git.kernel.org/stable/c/6f87c0e21ad20dd3d22108e33db1c552dfa352a0",
            "https://git.kernel.org/stable/c/6bd3d80d1f019cefa7011056c54b323f1d8b8e83",
            "https://git.kernel.org/stable/c/d0760a4ef85697bc756d06eae17ae27f3f055401",
            "https://git.kernel.org/stable/c/91c02557174be7f72e46ed7311e3bea1939840b0"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ncan: mcba_usb: fix memory leak in mcba_usb\n\nSyzbot reported memory leak in SocketCAN driver for Microchip CAN BUS\nAnalyzer Tool. The problem was in unfreed usb_coherent.\n\nIn mcba_usb_start() 20 coherent buffers are allocated and there is\nnothing, that frees them:\n\n1) In callback function the urb is resubmitted and that's all\n2) In disconnect function urbs are simply killed, but URB_FREE_BUFFER\n   is not set (see mcba_usb_start) and this flag cannot be used with\n   coherent buffers.\n\nFail log:\n| [ 1354.053291][ T8413] mcba_usb 1-1:0.0 can0: device disconnected\n| [ 1367.059384][ T8420] kmemleak: 20 new suspected memory leaks (see /sys/kernel/debug/kmem)\n\nSo, all allocated buffers should be freed with usb_free_coherent()\nexplicitly\n\nNOTE:\nThe same pattern for allocating and freeing coherent buffers\nis used in drivers/net/can/usb/kvaser_usb/kvaser_usb_core.c"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47231",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/89df95ce32be204eef2e7d4b2f6fb552fb191a68",
            "https://git.kernel.org/stable/c/a115198caaab6d663bef75823a3c5f0802306d60",
            "https://git.kernel.org/stable/c/6f87c0e21ad20dd3d22108e33db1c552dfa352a0",
            "https://git.kernel.org/stable/c/6bd3d80d1f019cefa7011056c54b323f1d8b8e83",
            "https://git.kernel.org/stable/c/d0760a4ef85697bc756d06eae17ae27f3f055401",
            "https://git.kernel.org/stable/c/91c02557174be7f72e46ed7311e3bea1939840b0"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ncan: mcba_usb: fix memory leak in mcba_usb\n\nSyzbot reported memory leak in SocketCAN driver for Microchip CAN BUS\nAnalyzer Tool. The problem was in unfreed usb_coherent.\n\nIn mcba_usb_start() 20 coherent buffers are allocated and there is\nnothing, that frees them:\n\n1) In callback function the urb is resubmitted and that's all\n2) In disconnect function urbs are simply killed, but URB_FREE_BUFFER\n   is not set (see mcba_usb_start) and this flag cannot be used with\n   coherent buffers.\n\nFail log:\n| [ 1354.053291][ T8413] mcba_usb 1-1:0.0 can0: device disconnected\n| [ 1367.059384][ T8420] kmemleak: 20 new suspected memory leaks (see /sys/kernel/debug/kmem)\n\nSo, all allocated buffers should be freed with usb_free_coherent()\nexplicitly\n\nNOTE:\nThe same pattern for allocating and freeing coherent buffers\nis used in drivers/net/can/usb/kvaser_usb/kvaser_usb_core.c"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47247",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/b6447b72aca571632e71bb73a797118d5ce46a93",
            "https://git.kernel.org/stable/c/fb1a3132ee1ac968316e45d21a48703a6db0b6c3"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5e: Fix use-after-free of encap entry in neigh update handler\n\nFunction mlx5e_rep_neigh_update() wasn't updated to accommodate rtnl lock\nremoval from TC filter update path and properly handle concurrent encap\nentry insertion/deletion which can lead to following use-after-free:\n\n [23827.464923] ==================================================================\n [23827.469446] BUG: KASAN: use-after-free in mlx5e_encap_take+0x72/0x140 [mlx5_core]\n [23827.470971] Read of size 4 at addr ffff8881d132228c by task kworker/u20:6/21635\n [23827.472251]\n [23827.472615] CPU: 9 PID: 21635 Comm: kworker/u20:6 Not tainted 5.13.0-rc3+ #5\n [23827.473788] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\n [23827.475639] Workqueue: mlx5e mlx5e_rep_neigh_update [mlx5_core]\n [23827.476731] Call Trace:\n [23827.477260]  dump_stack+0xbb/0x107\n [23827.477906]  print_address_description.constprop.0+0x18/0x140\n [23827.478896]  ? mlx5e_encap_take+0x72/0x140 [mlx5_core]\n [23827.479879]  ? mlx5e_encap_take+0x72/0x140 [mlx5_core]\n [23827.480905]  kasan_report.cold+0x7c/0xd8\n [23827.481701]  ? mlx5e_encap_take+0x72/0x140 [mlx5_core]\n [23827.482744]  kasan_check_range+0x145/0x1a0\n [23827.493112]  mlx5e_encap_take+0x72/0x140 [mlx5_core]\n [23827.494054]  ? mlx5e_tc_tun_encap_info_equal_generic+0x140/0x140 [mlx5_core]\n [23827.495296]  mlx5e_rep_neigh_update+0x41e/0x5e0 [mlx5_core]\n [23827.496338]  ? mlx5e_rep_neigh_entry_release+0xb80/0xb80 [mlx5_core]\n [23827.497486]  ? read_word_at_a_time+0xe/0x20\n [23827.498250]  ? strscpy+0xa0/0x2a0\n [23827.498889]  process_one_work+0x8ac/0x14e0\n [23827.499638]  ? lockdep_hardirqs_on_prepare+0x400/0x400\n [23827.500537]  ? pwq_dec_nr_in_flight+0x2c0/0x2c0\n [23827.501359]  ? rwlock_bug.part.0+0x90/0x90\n [23827.502116]  worker_thread+0x53b/0x1220\n [23827.502831]  ? process_one_work+0x14e0/0x14e0\n [23827.503627]  kthread+0x328/0x3f0\n [23827.504254]  ? _raw_spin_unlock_irq+0x24/0x40\n [23827.505065]  ? __kthread_bind_mask+0x90/0x90\n [23827.505912]  ret_from_fork+0x1f/0x30\n [23827.506621]\n [23827.506987] Allocated by task 28248:\n [23827.507694]  kasan_save_stack+0x1b/0x40\n [23827.508476]  __kasan_kmalloc+0x7c/0x90\n [23827.509197]  mlx5e_attach_encap+0xde1/0x1d40 [mlx5_core]\n [23827.510194]  mlx5e_tc_add_fdb_flow+0x397/0xc40 [mlx5_core]\n [23827.511218]  __mlx5e_add_fdb_flow+0x519/0xb30 [mlx5_core]\n [23827.512234]  mlx5e_configure_flower+0x191c/0x4870 [mlx5_core]\n [23827.513298]  tc_setup_cb_add+0x1d5/0x420\n [23827.514023]  fl_hw_replace_filter+0x382/0x6a0 [cls_flower]\n [23827.514975]  fl_change+0x2ceb/0x4a51 [cls_flower]\n [23827.515821]  tc_new_tfilter+0x89a/0x2070\n [23827.516548]  rtnetlink_rcv_msg+0x644/0x8c0\n [23827.517300]  netlink_rcv_skb+0x11d/0x340\n [23827.518021]  netlink_unicast+0x42b/0x700\n [23827.518742]  netlink_sendmsg+0x743/0xc20\n [23827.519467]  sock_sendmsg+0xb2/0xe0\n [23827.520131]  ____sys_sendmsg+0x590/0x770\n [23827.520851]  ___sys_sendmsg+0xd8/0x160\n [23827.521552]  __sys_sendmsg+0xb7/0x140\n [23827.522238]  do_syscall_64+0x3a/0x70\n [23827.522907]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n [23827.523797]\n [23827.524163] Freed by task 25948:\n [23827.524780]  kasan_save_stack+0x1b/0x40\n [23827.525488]  kasan_set_track+0x1c/0x30\n [23827.526187]  kasan_set_free_info+0x20/0x30\n [23827.526968]  __kasan_slab_free+0xed/0x130\n [23827.527709]  slab_free_freelist_hook+0xcf/0x1d0\n [23827.528528]  kmem_cache_free_bulk+0x33a/0x6e0\n [23827.529317]  kfree_rcu_work+0x55f/0xb70\n [23827.530024]  process_one_work+0x8ac/0x14e0\n [23827.530770]  worker_thread+0x53b/0x1220\n [23827.531480]  kthread+0x328/0x3f0\n [23827.532114]  ret_from_fork+0x1f/0x30\n [23827.532785]\n [23827.533147] Last potentially related work creation:\n [23827.534007]  kasan_save_stack+0x1b/0x40\n [23827.534710]  kasan_record_aux_stack+0xab/0xc0\n [23827.535492]  kvfree_call_rcu+0x31/0x7b0\n [23827.536206]  mlx5e_tc_del\n---truncated---"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47224",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/6d120ab4dc39a543c6b63361e1d0541c382900a3",
            "https://git.kernel.org/stable/c/019ab7d044d0ebf97e1236bb8935b7809be92358",
            "https://git.kernel.org/stable/c/e8afe05bd359ebe12a61dbdc94c06c00ea3e8d4b",
            "https://git.kernel.org/stable/c/6aa32217a9a446275440ee8724b1ecaf1838df47"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ll_temac: Make sure to free skb when it is completely used\n\nWith the skb pointer piggy-backed on the TX BD, we have a simple and\nefficient way to free the skb buffer when the frame has been transmitted.\nBut in order to avoid freeing the skb while there are still fragments from\nthe skb in use, we need to piggy-back on the TX BD of the skb, not the\nfirst.\n\nWithout this, we are doing use-after-free on the DMA side, when the first\nBD of a multi TX BD packet is seen as completed in xmit_done, and the\nremaining BDs are still being processed."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47235",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/db2bc3cfd2bc01621014d4f17cdfc74611f339c8",
            "https://git.kernel.org/stable/c/1cafc540b7bf1b6a5a77dc000205fe337ef6eba6",
            "https://git.kernel.org/stable/c/b1ad283755095a4b9d1431aeb357d7df1a33d3bb",
            "https://git.kernel.org/stable/c/0260916843cc74f3906acf8b6f256693e01530a2",
            "https://git.kernel.org/stable/c/19f88ca68ccf8771276a606765239b167654f84a",
            "https://git.kernel.org/stable/c/95deeb29d831e2fae608439e243e7a520611e7ea",
            "https://git.kernel.org/stable/c/d11d79e52ba080ee567cb7d7eb42a5ade60a8130",
            "https://git.kernel.org/stable/c/9cca0c2d70149160407bda9a9446ce0c29b6e6c6"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ethernet: fix potential use-after-free in ec_bhf_remove\n\nstatic void ec_bhf_remove(struct pci_dev *dev)\n{\n...\n\tstruct ec_bhf_priv *priv = netdev_priv(net_dev);\n\n\tunregister_netdev(net_dev);\n\tfree_netdev(net_dev);\n\n\tpci_iounmap(dev, priv->dma_io);\n\tpci_iounmap(dev, priv->io);\n...\n}\n\npriv is netdev private data, but it is used\nafter free_netdev(). It can cause use-after-free when accessing priv\npointer. So, fix it by moving free_netdev() after pci_iounmap()\ncalls."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47247",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/b6447b72aca571632e71bb73a797118d5ce46a93",
            "https://git.kernel.org/stable/c/fb1a3132ee1ac968316e45d21a48703a6db0b6c3"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5e: Fix use-after-free of encap entry in neigh update handler\n\nFunction mlx5e_rep_neigh_update() wasn't updated to accommodate rtnl lock\nremoval from TC filter update path and properly handle concurrent encap\nentry insertion/deletion which can lead to following use-after-free:\n\n [23827.464923] ==================================================================\n [23827.469446] BUG: KASAN: use-after-free in mlx5e_encap_take+0x72/0x140 [mlx5_core]\n [23827.470971] Read of size 4 at addr ffff8881d132228c by task kworker/u20:6/21635\n [23827.472251]\n [23827.472615] CPU: 9 PID: 21635 Comm: kworker/u20:6 Not tainted 5.13.0-rc3+ #5\n [23827.473788] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\n [23827.475639] Workqueue: mlx5e mlx5e_rep_neigh_update [mlx5_core]\n [23827.476731] Call Trace:\n [23827.477260]  dump_stack+0xbb/0x107\n [23827.477906]  print_address_description.constprop.0+0x18/0x140\n [23827.478896]  ? mlx5e_encap_take+0x72/0x140 [mlx5_core]\n [23827.479879]  ? mlx5e_encap_take+0x72/0x140 [mlx5_core]\n [23827.480905]  kasan_report.cold+0x7c/0xd8\n [23827.481701]  ? mlx5e_encap_take+0x72/0x140 [mlx5_core]\n [23827.482744]  kasan_check_range+0x145/0x1a0\n [23827.493112]  mlx5e_encap_take+0x72/0x140 [mlx5_core]\n [23827.494054]  ? mlx5e_tc_tun_encap_info_equal_generic+0x140/0x140 [mlx5_core]\n [23827.495296]  mlx5e_rep_neigh_update+0x41e/0x5e0 [mlx5_core]\n [23827.496338]  ? mlx5e_rep_neigh_entry_release+0xb80/0xb80 [mlx5_core]\n [23827.497486]  ? read_word_at_a_time+0xe/0x20\n [23827.498250]  ? strscpy+0xa0/0x2a0\n [23827.498889]  process_one_work+0x8ac/0x14e0\n [23827.499638]  ? lockdep_hardirqs_on_prepare+0x400/0x400\n [23827.500537]  ? pwq_dec_nr_in_flight+0x2c0/0x2c0\n [23827.501359]  ? rwlock_bug.part.0+0x90/0x90\n [23827.502116]  worker_thread+0x53b/0x1220\n [23827.502831]  ? process_one_work+0x14e0/0x14e0\n [23827.503627]  kthread+0x328/0x3f0\n [23827.504254]  ? _raw_spin_unlock_irq+0x24/0x40\n [23827.505065]  ? __kthread_bind_mask+0x90/0x90\n [23827.505912]  ret_from_fork+0x1f/0x30\n [23827.506621]\n [23827.506987] Allocated by task 28248:\n [23827.507694]  kasan_save_stack+0x1b/0x40\n [23827.508476]  __kasan_kmalloc+0x7c/0x90\n [23827.509197]  mlx5e_attach_encap+0xde1/0x1d40 [mlx5_core]\n [23827.510194]  mlx5e_tc_add_fdb_flow+0x397/0xc40 [mlx5_core]\n [23827.511218]  __mlx5e_add_fdb_flow+0x519/0xb30 [mlx5_core]\n [23827.512234]  mlx5e_configure_flower+0x191c/0x4870 [mlx5_core]\n [23827.513298]  tc_setup_cb_add+0x1d5/0x420\n [23827.514023]  fl_hw_replace_filter+0x382/0x6a0 [cls_flower]\n [23827.514975]  fl_change+0x2ceb/0x4a51 [cls_flower]\n [23827.515821]  tc_new_tfilter+0x89a/0x2070\n [23827.516548]  rtnetlink_rcv_msg+0x644/0x8c0\n [23827.517300]  netlink_rcv_skb+0x11d/0x340\n [23827.518021]  netlink_unicast+0x42b/0x700\n [23827.518742]  netlink_sendmsg+0x743/0xc20\n [23827.519467]  sock_sendmsg+0xb2/0xe0\n [23827.520131]  ____sys_sendmsg+0x590/0x770\n [23827.520851]  ___sys_sendmsg+0xd8/0x160\n [23827.521552]  __sys_sendmsg+0xb7/0x140\n [23827.522238]  do_syscall_64+0x3a/0x70\n [23827.522907]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n [23827.523797]\n [23827.524163] Freed by task 25948:\n [23827.524780]  kasan_save_stack+0x1b/0x40\n [23827.525488]  kasan_set_track+0x1c/0x30\n [23827.526187]  kasan_set_free_info+0x20/0x30\n [23827.526968]  __kasan_slab_free+0xed/0x130\n [23827.527709]  slab_free_freelist_hook+0xcf/0x1d0\n [23827.528528]  kmem_cache_free_bulk+0x33a/0x6e0\n [23827.529317]  kfree_rcu_work+0x55f/0xb70\n [23827.530024]  process_one_work+0x8ac/0x14e0\n [23827.530770]  worker_thread+0x53b/0x1220\n [23827.531480]  kthread+0x328/0x3f0\n [23827.532114]  ret_from_fork+0x1f/0x30\n [23827.532785]\n [23827.533147] Last potentially related work creation:\n [23827.534007]  kasan_save_stack+0x1b/0x40\n [23827.534710]  kasan_record_aux_stack+0xab/0xc0\n [23827.535492]  kvfree_call_rcu+0x31/0x7b0\n [23827.536206]  mlx5e_tc_del\n---truncated---"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47250",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/212166510582631994be4f4b3fe15e10a03c1dd4",
            "https://git.kernel.org/stable/c/086e92b1d68c6338535f715aad173f8cf4bfbc8c",
            "https://git.kernel.org/stable/c/6dcea66d3bb519b426282588f38e884e07893c1f",
            "https://git.kernel.org/stable/c/5340858147e3dc60913fb3dd0cbb758ec4a26e66",
            "https://git.kernel.org/stable/c/398a24447eb60f060c8994221cb5ae6caf355fa1",
            "https://git.kernel.org/stable/c/deeeb65c6ee404f2d1fb80b38b2730645c0f4663",
            "https://git.kernel.org/stable/c/0ffb460be3abac86f884a8c548bb02724ec370f4",
            "https://git.kernel.org/stable/c/d612c3f3fae221e7ea736d196581c2217304bbbc"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ipv4: fix memory leak in netlbl_cipsov4_add_std\n\nReported by syzkaller:\nBUG: memory leak\nunreferenced object 0xffff888105df7000 (size 64):\ncomm \"syz-executor842\", pid 360, jiffies 4294824824 (age 22.546s)\nhex dump (first 32 bytes):\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\nbacktrace:\n[<00000000e67ed558>] kmalloc include/linux/slab.h:590 [inline]\n[<00000000e67ed558>] kzalloc include/linux/slab.h:720 [inline]\n[<00000000e67ed558>] netlbl_cipsov4_add_std net/netlabel/netlabel_cipso_v4.c:145 [inline]\n[<00000000e67ed558>] netlbl_cipsov4_add+0x390/0x2340 net/netlabel/netlabel_cipso_v4.c:416\n[<0000000006040154>] genl_family_rcv_msg_doit.isra.0+0x20e/0x320 net/netlink/genetlink.c:739\n[<00000000204d7a1c>] genl_family_rcv_msg net/netlink/genetlink.c:783 [inline]\n[<00000000204d7a1c>] genl_rcv_msg+0x2bf/0x4f0 net/netlink/genetlink.c:800\n[<00000000c0d6a995>] netlink_rcv_skb+0x134/0x3d0 net/netlink/af_netlink.c:2504\n[<00000000d78b9d2c>] genl_rcv+0x24/0x40 net/netlink/genetlink.c:811\n[<000000009733081b>] netlink_unicast_kernel net/netlink/af_netlink.c:1314 [inline]\n[<000000009733081b>] netlink_unicast+0x4a0/0x6a0 net/netlink/af_netlink.c:1340\n[<00000000d5fd43b8>] netlink_sendmsg+0x789/0xc70 net/netlink/af_netlink.c:1929\n[<000000000a2d1e40>] sock_sendmsg_nosec net/socket.c:654 [inline]\n[<000000000a2d1e40>] sock_sendmsg+0x139/0x170 net/socket.c:674\n[<00000000321d1969>] ____sys_sendmsg+0x658/0x7d0 net/socket.c:2350\n[<00000000964e16bc>] ___sys_sendmsg+0xf8/0x170 net/socket.c:2404\n[<000000001615e288>] __sys_sendmsg+0xd3/0x190 net/socket.c:2433\n[<000000004ee8b6a5>] do_syscall_64+0x37/0x90 arch/x86/entry/common.c:47\n[<00000000171c7cee>] entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nThe memory of doi_def->map.std pointing is allocated in\nnetlbl_cipsov4_add_std, but no place has freed it. It should be\nfreed in cipso_v4_doi_free which frees the cipso DOI resource."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47241",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/fb3a948143688e14e2cfd2a2812877923d0e5e92",
            "https://git.kernel.org/stable/c/cfc7f0e70d649e6d2233fba0d9390b525677d971",
            "https://git.kernel.org/stable/c/e175aef902697826d344ce3a12189329848fe898"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nethtool: strset: fix message length calculation\n\nOuter nest for ETHTOOL_A_STRSET_STRINGSETS is not accounted for.\nThis may result in ETHTOOL_MSG_STRSET_GET producing a warning like:\n\n    calculated message payload length (684) not sufficient\n    WARNING: CPU: 0 PID: 30967 at net/ethtool/netlink.c:369 ethnl_default_doit+0x87a/0xa20\n\nand a splat.\n\nAs usually with such warnings three conditions must be met for the warning\nto trigger:\n - there must be no skb size rounding up (e.g. reply_size of 684);\n - string set must be per-device (so that the header gets populated);\n - the device name must be at least 12 characters long.\n\nall in all with current user space it looks like reading priv flags\nis the only place this could potentially happen. Or with syzbot :)"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47242",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/27ef25c72373222aaa5fe7b5cd890ae9cfb89a8d",
            "https://git.kernel.org/stable/c/499ada5073361c631f2a3c4a8aed44d53b6f82ec"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmptcp: fix soft lookup in subflow_error_report()\n\nMaxim reported a soft lookup in subflow_error_report():\n\n watchdog: BUG: soft lockup - CPU#0 stuck for 22s! [swapper/0:0]\n RIP: 0010:native_queued_spin_lock_slowpath\n RSP: 0018:ffffa859c0003bc0 EFLAGS: 00000202\n RAX: 0000000000000101 RBX: 0000000000000001 RCX: 0000000000000000\n RDX: ffff9195c2772d88 RSI: 0000000000000000 RDI: ffff9195c2772d88\n RBP: ffff9195c2772d00 R08: 00000000000067b0 R09: c6e31da9eb1e44f4\n R10: ffff9195ef379700 R11: ffff9195edb50710 R12: ffff9195c2772d88\n R13: ffff9195f500e3d0 R14: ffff9195ef379700 R15: ffff9195ef379700\n FS:  0000000000000000(0000) GS:ffff91961f400000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 000000c000407000 CR3: 0000000002988000 CR4: 00000000000006f0\n Call Trace:\n  <IRQ>\n _raw_spin_lock_bh\n subflow_error_report\n mptcp_subflow_data_available\n __mptcp_move_skbs_from_subflow\n mptcp_data_ready\n tcp_data_queue\n tcp_rcv_established\n tcp_v4_do_rcv\n tcp_v4_rcv\n ip_protocol_deliver_rcu\n ip_local_deliver_finish\n __netif_receive_skb_one_core\n netif_receive_skb\n rtl8139_poll 8139too\n __napi_poll\n net_rx_action\n __do_softirq\n __irq_exit_rcu\n common_interrupt\n  </IRQ>\n\nThe calling function - mptcp_subflow_data_available() - can be invoked\nfrom different contexts:\n- plain ssk socket lock\n- ssk socket lock + mptcp_data_lock\n- ssk socket lock + mptcp_data_lock + msk socket lock.\n\nSince subflow_error_report() tries to acquire the mptcp_data_lock, the\nlatter two call chains will cause soft lookup.\n\nThis change addresses the issue moving the error reporting call to\nouter functions, where the held locks list is known and the we can\nacquire only the needed one."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47248",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/e3c36c773aed0fef8b1d3d555b43393ec564400f",
            "https://git.kernel.org/stable/c/a0882f68f54f7a8b6308261acee9bd4faab5a69e",
            "https://git.kernel.org/stable/c/2f73448041bd0682d4b552cfd314ace66107f1ad",
            "https://git.kernel.org/stable/c/5a88477c1c85e4baa51e91f2d40f2166235daa56",
            "https://git.kernel.org/stable/c/8729ec8a2238152a4afc212a331a6cd2c61aeeac",
            "https://git.kernel.org/stable/c/65310b0aff86980a011c7c7bfa487a333d4ca241",
            "https://git.kernel.org/stable/c/a8b897c7bcd47f4147d066e22cc01d1026d7640e"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nudp: fix race between close() and udp_abort()\n\nKaustubh reported and diagnosed a panic in udp_lib_lookup().\nThe root cause is udp_abort() racing with close(). Both\nracing functions acquire the socket lock, but udp{v6}_destroy_sock()\nrelease it before performing destructive actions.\n\nWe can't easily extend the socket lock scope to avoid the race,\ninstead use the SOCK_DEAD flag to prevent udp_abort from doing\nany action when the critical race happens.\n\nDiagnosed-and-tested-by: Kaustubh Pandey <kapandey@codeaurora.org>"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47250",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/212166510582631994be4f4b3fe15e10a03c1dd4",
            "https://git.kernel.org/stable/c/086e92b1d68c6338535f715aad173f8cf4bfbc8c",
            "https://git.kernel.org/stable/c/6dcea66d3bb519b426282588f38e884e07893c1f",
            "https://git.kernel.org/stable/c/5340858147e3dc60913fb3dd0cbb758ec4a26e66",
            "https://git.kernel.org/stable/c/398a24447eb60f060c8994221cb5ae6caf355fa1",
            "https://git.kernel.org/stable/c/deeeb65c6ee404f2d1fb80b38b2730645c0f4663",
            "https://git.kernel.org/stable/c/0ffb460be3abac86f884a8c548bb02724ec370f4",
            "https://git.kernel.org/stable/c/d612c3f3fae221e7ea736d196581c2217304bbbc"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ipv4: fix memory leak in netlbl_cipsov4_add_std\n\nReported by syzkaller:\nBUG: memory leak\nunreferenced object 0xffff888105df7000 (size 64):\ncomm \"syz-executor842\", pid 360, jiffies 4294824824 (age 22.546s)\nhex dump (first 32 bytes):\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\nbacktrace:\n[<00000000e67ed558>] kmalloc include/linux/slab.h:590 [inline]\n[<00000000e67ed558>] kzalloc include/linux/slab.h:720 [inline]\n[<00000000e67ed558>] netlbl_cipsov4_add_std net/netlabel/netlabel_cipso_v4.c:145 [inline]\n[<00000000e67ed558>] netlbl_cipsov4_add+0x390/0x2340 net/netlabel/netlabel_cipso_v4.c:416\n[<0000000006040154>] genl_family_rcv_msg_doit.isra.0+0x20e/0x320 net/netlink/genetlink.c:739\n[<00000000204d7a1c>] genl_family_rcv_msg net/netlink/genetlink.c:783 [inline]\n[<00000000204d7a1c>] genl_rcv_msg+0x2bf/0x4f0 net/netlink/genetlink.c:800\n[<00000000c0d6a995>] netlink_rcv_skb+0x134/0x3d0 net/netlink/af_netlink.c:2504\n[<00000000d78b9d2c>] genl_rcv+0x24/0x40 net/netlink/genetlink.c:811\n[<000000009733081b>] netlink_unicast_kernel net/netlink/af_netlink.c:1314 [inline]\n[<000000009733081b>] netlink_unicast+0x4a0/0x6a0 net/netlink/af_netlink.c:1340\n[<00000000d5fd43b8>] netlink_sendmsg+0x789/0xc70 net/netlink/af_netlink.c:1929\n[<000000000a2d1e40>] sock_sendmsg_nosec net/socket.c:654 [inline]\n[<000000000a2d1e40>] sock_sendmsg+0x139/0x170 net/socket.c:674\n[<00000000321d1969>] ____sys_sendmsg+0x658/0x7d0 net/socket.c:2350\n[<00000000964e16bc>] ___sys_sendmsg+0xf8/0x170 net/socket.c:2404\n[<000000001615e288>] __sys_sendmsg+0xd3/0x190 net/socket.c:2433\n[<000000004ee8b6a5>] do_syscall_64+0x37/0x90 arch/x86/entry/common.c:47\n[<00000000171c7cee>] entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nThe memory of doi_def->map.std pointing is allocated in\nnetlbl_cipsov4_add_std, but no place has freed it. It should be\nfreed in cipso_v4_doi_free which frees the cipso DOI resource."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47245",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/e1eb98cfeafdd85537e7e3cefe93ca9bfbcc3ea8",
            "https://git.kernel.org/stable/c/576c1526b4d83c44ad7b673cb841f36cbc6cb6c4",
            "https://git.kernel.org/stable/c/674b5f0c6a4fc5d3abce877048290cea6091fcb1",
            "https://git.kernel.org/stable/c/7d9a9a1a88a3da574e019b4de756bc73337b3b0b",
            "https://git.kernel.org/stable/c/6defc77d48eff74075b80ad5925061b2fc010d98",
            "https://git.kernel.org/stable/c/9cdf299ba4e153b5e56187648420de22c6216f02",
            "https://git.kernel.org/stable/c/f648089337cb8ed40b2bb96e244f72b9d97dc96b",
            "https://git.kernel.org/stable/c/5fc177ab759418c9537433e63301096e733fb915"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: synproxy: Fix out of bounds when parsing TCP options\n\nThe TCP option parser in synproxy (synproxy_parse_options) could read\none byte out of bounds. When the length is 1, the execution flow gets\ninto the loop, reads one byte of the opcode, and if the opcode is\nneither TCPOPT_EOL nor TCPOPT_NOP, it reads one more byte, which exceeds\nthe length of 1.\n\nThis fix is inspired by commit 9609dad263f8 (\"ipv4: tcp_input: fix stack\nout of bounds when parsing TCP options.\").\n\nv2 changes:\n\nAdded an early return when length < 0 to avoid calling\nskb_header_pointer with negative length."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47259",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/c7eab9e2d7b4e983ce280276fb920af649955897",
            "https://git.kernel.org/stable/c/42c10b0db064e45f5c5ae7019bbf2168ffab766c",
            "https://git.kernel.org/stable/c/3e3c7ebbfac152d08be75c92802a64a1f6471a15",
            "https://git.kernel.org/stable/c/c3b6cf64dfe4ef96e7341508d50d6998da7062c7",
            "https://git.kernel.org/stable/c/72651c6579a25317a90536181d311c663d0329ab",
            "https://git.kernel.org/stable/c/476bdb04c501fc64bf3b8464ffddefc8dbe01577"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFS: Fix use-after-free in nfs4_init_client()\n\nKASAN reports a use-after-free when attempting to mount two different\nexports through two different NICs that belong to the same server.\n\nOlga was able to hit this with kernels starting somewhere between 5.7\nand 5.10, but I traced the patch that introduced the clear_bit() call to\n4.13. So something must have changed in the refcounting of the clp\npointer to make this call to nfs_put_client() the very last one."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47257",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/1f95741981c899c4724647291fec5faa3c777185",
            "https://git.kernel.org/stable/c/c6998ccfefa652bac3f9b236821e392af43efa1e",
            "https://git.kernel.org/stable/c/5f728ec65485625e30f46e5b4917ff023ad29ea0",
            "https://git.kernel.org/stable/c/d0f47648b87b6d5f204cb7f3cbce6d36dab85a67",
            "https://git.kernel.org/stable/c/c7836de2cadd88bc2f20f2c5a3d4ef4c73aef627",
            "https://git.kernel.org/stable/c/fdd51e34f45311ab6e48d2147cbc2904731b9993",
            "https://git.kernel.org/stable/c/9fdd04918a452980631ecc499317881c1d120b70"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ieee802154: fix null deref in parse dev addr\n\nFix a logic error that could result in a null deref if the user sets\nthe mode incorrectly for the given addr type."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47251",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/5a1cd67a801cf5ef989c4783e07b86a25b143126",
            "https://git.kernel.org/stable/c/d1b949c70206178b12027f66edc088d40375b5cb",
            "https://git.kernel.org/stable/c/e298aa358f0ca658406d524b6639fe389cb6e11e"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmac80211: fix skb length check in ieee80211_scan_rx()\n\nReplace hard-coded compile-time constants for header length check\nwith dynamic determination based on the frame type. Otherwise, we\nhit a validation WARN_ON in cfg80211 later.\n\n[style fixes, reword commit message]"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47268",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/18eaf0de50eadeeb395b83310b259b21ad8ed0a6",
            "https://git.kernel.org/stable/c/d0a06696a8a4d99f649240b6f9b8a2e55452ecf5",
            "https://git.kernel.org/stable/c/3a13ff7ef4349d70d1d18378d661117dd5af8efe"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: typec: tcpm: cancel vdm and state machine hrtimer when unregister tcpm port\n\nA pending hrtimer may expire after the kthread_worker of tcpm port\nis destroyed, see below kernel dump when do module unload, fix it\nby cancel the 2 hrtimers.\n\n[  111.517018] Unable to handle kernel paging request at virtual address ffff8000118cb880\n[  111.518786] blk_update_request: I/O error, dev sda, sector 60061185 op 0x0:(READ) flags 0x0 phys_seg 1 prio class 0\n[  111.526594] Mem abort info:\n[  111.526597]   ESR = 0x96000047\n[  111.526600]   EC = 0x25: DABT (current EL), IL = 32 bits\n[  111.526604]   SET = 0, FnV = 0\n[  111.526607]   EA = 0, S1PTW = 0\n[  111.526610] Data abort info:\n[  111.526612]   ISV = 0, ISS = 0x00000047\n[  111.526615]   CM = 0, WnR = 1\n[  111.526619] swapper pgtable: 4k pages, 48-bit VAs, pgdp=0000000041d75000\n[  111.526623] [ffff8000118cb880] pgd=10000001bffff003, p4d=10000001bffff003, pud=10000001bfffe003, pmd=10000001bfffa003, pte=0000000000000000\n[  111.526642] Internal error: Oops: 96000047 [#1] PREEMPT SMP\n[  111.526647] Modules linked in: dwc3_imx8mp dwc3 phy_fsl_imx8mq_usb [last unloaded: tcpci]\n[  111.526663] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.13.0-rc4-00927-gebbe9dbd802c-dirty #36\n[  111.526670] Hardware name: NXP i.MX8MPlus EVK board (DT)\n[  111.526674] pstate: 800000c5 (Nzcv daIF -PAN -UAO -TCO BTYPE=--)\n[  111.526681] pc : queued_spin_lock_slowpath+0x1a0/0x390\n[  111.526695] lr : _raw_spin_lock_irqsave+0x88/0xb4\n[  111.526703] sp : ffff800010003e20\n[  111.526706] x29: ffff800010003e20 x28: ffff00017f380180\n[  111.537156] buffer_io_error: 6 callbacks suppressed\n[  111.537162] Buffer I/O error on dev sda1, logical block 60040704, async page read\n[  111.539932]  x27: ffff00017f3801c0\n[  111.539938] x26: ffff800010ba2490 x25: 0000000000000000 x24: 0000000000000001\n[  111.543025] blk_update_request: I/O error, dev sda, sector 60061186 op 0x0:(READ) flags 0x0 phys_seg 7 prio class 0\n[  111.548304]\n[  111.548306] x23: 00000000000000c0 x22: ffff0000c2a9f184 x21: ffff00017f380180\n[  111.551374] Buffer I/O error on dev sda1, logical block 60040705, async page read\n[  111.554499]\n[  111.554503] x20: ffff0000c5f14210 x19: 00000000000000c0 x18: 0000000000000000\n[  111.557391] Buffer I/O error on dev sda1, logical block 60040706, async page read\n[  111.561218]\n[  111.561222] x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000\n[  111.564205] Buffer I/O error on dev sda1, logical block 60040707, async page read\n[  111.570887] x14: 00000000000000f5 x13: 0000000000000001 x12: 0000000000000040\n[  111.570902] x11: ffff0000c05ac6d8\n[  111.583420] Buffer I/O error on dev sda1, logical block 60040708, async page read\n[  111.588978]  x10: 0000000000000000 x9 : 0000000000040000\n[  111.588988] x8 : 0000000000000000\n[  111.597173] Buffer I/O error on dev sda1, logical block 60040709, async page read\n[  111.605766]  x7 : ffff00017f384880 x6 : ffff8000118cb880\n[  111.605777] x5 : ffff00017f384880\n[  111.611094] Buffer I/O error on dev sda1, logical block 60040710, async page read\n[  111.617086]  x4 : 0000000000000000 x3 : ffff0000c2a9f184\n[  111.617096] x2 : ffff8000118cb880\n[  111.622242] Buffer I/O error on dev sda1, logical block 60040711, async page read\n[  111.626927]  x1 : ffff8000118cb880 x0 : ffff00017f384888\n[  111.626938] Call trace:\n[  111.626942]  queued_spin_lock_slowpath+0x1a0/0x390\n[  111.795809]  kthread_queue_work+0x30/0xc0\n[  111.799828]  state_machine_timer_handler+0x20/0x30\n[  111.804624]  __hrtimer_run_queues+0x140/0x1e0\n[  111.808990]  hrtimer_interrupt+0xec/0x2c0\n[  111.813004]  arch_timer_handler_phys+0x38/0x50\n[  111.817456]  handle_percpu_devid_irq+0x88/0x150\n[  111.821991]  __handle_domain_irq+0x80/0xe0\n[  111.826093]  gic_handle_irq+0xc0/0x140\n[  111.829848]  el1_irq+0xbc/0x154\n[  111.832991]  arch_cpu_idle+0x1c/0x2c\n[  111.836572]  default_idle_call+0x24/0x6c\n[  111.840497]  do_idle+0x238/0x2ac\n[  1\n---truncated---"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47255",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/bf99ea52970caeb4583bdba1192c1f9b53b12c84",
            "https://git.kernel.org/stable/c/018685461a5b9a9a70e664ac77aef0d7415a3fd5",
            "https://git.kernel.org/stable/c/a2aff09807fbe4018c269d3773a629949058b210",
            "https://git.kernel.org/stable/c/218bf772bddd221489c38dde6ef8e917131161f6"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nkvm: LAPIC: Restore guard to prevent illegal APIC register access\n\nPer the SDM, \"any access that touches bytes 4 through 15 of an APIC\nregister may cause undefined behavior and must not be executed.\"\nWorse, such an access in kvm_lapic_reg_read can result in a leak of\nkernel stack contents. Prior to commit 01402cf81051 (\"kvm: LAPIC:\nwrite down valid APIC registers\"), such an access was explicitly\ndisallowed. Restore the guard that was removed in that commit."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47267",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/fd24be23abf3e94260be0f00bb42c7e91d495f87",
            "https://git.kernel.org/stable/c/70cd19cb5bd94bbb5bacfc9c1e4ee0071699a604",
            "https://git.kernel.org/stable/c/45f9a2fe737dc0a5df270787f2231aee8985cd59",
            "https://git.kernel.org/stable/c/5ef23506695b01d5d56a13a092a97f2478069d75",
            "https://git.kernel.org/stable/c/b972eff874637402ddc4a7dd11fb22538a0b6d28",
            "https://git.kernel.org/stable/c/ca6bc277430d90375452b60b047763a090b7673e",
            "https://git.kernel.org/stable/c/032e288097a553db5653af552dd8035cd2a0ba96"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: fix various gadget panics on 10gbps cabling\n\nusb_assign_descriptors() is called with 5 parameters,\nthe last 4 of which are the usb_descriptor_header for:\n  full-speed (USB1.1 - 12Mbps [including USB1.0 low-speed @ 1.5Mbps),\n  high-speed (USB2.0 - 480Mbps),\n  super-speed (USB3.0 - 5Gbps),\n  super-speed-plus (USB3.1 - 10Gbps).\n\nThe differences between full/high/super-speed descriptors are usually\nsubstantial (due to changes in the maximum usb block size from 64 to 512\nto 1024 bytes and other differences in the specs), while the difference\nbetween 5 and 10Gbps descriptors may be as little as nothing\n(in many cases the same tuning is simply good enough).\n\nHowever if a gadget driver calls usb_assign_descriptors() with\na NULL descriptor for super-speed-plus and is then used on a max 10gbps\nconfiguration, the kernel will crash with a null pointer dereference,\nwhen a 10gbps capable device port + cable + host port combination shows up.\n(This wouldn't happen if the gadget max-speed was set to 5gbps, but\nit of course defaults to the maximum, and there's no real reason to\nartificially limit it)\n\nThe fix is to simply use the 5gbps descriptor as the 10gbps descriptor,\nif a 10gbps descriptor wasn't provided.\n\nObviously this won't fix the problem if the 5gbps descriptor is also\nNULL, but such cases can't be so trivially solved (and any such gadgets\nare unlikely to be used with USB3 ports any way)."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47268",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/18eaf0de50eadeeb395b83310b259b21ad8ed0a6",
            "https://git.kernel.org/stable/c/d0a06696a8a4d99f649240b6f9b8a2e55452ecf5",
            "https://git.kernel.org/stable/c/3a13ff7ef4349d70d1d18378d661117dd5af8efe"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: typec: tcpm: cancel vdm and state machine hrtimer when unregister tcpm port\n\nA pending hrtimer may expire after the kthread_worker of tcpm port\nis destroyed, see below kernel dump when do module unload, fix it\nby cancel the 2 hrtimers.\n\n[  111.517018] Unable to handle kernel paging request at virtual address ffff8000118cb880\n[  111.518786] blk_update_request: I/O error, dev sda, sector 60061185 op 0x0:(READ) flags 0x0 phys_seg 1 prio class 0\n[  111.526594] Mem abort info:\n[  111.526597]   ESR = 0x96000047\n[  111.526600]   EC = 0x25: DABT (current EL), IL = 32 bits\n[  111.526604]   SET = 0, FnV = 0\n[  111.526607]   EA = 0, S1PTW = 0\n[  111.526610] Data abort info:\n[  111.526612]   ISV = 0, ISS = 0x00000047\n[  111.526615]   CM = 0, WnR = 1\n[  111.526619] swapper pgtable: 4k pages, 48-bit VAs, pgdp=0000000041d75000\n[  111.526623] [ffff8000118cb880] pgd=10000001bffff003, p4d=10000001bffff003, pud=10000001bfffe003, pmd=10000001bfffa003, pte=0000000000000000\n[  111.526642] Internal error: Oops: 96000047 [#1] PREEMPT SMP\n[  111.526647] Modules linked in: dwc3_imx8mp dwc3 phy_fsl_imx8mq_usb [last unloaded: tcpci]\n[  111.526663] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.13.0-rc4-00927-gebbe9dbd802c-dirty #36\n[  111.526670] Hardware name: NXP i.MX8MPlus EVK board (DT)\n[  111.526674] pstate: 800000c5 (Nzcv daIF -PAN -UAO -TCO BTYPE=--)\n[  111.526681] pc : queued_spin_lock_slowpath+0x1a0/0x390\n[  111.526695] lr : _raw_spin_lock_irqsave+0x88/0xb4\n[  111.526703] sp : ffff800010003e20\n[  111.526706] x29: ffff800010003e20 x28: ffff00017f380180\n[  111.537156] buffer_io_error: 6 callbacks suppressed\n[  111.537162] Buffer I/O error on dev sda1, logical block 60040704, async page read\n[  111.539932]  x27: ffff00017f3801c0\n[  111.539938] x26: ffff800010ba2490 x25: 0000000000000000 x24: 0000000000000001\n[  111.543025] blk_update_request: I/O error, dev sda, sector 60061186 op 0x0:(READ) flags 0x0 phys_seg 7 prio class 0\n[  111.548304]\n[  111.548306] x23: 00000000000000c0 x22: ffff0000c2a9f184 x21: ffff00017f380180\n[  111.551374] Buffer I/O error on dev sda1, logical block 60040705, async page read\n[  111.554499]\n[  111.554503] x20: ffff0000c5f14210 x19: 00000000000000c0 x18: 0000000000000000\n[  111.557391] Buffer I/O error on dev sda1, logical block 60040706, async page read\n[  111.561218]\n[  111.561222] x17: 0000000000000000 x16: 0000000000000000 x15: 0000000000000000\n[  111.564205] Buffer I/O error on dev sda1, logical block 60040707, async page read\n[  111.570887] x14: 00000000000000f5 x13: 0000000000000001 x12: 0000000000000040\n[  111.570902] x11: ffff0000c05ac6d8\n[  111.583420] Buffer I/O error on dev sda1, logical block 60040708, async page read\n[  111.588978]  x10: 0000000000000000 x9 : 0000000000040000\n[  111.588988] x8 : 0000000000000000\n[  111.597173] Buffer I/O error on dev sda1, logical block 60040709, async page read\n[  111.605766]  x7 : ffff00017f384880 x6 : ffff8000118cb880\n[  111.605777] x5 : ffff00017f384880\n[  111.611094] Buffer I/O error on dev sda1, logical block 60040710, async page read\n[  111.617086]  x4 : 0000000000000000 x3 : ffff0000c2a9f184\n[  111.617096] x2 : ffff8000118cb880\n[  111.622242] Buffer I/O error on dev sda1, logical block 60040711, async page read\n[  111.626927]  x1 : ffff8000118cb880 x0 : ffff00017f384888\n[  111.626938] Call trace:\n[  111.626942]  queued_spin_lock_slowpath+0x1a0/0x390\n[  111.795809]  kthread_queue_work+0x30/0xc0\n[  111.799828]  state_machine_timer_handler+0x20/0x30\n[  111.804624]  __hrtimer_run_queues+0x140/0x1e0\n[  111.808990]  hrtimer_interrupt+0xec/0x2c0\n[  111.813004]  arch_timer_handler_phys+0x38/0x50\n[  111.817456]  handle_percpu_devid_irq+0x88/0x150\n[  111.821991]  __handle_domain_irq+0x80/0xe0\n[  111.826093]  gic_handle_irq+0xc0/0x140\n[  111.829848]  el1_irq+0xbc/0x154\n[  111.832991]  arch_cpu_idle+0x1c/0x2c\n[  111.836572]  default_idle_call+0x24/0x6c\n[  111.840497]  do_idle+0x238/0x2ac\n[  1\n---truncated---"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47271",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/ae746b6f4ce619cf4032fd798a232b010907a397",
            "https://git.kernel.org/stable/c/a9aecef198faae3240921b707bc09b602e966fce"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: cdnsp: Fix deadlock issue in cdnsp_thread_irq_handler\n\nPatch fixes the following critical issue caused by deadlock which has been\ndetected during testing NCM class:\n\nsmp: csd: Detected non-responsive CSD lock (#1) on CPU#0\nsmp:     csd: CSD lock (#1) unresponsive.\n....\nRIP: 0010:native_queued_spin_lock_slowpath+0x61/0x1d0\nRSP: 0018:ffffbc494011cde0 EFLAGS: 00000002\nRAX: 0000000000000101 RBX: ffff9ee8116b4a68 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff9ee8116b4658\nRBP: ffffbc494011cde0 R08: 0000000000000001 R09: 0000000000000000\nR10: ffff9ee8116b4670 R11: 0000000000000000 R12: ffff9ee8116b4658\nR13: ffff9ee8116b4670 R14: 0000000000000246 R15: ffff9ee8116b4658\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f7bcc41a830 CR3: 000000007a612003 CR4: 00000000001706e0\nCall Trace:\n <IRQ>\n do_raw_spin_lock+0xc0/0xd0\n _raw_spin_lock_irqsave+0x95/0xa0\n cdnsp_gadget_ep_queue.cold+0x88/0x107 [cdnsp_udc_pci]\n usb_ep_queue+0x35/0x110\n eth_start_xmit+0x220/0x3d0 [u_ether]\n ncm_tx_timeout+0x34/0x40 [usb_f_ncm]\n ? ncm_free_inst+0x50/0x50 [usb_f_ncm]\n __hrtimer_run_queues+0xac/0x440\n hrtimer_run_softirq+0x8c/0xb0\n __do_softirq+0xcf/0x428\n asm_call_irq_on_stack+0x12/0x20\n </IRQ>\n do_softirq_own_stack+0x61/0x70\n irq_exit_rcu+0xc1/0xd0\n sysvec_apic_timer_interrupt+0x52/0xb0\n asm_sysvec_apic_timer_interrupt+0x12/0x20\nRIP: 0010:do_raw_spin_trylock+0x18/0x40\nRSP: 0018:ffffbc494138bda8 EFLAGS: 00000246\nRAX: 0000000000000000 RBX: ffff9ee8116b4658 RCX: 0000000000000000\nRDX: 0000000000000001 RSI: 0000000000000000 RDI: ffff9ee8116b4658\nRBP: ffffbc494138bda8 R08: 0000000000000001 R09: 0000000000000000\nR10: ffff9ee8116b4670 R11: 0000000000000000 R12: ffff9ee8116b4658\nR13: ffff9ee8116b4670 R14: ffff9ee7b5c73d80 R15: ffff9ee8116b4000\n _raw_spin_lock+0x3d/0x70\n ? cdnsp_thread_irq_handler.cold+0x32/0x112c [cdnsp_udc_pci]\n cdnsp_thread_irq_handler.cold+0x32/0x112c [cdnsp_udc_pci]\n ? cdnsp_remove_request+0x1f0/0x1f0 [cdnsp_udc_pci]\n ? cdnsp_thread_irq_handler+0x5/0xa0 [cdnsp_udc_pci]\n ? irq_thread+0xa0/0x1c0\n irq_thread_fn+0x28/0x60\n irq_thread+0x105/0x1c0\n ? __kthread_parkme+0x42/0x90\n ? irq_forced_thread_fn+0x90/0x90\n ? wake_threads_waitq+0x30/0x30\n ? irq_thread_check_affinity+0xe0/0xe0\n kthread+0x12a/0x160\n ? kthread_park+0x90/0x90\n ret_from_fork+0x22/0x30\n\nThe root cause of issue is spin_lock/spin_unlock instruction instead\nspin_lock_irqsave/spin_lock_irqrestore in cdnsp_thread_irq_handler\nfunction."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47262",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/796d3bd4ac9316e70c181189318cd2bd98af34bc",
            "https://git.kernel.org/stable/c/d046f724bbd725a24007b7e52b2d675249870888",
            "https://git.kernel.org/stable/c/9fb088ce13bc3c59a51260207b487db3e556f275",
            "https://git.kernel.org/stable/c/f31500b0d437a2464ca5972d8f5439e156b74960"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86: Ensure liveliness of nested VM-Enter fail tracepoint message\n\nUse the __string() machinery provided by the tracing subystem to make a\ncopy of the string literals consumed by the \"nested VM-Enter failed\"\ntracepoint.  A complete copy is necessary to ensure that the tracepoint\ncan't outlive the data/memory it consumes and deference stale memory.\n\nBecause the tracepoint itself is defined by kvm, if kvm-intel and/or\nkvm-amd are built as modules, the memory holding the string literals\ndefined by the vendor modules will be freed when the module is unloaded,\nwhereas the tracepoint and its data in the ring buffer will live until\nkvm is unloaded (or \"indefinitely\" if kvm is built-in).\n\nThis bug has existed since the tracepoint was added, but was recently\nexposed by a new check in tracing to detect exactly this type of bug.\n\n  fmt: '%s%s\n  ' current_buffer: ' vmx_dirty_log_t-140127  [003] ....  kvm_nested_vmenter_failed: '\n  WARNING: CPU: 3 PID: 140134 at kernel/trace/trace.c:3759 trace_check_vprintf+0x3be/0x3e0\n  CPU: 3 PID: 140134 Comm: less Not tainted 5.13.0-rc1-ce2e73ce600a-req #184\n  Hardware name: ASUS Q87M-E/Q87M-E, BIOS 1102 03/03/2014\n  RIP: 0010:trace_check_vprintf+0x3be/0x3e0\n  Code: <0f> 0b 44 8b 4c 24 1c e9 a9 fe ff ff c6 44 02 ff 00 49 8b 97 b0 20\n  RSP: 0018:ffffa895cc37bcb0 EFLAGS: 00010282\n  RAX: 0000000000000000 RBX: ffffa895cc37bd08 RCX: 0000000000000027\n  RDX: 0000000000000027 RSI: 00000000ffffdfff RDI: ffff9766cfad74f8\n  RBP: ffffffffc0a041d4 R08: ffff9766cfad74f0 R09: ffffa895cc37bad8\n  R10: 0000000000000001 R11: 0000000000000001 R12: ffffffffc0a041d4\n  R13: ffffffffc0f4dba8 R14: 0000000000000000 R15: ffff976409f2c000\n  FS:  00007f92fa200740(0000) GS:ffff9766cfac0000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 0000559bd11b0000 CR3: 000000019fbaa002 CR4: 00000000001726e0\n  Call Trace:\n   trace_event_printf+0x5e/0x80\n   trace_raw_output_kvm_nested_vmenter_failed+0x3a/0x60 [kvm]\n   print_trace_line+0x1dd/0x4e0\n   s_show+0x45/0x150\n   seq_read_iter+0x2d5/0x4c0\n   seq_read+0x106/0x150\n   vfs_read+0x98/0x180\n   ksys_read+0x5f/0xe0\n   do_syscall_64+0x40/0xb0\n   entry_SYSCALL_64_after_hwframe+0x44/0xae"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47271",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/ae746b6f4ce619cf4032fd798a232b010907a397",
            "https://git.kernel.org/stable/c/a9aecef198faae3240921b707bc09b602e966fce"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: cdnsp: Fix deadlock issue in cdnsp_thread_irq_handler\n\nPatch fixes the following critical issue caused by deadlock which has been\ndetected during testing NCM class:\n\nsmp: csd: Detected non-responsive CSD lock (#1) on CPU#0\nsmp:     csd: CSD lock (#1) unresponsive.\n....\nRIP: 0010:native_queued_spin_lock_slowpath+0x61/0x1d0\nRSP: 0018:ffffbc494011cde0 EFLAGS: 00000002\nRAX: 0000000000000101 RBX: ffff9ee8116b4a68 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff9ee8116b4658\nRBP: ffffbc494011cde0 R08: 0000000000000001 R09: 0000000000000000\nR10: ffff9ee8116b4670 R11: 0000000000000000 R12: ffff9ee8116b4658\nR13: ffff9ee8116b4670 R14: 0000000000000246 R15: ffff9ee8116b4658\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f7bcc41a830 CR3: 000000007a612003 CR4: 00000000001706e0\nCall Trace:\n <IRQ>\n do_raw_spin_lock+0xc0/0xd0\n _raw_spin_lock_irqsave+0x95/0xa0\n cdnsp_gadget_ep_queue.cold+0x88/0x107 [cdnsp_udc_pci]\n usb_ep_queue+0x35/0x110\n eth_start_xmit+0x220/0x3d0 [u_ether]\n ncm_tx_timeout+0x34/0x40 [usb_f_ncm]\n ? ncm_free_inst+0x50/0x50 [usb_f_ncm]\n __hrtimer_run_queues+0xac/0x440\n hrtimer_run_softirq+0x8c/0xb0\n __do_softirq+0xcf/0x428\n asm_call_irq_on_stack+0x12/0x20\n </IRQ>\n do_softirq_own_stack+0x61/0x70\n irq_exit_rcu+0xc1/0xd0\n sysvec_apic_timer_interrupt+0x52/0xb0\n asm_sysvec_apic_timer_interrupt+0x12/0x20\nRIP: 0010:do_raw_spin_trylock+0x18/0x40\nRSP: 0018:ffffbc494138bda8 EFLAGS: 00000246\nRAX: 0000000000000000 RBX: ffff9ee8116b4658 RCX: 0000000000000000\nRDX: 0000000000000001 RSI: 0000000000000000 RDI: ffff9ee8116b4658\nRBP: ffffbc494138bda8 R08: 0000000000000001 R09: 0000000000000000\nR10: ffff9ee8116b4670 R11: 0000000000000000 R12: ffff9ee8116b4658\nR13: ffff9ee8116b4670 R14: ffff9ee7b5c73d80 R15: ffff9ee8116b4000\n _raw_spin_lock+0x3d/0x70\n ? cdnsp_thread_irq_handler.cold+0x32/0x112c [cdnsp_udc_pci]\n cdnsp_thread_irq_handler.cold+0x32/0x112c [cdnsp_udc_pci]\n ? cdnsp_remove_request+0x1f0/0x1f0 [cdnsp_udc_pci]\n ? cdnsp_thread_irq_handler+0x5/0xa0 [cdnsp_udc_pci]\n ? irq_thread+0xa0/0x1c0\n irq_thread_fn+0x28/0x60\n irq_thread+0x105/0x1c0\n ? __kthread_parkme+0x42/0x90\n ? irq_forced_thread_fn+0x90/0x90\n ? wake_threads_waitq+0x30/0x30\n ? irq_thread_check_affinity+0xe0/0xe0\n kthread+0x12a/0x160\n ? kthread_park+0x90/0x90\n ret_from_fork+0x22/0x30\n\nThe root cause of issue is spin_lock/spin_unlock instruction instead\nspin_lock_irqsave/spin_lock_irqrestore in cdnsp_thread_irq_handler\nfunction."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47275",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/555002a840ab88468e252b0eedf0b05e2ce7099c",
            "https://git.kernel.org/stable/c/41fe8d088e96472f63164e213de44ec77be69478"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nbcache: avoid oversized read request in cache missing code path\n\nIn the cache missing code path of cached device, if a proper location\nfrom the internal B+ tree is matched for a cache miss range, function\ncached_dev_cache_miss() will be called in cache_lookup_fn() in the\nfollowing code block,\n[code block 1]\n  526         unsigned int sectors = KEY_INODE(k) == s->iop.inode\n  527                 ? min_t(uint64_t, INT_MAX,\n  528                         KEY_START(k) - bio->bi_iter.bi_sector)\n  529                 : INT_MAX;\n  530         int ret = s->d->cache_miss(b, s, bio, sectors);\n\nHere s->d->cache_miss() is the call backfunction pointer initialized as\ncached_dev_cache_miss(), the last parameter 'sectors' is an important\nhint to calculate the size of read request to backing device of the\nmissing cache data.\n\nCurrent calculation in above code block may generate oversized value of\n'sectors', which consequently may trigger 2 different potential kernel\npanics by BUG() or BUG_ON() as listed below,\n\n1) BUG_ON() inside bch_btree_insert_key(),\n[code block 2]\n   886         BUG_ON(b->ops->is_extents && !KEY_SIZE(k));\n2) BUG() inside biovec_slab(),\n[code block 3]\n   51         default:\n   52                 BUG();\n   53                 return NULL;\n\nAll the above panics are original from cached_dev_cache_miss() by the\noversized parameter 'sectors'.\n\nInside cached_dev_cache_miss(), parameter 'sectors' is used to calculate\nthe size of data read from backing device for the cache missing. This\nsize is stored in s->insert_bio_sectors by the following lines of code,\n[code block 4]\n  909    s->insert_bio_sectors = min(sectors, bio_sectors(bio) + reada);\n\nThen the actual key inserting to the internal B+ tree is generated and\nstored in s->iop.replace_key by the following lines of code,\n[code block 5]\n  911   s->iop.replace_key = KEY(s->iop.inode,\n  912                    bio->bi_iter.bi_sector + s->insert_bio_sectors,\n  913                    s->insert_bio_sectors);\nThe oversized parameter 'sectors' may trigger panic 1) by BUG_ON() from\nthe above code block.\n\nAnd the bio sending to backing device for the missing data is allocated\nwith hint from s->insert_bio_sectors by the following lines of code,\n[code block 6]\n  926    cache_bio = bio_alloc_bioset(GFP_NOWAIT,\n  927                 DIV_ROUND_UP(s->insert_bio_sectors, PAGE_SECTORS),\n  928                 &dc->disk.bio_split);\nThe oversized parameter 'sectors' may trigger panic 2) by BUG() from the\nagove code block.\n\nNow let me explain how the panics happen with the oversized 'sectors'.\nIn code block 5, replace_key is generated by macro KEY(). From the\ndefinition of macro KEY(),\n[code block 7]\n  71 #define KEY(inode, offset, size)                                  \\\n  72 ((struct bkey) {                                                  \\\n  73      .high = (1ULL << 63) | ((__u64) (size) << 20) | (inode),     \\\n  74      .low = (offset)                                              \\\n  75 })\n\nHere 'size' is 16bits width embedded in 64bits member 'high' of struct\nbkey. But in code block 1, if \"KEY_START(k) - bio->bi_iter.bi_sector\" is\nvery probably to be larger than (1<<16) - 1, which makes the bkey size\ncalculation in code block 5 is overflowed. In one bug report the value\nof parameter 'sectors' is 131072 (= 1 << 17), the overflowed 'sectors'\nresults the overflowed s->insert_bio_sectors in code block 4, then makes\nsize field of s->iop.replace_key to be 0 in code block 5. Then the 0-\nsized s->iop.replace_key is inserted into the internal B+ tree as cache\nmissing check key (a special key to detect and avoid a racing between\nnormal write request and cache missing read request) as,\n[code block 8]\n  915   ret = bch_btree_insert_check_key(b, &s->op, &s->iop.replace_key);\n\nThen the 0-sized s->iop.replace_key as 3rd parameter triggers the bkey\nsize check BUG_ON() in code block 2, and causes the kernel panic 1).\n\nAnother ke\n---truncated---"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47272",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/851dee5a5da56564a70290713aee665403bb0b24",
            "https://git.kernel.org/stable/c/4aad390363d2b9b3e92428dd34d27bb7ea8f1ee8",
            "https://git.kernel.org/stable/c/03715ea2e3dbbc56947137ce3b4ac18a726b2f87"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: dwc3: gadget: Bail from dwc3_gadget_exit() if dwc->gadget is NULL\n\nThere exists a possible scenario in which dwc3_gadget_init() can fail:\nduring during host -> peripheral mode switch in dwc3_set_mode(), and\na pending gadget driver fails to bind.  Then, if the DRD undergoes\nanother mode switch from peripheral->host the resulting\ndwc3_gadget_exit() will attempt to reference an invalid and dangling\ndwc->gadget pointer as well as call dma_free_coherent() on unmapped\nDMA pointers.\n\nThe exact scenario can be reproduced as follows:\n - Start DWC3 in peripheral mode\n - Configure ConfigFS gadget with FunctionFS instance (or use g_ffs)\n - Run FunctionFS userspace application (open EPs, write descriptors, etc)\n - Bind gadget driver to DWC3's UDC\n - Switch DWC3 to host mode\n   => dwc3_gadget_exit() is called. usb_del_gadget() will put the\n\tConfigFS driver instance on the gadget_driver_pending_list\n - Stop FunctionFS application (closes the ep files)\n - Switch DWC3 to peripheral mode\n   => dwc3_gadget_init() fails as usb_add_gadget() calls\n\tcheck_pending_gadget_drivers() and attempts to rebind the UDC\n\tto the ConfigFS gadget but fails with -19 (-ENODEV) because the\n\tFFS instance is not in FFS_ACTIVE state (userspace has not\n\tre-opened and written the descriptors yet, i.e. desc_ready!=0).\n - Switch DWC3 back to host mode\n   => dwc3_gadget_exit() is called again, but this time dwc->gadget\n\tis invalid.\n\nAlthough it can be argued that userspace should take responsibility\nfor ensuring that the FunctionFS application be ready prior to\nallowing the composite driver bind to the UDC, failure to do so\nshould not result in a panic from the kernel driver.\n\nFix this by setting dwc->gadget to NULL in the failure path of\ndwc3_gadget_init() and add a check to dwc3_gadget_exit() to bail out\nunless the gadget pointer is valid."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47285",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/c08e0be44759d0b5affc5888be4aa5e536873335",
            "https://git.kernel.org/stable/c/d6a21a3fb03300fbaa9fc3ed99f8b0962ce28362",
            "https://git.kernel.org/stable/c/38cb2e23188af29c43966acee9dbb18b62e26cfe",
            "https://git.kernel.org/stable/c/ec72482564ff99c6832d33610d9f8ab7ecc81b6d",
            "https://git.kernel.org/stable/c/f3ed12af6bbbaf79eddb0ae14656b8ecacea74f0",
            "https://git.kernel.org/stable/c/1e5cab50208c8fb7351b798cb1d569debfeb994a",
            "https://git.kernel.org/stable/c/90d0a3c76965d7a10fc87c07be3e9714e2130d5c",
            "https://git.kernel.org/stable/c/8ab78863e9eff11910e1ac8bcf478060c29b379e"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/nfc/rawsock.c: fix a permission check bug\n\nThe function rawsock_create() calls a privileged function sk_alloc(), which requires a ns-aware check to check net->user_ns, i.e., ns_capable(). However, the original code checks the init_user_ns using capable(). So we replace the capable() with ns_capable()."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47274",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/edcce01e0e50840a9aa6a70baed21477bdd2c9f9",
            "https://git.kernel.org/stable/c/2d598902799886d67947406f26ee8e5fd2ca097f",
            "https://git.kernel.org/stable/c/31ceae385556c37e4d286cb6378696448f566883",
            "https://git.kernel.org/stable/c/d63f00ec908b3be635ead5d6029cc94246e1f38d",
            "https://git.kernel.org/stable/c/43c32c22254b9328d7abb1c2b0f689dc67838e60",
            "https://git.kernel.org/stable/c/b16a249eca2230c2cd66fa1d4b94743bd9b6ef92",
            "https://git.kernel.org/stable/c/3e08a9f9760f4a70d633c328a76408e62d6f80a3"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing: Correct the length check which causes memory corruption\n\nWe've suffered from severe kernel crashes due to memory corruption on\nour production environment, like,\n\nCall Trace:\n[1640542.554277] general protection fault: 0000 [#1] SMP PTI\n[1640542.554856] CPU: 17 PID: 26996 Comm: python Kdump: loaded Tainted:G\n[1640542.556629] RIP: 0010:kmem_cache_alloc+0x90/0x190\n[1640542.559074] RSP: 0018:ffffb16faa597df8 EFLAGS: 00010286\n[1640542.559587] RAX: 0000000000000000 RBX: 0000000000400200 RCX:\n0000000006e931bf\n[1640542.560323] RDX: 0000000006e931be RSI: 0000000000400200 RDI:\nffff9a45ff004300\n[1640542.560996] RBP: 0000000000400200 R08: 0000000000023420 R09:\n0000000000000000\n[1640542.561670] R10: 0000000000000000 R11: 0000000000000000 R12:\nffffffff9a20608d\n[1640542.562366] R13: ffff9a45ff004300 R14: ffff9a45ff004300 R15:\n696c662f65636976\n[1640542.563128] FS:  00007f45d7c6f740(0000) GS:ffff9a45ff840000(0000)\nknlGS:0000000000000000\n[1640542.563937] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[1640542.564557] CR2: 00007f45d71311a0 CR3: 000000189d63e004 CR4:\n00000000003606e0\n[1640542.565279] DR0: 0000000000000000 DR1: 0000000000000000 DR2:\n0000000000000000\n[1640542.566069] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7:\n0000000000000400\n[1640542.566742] Call Trace:\n[1640542.567009]  anon_vma_clone+0x5d/0x170\n[1640542.567417]  __split_vma+0x91/0x1a0\n[1640542.567777]  do_munmap+0x2c6/0x320\n[1640542.568128]  vm_munmap+0x54/0x70\n[1640542.569990]  __x64_sys_munmap+0x22/0x30\n[1640542.572005]  do_syscall_64+0x5b/0x1b0\n[1640542.573724]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n[1640542.575642] RIP: 0033:0x7f45d6e61e27\n\nJames Wang has reproduced it stably on the latest 4.19 LTS.\nAfter some debugging, we finally proved that it's due to ftrace\nbuffer out-of-bound access using a debug tool as follows:\n[   86.775200] BUG: Out-of-bounds write at addr 0xffff88aefe8b7000\n[   86.780806]  no_context+0xdf/0x3c0\n[   86.784327]  __do_page_fault+0x252/0x470\n[   86.788367]  do_page_fault+0x32/0x140\n[   86.792145]  page_fault+0x1e/0x30\n[   86.795576]  strncpy_from_unsafe+0x66/0xb0\n[   86.799789]  fetch_memory_string+0x25/0x40\n[   86.804002]  fetch_deref_string+0x51/0x60\n[   86.808134]  kprobe_trace_func+0x32d/0x3a0\n[   86.812347]  kprobe_dispatcher+0x45/0x50\n[   86.816385]  kprobe_ftrace_handler+0x90/0xf0\n[   86.820779]  ftrace_ops_assist_func+0xa1/0x140\n[   86.825340]  0xffffffffc00750bf\n[   86.828603]  do_sys_open+0x5/0x1f0\n[   86.832124]  do_syscall_64+0x5b/0x1b0\n[   86.835900]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\ncommit b220c049d519 (\"tracing: Check length before giving out\nthe filter buffer\") adds length check to protect trace data\noverflow introduced in 0fc1b09ff1ff, seems that this fix can't prevent\noverflow entirely, the length check should also take the sizeof\nentry->array[0] into account, since this array[0] is filled the\nlength of trace data and occupy addtional space and risk overflow."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47274",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/edcce01e0e50840a9aa6a70baed21477bdd2c9f9",
            "https://git.kernel.org/stable/c/2d598902799886d67947406f26ee8e5fd2ca097f",
            "https://git.kernel.org/stable/c/31ceae385556c37e4d286cb6378696448f566883",
            "https://git.kernel.org/stable/c/d63f00ec908b3be635ead5d6029cc94246e1f38d",
            "https://git.kernel.org/stable/c/43c32c22254b9328d7abb1c2b0f689dc67838e60",
            "https://git.kernel.org/stable/c/b16a249eca2230c2cd66fa1d4b94743bd9b6ef92",
            "https://git.kernel.org/stable/c/3e08a9f9760f4a70d633c328a76408e62d6f80a3"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing: Correct the length check which causes memory corruption\n\nWe've suffered from severe kernel crashes due to memory corruption on\nour production environment, like,\n\nCall Trace:\n[1640542.554277] general protection fault: 0000 [#1] SMP PTI\n[1640542.554856] CPU: 17 PID: 26996 Comm: python Kdump: loaded Tainted:G\n[1640542.556629] RIP: 0010:kmem_cache_alloc+0x90/0x190\n[1640542.559074] RSP: 0018:ffffb16faa597df8 EFLAGS: 00010286\n[1640542.559587] RAX: 0000000000000000 RBX: 0000000000400200 RCX:\n0000000006e931bf\n[1640542.560323] RDX: 0000000006e931be RSI: 0000000000400200 RDI:\nffff9a45ff004300\n[1640542.560996] RBP: 0000000000400200 R08: 0000000000023420 R09:\n0000000000000000\n[1640542.561670] R10: 0000000000000000 R11: 0000000000000000 R12:\nffffffff9a20608d\n[1640542.562366] R13: ffff9a45ff004300 R14: ffff9a45ff004300 R15:\n696c662f65636976\n[1640542.563128] FS:  00007f45d7c6f740(0000) GS:ffff9a45ff840000(0000)\nknlGS:0000000000000000\n[1640542.563937] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[1640542.564557] CR2: 00007f45d71311a0 CR3: 000000189d63e004 CR4:\n00000000003606e0\n[1640542.565279] DR0: 0000000000000000 DR1: 0000000000000000 DR2:\n0000000000000000\n[1640542.566069] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7:\n0000000000000400\n[1640542.566742] Call Trace:\n[1640542.567009]  anon_vma_clone+0x5d/0x170\n[1640542.567417]  __split_vma+0x91/0x1a0\n[1640542.567777]  do_munmap+0x2c6/0x320\n[1640542.568128]  vm_munmap+0x54/0x70\n[1640542.569990]  __x64_sys_munmap+0x22/0x30\n[1640542.572005]  do_syscall_64+0x5b/0x1b0\n[1640542.573724]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n[1640542.575642] RIP: 0033:0x7f45d6e61e27\n\nJames Wang has reproduced it stably on the latest 4.19 LTS.\nAfter some debugging, we finally proved that it's due to ftrace\nbuffer out-of-bound access using a debug tool as follows:\n[   86.775200] BUG: Out-of-bounds write at addr 0xffff88aefe8b7000\n[   86.780806]  no_context+0xdf/0x3c0\n[   86.784327]  __do_page_fault+0x252/0x470\n[   86.788367]  do_page_fault+0x32/0x140\n[   86.792145]  page_fault+0x1e/0x30\n[   86.795576]  strncpy_from_unsafe+0x66/0xb0\n[   86.799789]  fetch_memory_string+0x25/0x40\n[   86.804002]  fetch_deref_string+0x51/0x60\n[   86.808134]  kprobe_trace_func+0x32d/0x3a0\n[   86.812347]  kprobe_dispatcher+0x45/0x50\n[   86.816385]  kprobe_ftrace_handler+0x90/0xf0\n[   86.820779]  ftrace_ops_assist_func+0xa1/0x140\n[   86.825340]  0xffffffffc00750bf\n[   86.828603]  do_sys_open+0x5/0x1f0\n[   86.832124]  do_syscall_64+0x5b/0x1b0\n[   86.835900]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\ncommit b220c049d519 (\"tracing: Check length before giving out\nthe filter buffer\") adds length check to protect trace data\noverflow introduced in 0fc1b09ff1ff, seems that this fix can't prevent\noverflow entirely, the length check should also take the sizeof\nentry->array[0] into account, since this array[0] is filled the\nlength of trace data and occupy addtional space and risk overflow."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47323",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/0015581a79bbf8e521f85dddb7d3e4a66b9f51d4",
            "https://git.kernel.org/stable/c/b4565a8a2d6bffb05bfbec11399d261ec16fe373",
            "https://git.kernel.org/stable/c/2aef07017fae21c3d8acea9656b10e3b9c0f1e04",
            "https://git.kernel.org/stable/c/522e75ed63f67e815d4ec0deace67df22d9ce78e",
            "https://git.kernel.org/stable/c/7c56c5508dc20a6b133bc669fc34327a6711c24c",
            "https://git.kernel.org/stable/c/a173e3b62cf6dd3c4a0a10c8a82eedfcae81a566",
            "https://git.kernel.org/stable/c/b3c41ea5bc34d8c7b19e230d80e0e555c6f5057d",
            "https://git.kernel.org/stable/c/f0feab82f6a0323f54d85e8b512a2be64f83648a",
            "https://git.kernel.org/stable/c/90b7c141132244e8e49a34a4c1e445cce33e07f4"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nwatchdog: sc520_wdt: Fix possible use-after-free in wdt_turnoff()\n\nThis module's remove path calls del_timer(). However, that function\ndoes not wait until the timer handler finishes. This means that the\ntimer handler may still be running after the driver's remove function\nhas finished, which would result in a use-after-free.\n\nFix by calling del_timer_sync(), which makes sure the timer handler\nhas finished, and unable to re-schedule itself."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47279",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/2147684be1ebdaf845783139b9bc4eba3fecd9e4",
            "https://git.kernel.org/stable/c/fbf649cd6d64d40c03c5397ecd6b1ae922ba7afc"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: misc: brcmstb-usb-pinmap: check return value after calling platform_get_resource()\n\nIt will cause null-ptr-deref if platform_get_resource() returns NULL,\nwe need check the return value."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47283",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/8d717c9135a3340ae62d1699484850bfb4112b0c",
            "https://git.kernel.org/stable/c/81c4d1d83f88e15b26f4522a35cba6ffd8c5dfdd",
            "https://git.kernel.org/stable/c/8f03eeb6e0a0a0b8d617ee0a4bce729e47130036"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet:sfc: fix non-freed irq in legacy irq mode\n\nSFC driver can be configured via modparam to work using MSI-X, MSI or\nlegacy IRQ interrupts. In the last one, the interrupt was not properly\nreleased on module remove.\n\nIt was not freed because the flag irqs_hooked was not set during\ninitialization in the case of using legacy IRQ.\n\nExample of (trimmed) trace during module remove without this fix:\n\nremove_proc_entry: removing non-empty directory 'irq/125', leaking at least '0000:3b:00.1'\nWARNING: CPU: 39 PID: 3658 at fs/proc/generic.c:715 remove_proc_entry+0x15c/0x170\n...trimmed...\nCall Trace:\n unregister_irq_proc+0xe3/0x100\n free_desc+0x29/0x70\n irq_free_descs+0x47/0x70\n mp_unmap_irq+0x58/0x60\n acpi_unregister_gsi_ioapic+0x2a/0x40\n acpi_pci_irq_disable+0x78/0xb0\n pci_disable_device+0xd1/0x100\n efx_pci_remove+0xa1/0x1e0 [sfc]\n pci_device_remove+0x38/0xa0\n __device_release_driver+0x177/0x230\n driver_detach+0xcb/0x110\n bus_remove_driver+0x58/0xd0\n pci_unregister_driver+0x2a/0xb0\n efx_exit_module+0x24/0xf40 [sfc]\n __do_sys_delete_module.constprop.0+0x171/0x280\n ? exit_to_user_mode_prepare+0x83/0x1d0\n do_syscall_64+0x3d/0x80\n entry_SYSCALL_64_after_hwframe+0x44/0xae\nRIP: 0033:0x7f9f9385800b\n...trimmed..."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47298",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/715f378f42909c401ec043f5150c4fdf57fb8889",
            "https://git.kernel.org/stable/c/6c508a1c6c62793dc6e6872cad4b200097bab7c9",
            "https://git.kernel.org/stable/c/7e6b27a69167f97c56b5437871d29e9722c3e470"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf, sockmap: Fix potential memory leak on unlikely error case\n\nIf skb_linearize is needed and fails we could leak a msg on the error\nhandling. To fix ensure we kfree the msg block before returning error.\nFound during code review."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47298",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/715f378f42909c401ec043f5150c4fdf57fb8889",
            "https://git.kernel.org/stable/c/6c508a1c6c62793dc6e6872cad4b200097bab7c9",
            "https://git.kernel.org/stable/c/7e6b27a69167f97c56b5437871d29e9722c3e470"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf, sockmap: Fix potential memory leak on unlikely error case\n\nIf skb_linearize is needed and fails we could leak a msg on the error\nhandling. To fix ensure we kfree the msg block before returning error.\nFound during code review."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47277",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/3098b86390a6b9ea52657689f08410baf130ceff",
            "https://git.kernel.org/stable/c/740621309b25bbf619b8a0ba5fd50a8e58989441",
            "https://git.kernel.org/stable/c/361ce3b917aff93123e9e966d8608655c967f438",
            "https://git.kernel.org/stable/c/22b87fb17a28d37331bb9c1110737627b17f6781",
            "https://git.kernel.org/stable/c/bff1fbf0cf0712686f1df59a83fba6e31d2746a0",
            "https://git.kernel.org/stable/c/7af299b97734c7e7f465b42a2139ce4d77246975",
            "https://git.kernel.org/stable/c/ed0e2a893092c7fcb4ff7ba74e5efce53a6f5940",
            "https://git.kernel.org/stable/c/da27a83fd6cc7780fea190e1f5c19e87019da65c"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nkvm: avoid speculation-based attacks from out-of-range memslot accesses\n\nKVM's mechanism for accessing guest memory translates a guest physical\naddress (gpa) to a host virtual address using the right-shifted gpa\n(also known as gfn) and a struct kvm_memory_slot.  The translation is\nperformed in __gfn_to_hva_memslot using the following formula:\n\n      hva = slot->userspace_addr + (gfn - slot->base_gfn) * PAGE_SIZE\n\nIt is expected that gfn falls within the boundaries of the guest's\nphysical memory.  However, a guest can access invalid physical addresses\nin such a way that the gfn is invalid.\n\n__gfn_to_hva_memslot is called from kvm_vcpu_gfn_to_hva_prot, which first\nretrieves a memslot through __gfn_to_memslot.  While __gfn_to_memslot\ndoes check that the gfn falls within the boundaries of the guest's\nphysical memory or not, a CPU can speculate the result of the check and\ncontinue execution speculatively using an illegal gfn. The speculation\ncan result in calculating an out-of-bounds hva.  If the resulting host\nvirtual address is used to load another guest physical address, this\nis effectively a Spectre gadget consisting of two consecutive reads,\nthe second of which is data dependent on the first.\n\nRight now it's not clear if there are any cases in which this is\nexploitable.  One interesting case was reported by the original author\nof this patch, and involves visiting guest page tables on x86.  Right\nnow these are not vulnerable because the hva read goes through get_user(),\nwhich contains an LFENCE speculation barrier.  However, there are\npatches in progress for x86 uaccess.h to mask kernel addresses instead of\nusing LFENCE; once these land, a guest could use speculation to read\nfrom the VMM's ring 3 address space.  Other architectures such as ARM\nalready use the address masking method, and would be susceptible to\nthis same kind of data-dependent access gadgets.  Therefore, this patch\nproactively protects from these attacks by masking out-of-bounds gfns\nin __gfn_to_hva_memslot, which blocks speculation of invalid hvas.\n\nSean Christopherson noted that this patch does not cover\nkvm_read_guest_offset_cached.  This however is limited to a few bytes\npast the end of the cache, and therefore it is unlikely to be useful in\nthe context of building a chain of data dependent accesses."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47286",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/3efec3b4b16fc7af25676a94230a8ab2a3bb867c",
            "https://git.kernel.org/stable/c/aed4f5b51aba41e2afd7cfda20a0571a6a67dfe9",
            "https://git.kernel.org/stable/c/546362a9ef2ef40b57c6605f14e88ced507f8dd0"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nbus: mhi: core: Validate channel ID when processing command completions\n\nMHI reads the channel ID from the event ring element sent by the\ndevice which can be any value between 0 and 255. In order to\nprevent any out of bound accesses, add a check against the maximum\nnumber of channels supported by the controller and those channels\nnot configured yet so as to skip processing of that event ring\nelement."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47289",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/38f54217b423c0101d03a00feec6fb8ec608b12e",
            "https://git.kernel.org/stable/c/cae3fa3d8165761f3000f523b11cfa1cd35206bc",
            "https://git.kernel.org/stable/c/ccf23a0888077a25a0793a746c3941db2a7562e4",
            "https://git.kernel.org/stable/c/fc68f42aa737dc15e7665a4101d4168aadb8e4c4"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nACPI: fix NULL pointer dereference\n\nCommit 71f642833284 (\"ACPI: utils: Fix reference counting in\nfor_each_acpi_dev_match()\") started doing \"acpi_dev_put()\" on a pointer\nthat was possibly NULL.  That fails miserably, because that helper\ninline function is not set up to handle that case.\n\nJust make acpi_dev_put() silently accept a NULL pointer, rather than\ncalling down to put_device() with an invalid offset off that NULL\npointer."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47337",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/d2f0b960d07e52bb664471b4de0ed8b08c636b3a",
            "https://git.kernel.org/stable/c/f3d0a109240c9bed5c60d819014786be3a2fe515",
            "https://git.kernel.org/stable/c/e1bd3fac2baa3d5c04375980c1d5263a3335af92",
            "https://git.kernel.org/stable/c/887bfae2732b5b02a86a859fd239d34f7ff93c05",
            "https://git.kernel.org/stable/c/ea518b70ed5e4598c8d706f37fc16f7b06e440bd",
            "https://git.kernel.org/stable/c/8e4212ecf0713dd57d0e3209a66201da582149b1",
            "https://git.kernel.org/stable/c/c1671d2d2ef8a84837eea1b4d99ca0c6a66fb691",
            "https://git.kernel.org/stable/c/93aa71ad7379900e61c8adff6a710a4c18c7c99b"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: core: Fix bad pointer dereference when ehandler kthread is invalid\n\nCommit 66a834d09293 (\"scsi: core: Fix error handling of scsi_host_alloc()\")\nchanged the allocation logic to call put_device() to perform host cleanup\nwith the assumption that IDA removal and stopping the kthread would\nproperly be performed in scsi_host_dev_release(). However, in the unlikely\ncase that the error handler thread fails to spawn, shost->ehandler is set\nto ERR_PTR(-ENOMEM).\n\nThe error handler cleanup code in scsi_host_dev_release() will call\nkthread_stop() if shost->ehandler != NULL which will always be the case\nwhether the kthread was successfully spawned or not. In the case that it\nfailed to spawn this has the nasty side effect of trying to dereference an\ninvalid pointer when kthread_stop() is called. The following splat provides\nan example of this behavior in the wild:\n\nscsi host11: error handler thread failed to spawn, error = -4\nKernel attempted to read user page (10c) - exploit attempt? (uid: 0)\nBUG: Kernel NULL pointer dereference on read at 0x0000010c\nFaulting instruction address: 0xc00000000818e9a8\nOops: Kernel access of bad area, sig: 11 [#1]\nLE PAGE_SIZE=64K MMU=Hash SMP NR_CPUS=2048 NUMA pSeries\nModules linked in: ibmvscsi(+) scsi_transport_srp dm_multipath dm_mirror dm_region\n hash dm_log dm_mod fuse overlay squashfs loop\nCPU: 12 PID: 274 Comm: systemd-udevd Not tainted 5.13.0-rc7 #1\nNIP:  c00000000818e9a8 LR: c0000000089846e8 CTR: 0000000000007ee8\nREGS: c000000037d12ea0 TRAP: 0300   Not tainted  (5.13.0-rc7)\nMSR:  800000000280b033 &lt;SF,VEC,VSX,EE,FP,ME,IR,DR,RI,LE&gt;  CR: 28228228\nXER: 20040001\nCFAR: c0000000089846e4 DAR: 000000000000010c DSISR: 40000000 IRQMASK: 0\nGPR00: c0000000089846e8 c000000037d13140 c000000009cc1100 fffffffffffffffc\nGPR04: 0000000000000001 0000000000000000 0000000000000000 c000000037dc0000\nGPR08: 0000000000000000 c000000037dc0000 0000000000000001 00000000fffff7ff\nGPR12: 0000000000008000 c00000000a049000 c000000037d13d00 000000011134d5a0\nGPR16: 0000000000001740 c0080000190d0000 c0080000190d1740 c000000009129288\nGPR20: c000000037d13bc0 0000000000000001 c000000037d13bc0 c0080000190b7898\nGPR24: c0080000190b7708 0000000000000000 c000000033bb2c48 0000000000000000\nGPR28: c000000046b28280 0000000000000000 000000000000010c fffffffffffffffc\nNIP [c00000000818e9a8] kthread_stop+0x38/0x230\nLR [c0000000089846e8] scsi_host_dev_release+0x98/0x160\nCall Trace:\n[c000000033bb2c48] 0xc000000033bb2c48 (unreliable)\n[c0000000089846e8] scsi_host_dev_release+0x98/0x160\n[c00000000891e960] device_release+0x60/0x100\n[c0000000087e55c4] kobject_release+0x84/0x210\n[c00000000891ec78] put_device+0x28/0x40\n[c000000008984ea4] scsi_host_alloc+0x314/0x430\n[c0080000190b38bc] ibmvscsi_probe+0x54/0xad0 [ibmvscsi]\n[c000000008110104] vio_bus_probe+0xa4/0x4b0\n[c00000000892a860] really_probe+0x140/0x680\n[c00000000892aefc] driver_probe_device+0x15c/0x200\n[c00000000892b63c] device_driver_attach+0xcc/0xe0\n[c00000000892b740] __driver_attach+0xf0/0x200\n[c000000008926f28] bus_for_each_dev+0xa8/0x130\n[c000000008929ce4] driver_attach+0x34/0x50\n[c000000008928fc0] bus_add_driver+0x1b0/0x300\n[c00000000892c798] driver_register+0x98/0x1a0\n[c00000000810eb60] __vio_register_driver+0x80/0xe0\n[c0080000190b4a30] ibmvscsi_module_init+0x9c/0xdc [ibmvscsi]\n[c0000000080121d0] do_one_initcall+0x60/0x2d0\n[c000000008261abc] do_init_module+0x7c/0x320\n[c000000008265700] load_module+0x2350/0x25b0\n[c000000008265cb4] __do_sys_finit_module+0xd4/0x160\n[c000000008031110] system_call_exception+0x150/0x2d0\n[c00000000800d35c] system_call_common+0xec/0x278\n\nFix this be nulling shost->ehandler when the kthread fails to spawn."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47292",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/502731a03f27cba1513fbbff77e508185ffce5bb",
            "https://git.kernel.org/stable/c/362a9e65289284f36403058eea2462d0330c1f24"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nio_uring: fix memleak in io_init_wq_offload()\n\nI got memory leak report when doing fuzz test:\n\nBUG: memory leak\nunreferenced object 0xffff888107310a80 (size 96):\ncomm \"syz-executor.6\", pid 4610, jiffies 4295140240 (age 20.135s)\nhex dump (first 32 bytes):\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n00 00 00 00 ad 4e ad de ff ff ff ff 00 00 00 00 .....N..........\nbacktrace:\n[<000000001974933b>] kmalloc include/linux/slab.h:591 [inline]\n[<000000001974933b>] kzalloc include/linux/slab.h:721 [inline]\n[<000000001974933b>] io_init_wq_offload fs/io_uring.c:7920 [inline]\n[<000000001974933b>] io_uring_alloc_task_context+0x466/0x640 fs/io_uring.c:7955\n[<0000000039d0800d>] __io_uring_add_tctx_node+0x256/0x360 fs/io_uring.c:9016\n[<000000008482e78c>] io_uring_add_tctx_node fs/io_uring.c:9052 [inline]\n[<000000008482e78c>] __do_sys_io_uring_enter fs/io_uring.c:9354 [inline]\n[<000000008482e78c>] __se_sys_io_uring_enter fs/io_uring.c:9301 [inline]\n[<000000008482e78c>] __x64_sys_io_uring_enter+0xabc/0xc20 fs/io_uring.c:9301\n[<00000000b875f18f>] do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n[<00000000b875f18f>] do_syscall_64+0x3b/0x90 arch/x86/entry/common.c:80\n[<000000006b0a8484>] entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nCPU0                          CPU1\nio_uring_enter                io_uring_enter\nio_uring_add_tctx_node        io_uring_add_tctx_node\n__io_uring_add_tctx_node      __io_uring_add_tctx_node\nio_uring_alloc_task_context   io_uring_alloc_task_context\nio_init_wq_offload            io_init_wq_offload\nhash = kzalloc                hash = kzalloc\nctx->hash_map = hash          ctx->hash_map = hash <- one of the hash is leaked\n\nWhen calling io_uring_enter() in parallel, the 'hash_map' will be leaked,\nadd uring_lock to protect 'hash_map'."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47295",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/8d7924ce85bae64e7a67c366c7c50840f49f3a62",
            "https://git.kernel.org/stable/c/8e9662fde6d63c78eb1350f6167f64c9d71a865b",
            "https://git.kernel.org/stable/c/cac71d27745f92ee13f0ecc668ffe151a4a9c9b1",
            "https://git.kernel.org/stable/c/f5051bcece50140abd1a11a2d36dc3ec5484fc32"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: sched: fix memory leak in tcindex_partial_destroy_work\n\nSyzbot reported memory leak in tcindex_set_parms(). The problem was in\nnon-freed perfect hash in tcindex_partial_destroy_work().\n\nIn tcindex_set_parms() new tcindex_data is allocated and some fields from\nold one are copied to new one, but not the perfect hash. Since\ntcindex_partial_destroy_work() is the destroy function for old\ntcindex_data, we need to free perfect hash to avoid memory leak."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47222",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/42020f7f37a90d24b9551f5f7eba3f7c7c102968",
            "https://git.kernel.org/stable/c/84fc1c944e45ab317e2e70a0e7f76fa2a5e43b6e",
            "https://git.kernel.org/stable/c/79855be6445b6592bddb7bd7167083ec8cdbd73f",
            "https://git.kernel.org/stable/c/fc7fdd8c5c2ad2fe3e297698be9d4dbe4a4e0579",
            "https://git.kernel.org/stable/c/25053a8404ba17ca48f5553d487afc1882e9f56c",
            "https://git.kernel.org/stable/c/cfc579f9d89af4ada58c69b03bcaa4887840f3b3"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: bridge: fix vlan tunnel dst refcnt when egressing\n\nThe egress tunnel code uses dst_clone() and directly sets the result\nwhich is wrong because the entry might have 0 refcnt or be already deleted,\ncausing number of problems. It also triggers the WARN_ON() in dst_hold()[1]\nwhen a refcnt couldn't be taken. Fix it by using dst_hold_safe() and\nchecking if a reference was actually taken before setting the dst.\n\n[1] dmesg WARN_ON log and following refcnt errors\n WARNING: CPU: 5 PID: 38 at include/net/dst.h:230 br_handle_egress_vlan_tunnel+0x10b/0x134 [bridge]\n Modules linked in: 8021q garp mrp bridge stp llc bonding ipv6 virtio_net\n CPU: 5 PID: 38 Comm: ksoftirqd/5 Kdump: loaded Tainted: G        W         5.13.0-rc3+ #360\n Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.14.0-1.fc33 04/01/2014\n RIP: 0010:br_handle_egress_vlan_tunnel+0x10b/0x134 [bridge]\n Code: e8 85 bc 01 e1 45 84 f6 74 90 45 31 f6 85 db 48 c7 c7 a0 02 19 a0 41 0f 94 c6 31 c9 31 d2 44 89 f6 e8 64 bc 01 e1 85 db 75 02 <0f> 0b 31 c9 31 d2 44 89 f6 48 c7 c7 70 02 19 a0 e8 4b bc 01 e1 49\n RSP: 0018:ffff8881003d39e8 EFLAGS: 00010246\n RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000\n RDX: 0000000000000000 RSI: 0000000000000001 RDI: ffffffffa01902a0\n RBP: ffff8881040c6700 R08: 0000000000000000 R09: 0000000000000001\n R10: 2ce93d0054fe0d00 R11: 54fe0d00000e0000 R12: ffff888109515000\n R13: 0000000000000000 R14: 0000000000000001 R15: 0000000000000401\n FS:  0000000000000000(0000) GS:ffff88822bf40000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 00007f42ba70f030 CR3: 0000000109926000 CR4: 00000000000006e0\n Call Trace:\n  br_handle_vlan+0xbc/0xca [bridge]\n  __br_forward+0x23/0x164 [bridge]\n  deliver_clone+0x41/0x48 [bridge]\n  br_handle_frame_finish+0x36f/0x3aa [bridge]\n  ? skb_dst+0x2e/0x38 [bridge]\n  ? br_handle_ingress_vlan_tunnel+0x3e/0x1c8 [bridge]\n  ? br_handle_frame_finish+0x3aa/0x3aa [bridge]\n  br_handle_frame+0x2c3/0x377 [bridge]\n  ? __skb_pull+0x33/0x51\n  ? vlan_do_receive+0x4f/0x36a\n  ? br_handle_frame_finish+0x3aa/0x3aa [bridge]\n  __netif_receive_skb_core+0x539/0x7c6\n  ? __list_del_entry_valid+0x16e/0x1c2\n  __netif_receive_skb_list_core+0x6d/0xd6\n  netif_receive_skb_list_internal+0x1d9/0x1fa\n  gro_normal_list+0x22/0x3e\n  dev_gro_receive+0x55b/0x600\n  ? detach_buf_split+0x58/0x140\n  napi_gro_receive+0x94/0x12e\n  virtnet_poll+0x15d/0x315 [virtio_net]\n  __napi_poll+0x2c/0x1c9\n  net_rx_action+0xe6/0x1fb\n  __do_softirq+0x115/0x2d8\n  run_ksoftirqd+0x18/0x20\n  smpboot_thread_fn+0x183/0x19c\n  ? smpboot_unregister_percpu_thread+0x66/0x66\n  kthread+0x10a/0x10f\n  ? kthread_mod_delayed_work+0xb6/0xb6\n  ret_from_fork+0x22/0x30\n ---[ end trace 49f61b07f775fd2b ]---\n dst_release: dst:00000000c02d677a refcnt:-1\n dst_release underflow"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47340",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/7bde24bde490f3139eee147efc6d60d6040fe975",
            "https://git.kernel.org/stable/c/745c9a59422c63f661f4374ed5181740db4130a1",
            "https://git.kernel.org/stable/c/49def1b0644892e3b113673c13d650c3060b43bc",
            "https://git.kernel.org/stable/c/aff8d95b69051d0cf4acc3d91f22299fdbb9dfb3",
            "https://git.kernel.org/stable/c/a21e5cb1a64c904f1f0ef7b2d386fc7d2b1d2ce2",
            "https://git.kernel.org/stable/c/8018936950360f1c503bb385e158cfc5e4945d18",
            "https://git.kernel.org/stable/c/3bb27e27240289b47d3466f647a55c567adbdc3a",
            "https://git.kernel.org/stable/c/42f102ea1943ecb10a0756bf75424de5d1d5beed",
            "https://git.kernel.org/stable/c/9d574f985fe33efd6911f4d752de6f485a1ea732"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\njfs: fix GPF in diFree\n\nAvoid passing inode with\nJFS_SBI(inode->i_sb)->ipimap == NULL to\ndiFree()[1]. GFP will appear:\n\n\tstruct inode *ipimap = JFS_SBI(ip->i_sb)->ipimap;\n\tstruct inomap *imap = JFS_IP(ipimap)->i_imap;\n\nJFS_IP() will return invalid pointer when ipimap == NULL\n\nCall Trace:\n diFree+0x13d/0x2dc0 fs/jfs/jfs_imap.c:853 [1]\n jfs_evict_inode+0x2c9/0x370 fs/jfs/inode.c:154\n evict+0x2ed/0x750 fs/inode.c:578\n iput_final fs/inode.c:1654 [inline]\n iput.part.0+0x3fe/0x820 fs/inode.c:1680\n iput+0x58/0x70 fs/inode.c:1670"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47293",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/e4fdca366806f6bab374d1a95e626a10a3854b0c",
            "https://git.kernel.org/stable/c/a88414fb1117f2fe65fb88e45ba694e1d09d5024",
            "https://git.kernel.org/stable/c/071729150be9e1d1b851b70efb6d91ee9269d57b",
            "https://git.kernel.org/stable/c/34f1e1f657fae2891b485a3b2b95fe4d2aef9f0d",
            "https://git.kernel.org/stable/c/727d6a8b7ef3d25080fad228b2c4a1d4da5999c6"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/sched: act_skbmod: Skip non-Ethernet packets\n\nCurrently tcf_skbmod_act() assumes that packets use Ethernet as their L2\nprotocol, which is not always the case.  As an example, for CAN devices:\n\n\t$ ip link add dev vcan0 type vcan\n\t$ ip link set up vcan0\n\t$ tc qdisc add dev vcan0 root handle 1: htb\n\t$ tc filter add dev vcan0 parent 1: protocol ip prio 10 \\\n\t\tmatchall action skbmod swap mac\n\nDoing the above silently corrupts all the packets.  Do not perform skbmod\nactions for non-Ethernet packets."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47302",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/a9508e0edfe369ac95d0825bcdca976436ce780f",
            "https://git.kernel.org/stable/c/e15f629036bac005fc758b4ad17896cf2312add4",
            "https://git.kernel.org/stable/c/ea5e36b7367ea0a36ef73a163768f16d2977bd83",
            "https://git.kernel.org/stable/c/56ea7ed103b46970e171eb1c95916f393d64eeff"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nigc: Fix use-after-free error during reset\n\nCleans the next descriptor to watch (next_to_watch) when cleaning the\nTX ring.\n\nFailure to do so can cause invalid memory accesses. If igc_poll() runs\nwhile the controller is being reset this can lead to the driver try to\nfree a skb that was already freed.\n\nLog message:\n\n [  101.525242] refcount_t: underflow; use-after-free.\n [  101.525251] WARNING: CPU: 1 PID: 646 at lib/refcount.c:28 refcount_warn_saturate+0xab/0xf0\n [  101.525259] Modules linked in: sch_etf(E) sch_mqprio(E) rfkill(E) intel_rapl_msr(E) intel_rapl_common(E)\n x86_pkg_temp_thermal(E) intel_powerclamp(E) coretemp(E) binfmt_misc(E) kvm_intel(E) kvm(E) irqbypass(E) crc32_pclmul(E)\n ghash_clmulni_intel(E) aesni_intel(E) mei_wdt(E) libaes(E) crypto_simd(E) cryptd(E) glue_helper(E) snd_hda_codec_hdmi(E)\n rapl(E) intel_cstate(E) snd_hda_intel(E) snd_intel_dspcfg(E) sg(E) soundwire_intel(E) intel_uncore(E) at24(E)\n soundwire_generic_allocation(E) iTCO_wdt(E) soundwire_cadence(E) intel_pmc_bxt(E) serio_raw(E) snd_hda_codec(E)\n iTCO_vendor_support(E) watchdog(E) snd_hda_core(E) snd_hwdep(E) snd_soc_core(E) snd_compress(E) snd_pcsp(E)\n soundwire_bus(E) snd_pcm(E) evdev(E) snd_timer(E) mei_me(E) snd(E) soundcore(E) mei(E) configfs(E) ip_tables(E) x_tables(E)\n autofs4(E) ext4(E) crc32c_generic(E) crc16(E) mbcache(E) jbd2(E) sd_mod(E) t10_pi(E) crc_t10dif(E) crct10dif_generic(E)\n i915(E) ahci(E) libahci(E) ehci_pci(E) igb(E) xhci_pci(E) ehci_hcd(E)\n [  101.525303]  drm_kms_helper(E) dca(E) xhci_hcd(E) libata(E) crct10dif_pclmul(E) cec(E) crct10dif_common(E) tsn(E) igc(E)\n e1000e(E) ptp(E) i2c_i801(E) crc32c_intel(E) psmouse(E) i2c_algo_bit(E) i2c_smbus(E) scsi_mod(E) lpc_ich(E) pps_core(E)\n usbcore(E) drm(E) button(E) video(E)\n [  101.525318] CPU: 1 PID: 646 Comm: irq/37-enp7s0-T Tainted: G            E     5.10.30-rt37-tsn1-rt-ipipe #ipipe\n [  101.525320] Hardware name: SIEMENS AG SIMATIC IPC427D/A5E31233588, BIOS V17.02.09 03/31/2017\n [  101.525322] RIP: 0010:refcount_warn_saturate+0xab/0xf0\n [  101.525325] Code: 05 31 48 44 01 01 e8 f0 c6 42 00 0f 0b c3 80 3d 1f 48 44 01 00 75 90 48 c7 c7 78 a8 f3 a6 c6 05 0f 48\n 44 01 01 e8 d1 c6 42 00 <0f> 0b c3 80 3d fe 47 44 01 00 0f 85 6d ff ff ff 48 c7 c7 d0 a8 f3\n [  101.525327] RSP: 0018:ffffbdedc0917cb8 EFLAGS: 00010286\n [  101.525329] RAX: 0000000000000000 RBX: ffff98fd6becbf40 RCX: 0000000000000001\n [  101.525330] RDX: 0000000000000001 RSI: ffffffffa6f2700c RDI: 00000000ffffffff\n [  101.525332] RBP: ffff98fd6becc14c R08: ffffffffa7463d00 R09: ffffbdedc0917c50\n [  101.525333] R10: ffffffffa74c3578 R11: 0000000000000034 R12: 00000000ffffff00\n [  101.525335] R13: ffff98fd6b0b1000 R14: 0000000000000039 R15: ffff98fd6be35c40\n [  101.525337] FS:  0000000000000000(0000) GS:ffff98fd6e240000(0000) knlGS:0000000000000000\n [  101.525339] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n [  101.525341] CR2: 00007f34135a3a70 CR3: 0000000150210003 CR4: 00000000001706e0\n [  101.525343] Call Trace:\n [  101.525346]  sock_wfree+0x9c/0xa0\n [  101.525353]  unix_destruct_scm+0x7b/0xa0\n [  101.525358]  skb_release_head_state+0x40/0x90\n [  101.525362]  skb_release_all+0xe/0x30\n [  101.525364]  napi_consume_skb+0x57/0x160\n [  101.525367]  igc_poll+0xb7/0xc80 [igc]\n [  101.525376]  ? sched_clock+0x5/0x10\n [  101.525381]  ? sched_clock_cpu+0xe/0x100\n [  101.525385]  net_rx_action+0x14c/0x410\n [  101.525388]  __do_softirq+0xe9/0x2f4\n [  101.525391]  __local_bh_enable_ip+0xe3/0x110\n [  101.525395]  ? irq_finalize_oneshot.part.47+0xe0/0xe0\n [  101.525398]  irq_forced_thread_fn+0x6a/0x80\n [  101.525401]  irq_thread+0xe8/0x180\n [  101.525403]  ? wake_threads_waitq+0x30/0x30\n [  101.525406]  ? irq_thread_check_affinity+0xd0/0xd0\n [  101.525408]  kthread+0x183/0x1a0\n [  101.525412]  ? kthread_park+0x80/0x80\n [  101.525415]  ret_from_fork+0x22/0x30"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47296",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/9bafc34dc4ad0cef18727c557f21ed3c3304df50",
            "https://git.kernel.org/stable/c/f38527f1890543cdfca8dfd06f75f9887cce6151",
            "https://git.kernel.org/stable/c/e14ef1095387f764d95614d3ec9e4d07c82a3533",
            "https://git.kernel.org/stable/c/a4a488915feaad38345cc01b80d52e8200ff5209",
            "https://git.kernel.org/stable/c/bc4188a2f56e821ea057aca6bf444e138d06c252"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: PPC: Fix kvm_arch_vcpu_ioctl vcpu_load leak\n\nvcpu_put is not called if the user copy fails. This can result in preempt\nnotifier corruption and crashes, among other issues."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47314",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/8018476756066e97ecb886c3dc024aeb7d5792ad",
            "https://git.kernel.org/stable/c/3b45b8a7d549bd92ec94b5357c2c2c1a7ed107e4",
            "https://git.kernel.org/stable/c/7626ffbea708e5aba6912295c012d2b409a1769f",
            "https://git.kernel.org/stable/c/ee1aa737ba0b75ab8af3444c4ae5bdba36aed6e6",
            "https://git.kernel.org/stable/c/443f6ca6fd186b4fa4e6f377b6e19a91feb1a0d5",
            "https://git.kernel.org/stable/c/b5789e23773f4a852fbfe244b63f675e265d3a7f",
            "https://git.kernel.org/stable/c/48ee69825f7480622ed447b0249123236d3b3ad0",
            "https://git.kernel.org/stable/c/a6b45b4932f7b0c36b41fb56a35ad679ece939a0",
            "https://git.kernel.org/stable/c/8e0d09b1232d0538066c40ed4c13086faccbdff6"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmemory: fsl_ifc: fix leak of private memory on probe failure\n\nOn probe error the driver should free the memory allocated for private\nstructure.  Fix this by using resource-managed allocation."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47337",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/d2f0b960d07e52bb664471b4de0ed8b08c636b3a",
            "https://git.kernel.org/stable/c/f3d0a109240c9bed5c60d819014786be3a2fe515",
            "https://git.kernel.org/stable/c/e1bd3fac2baa3d5c04375980c1d5263a3335af92",
            "https://git.kernel.org/stable/c/887bfae2732b5b02a86a859fd239d34f7ff93c05",
            "https://git.kernel.org/stable/c/ea518b70ed5e4598c8d706f37fc16f7b06e440bd",
            "https://git.kernel.org/stable/c/8e4212ecf0713dd57d0e3209a66201da582149b1",
            "https://git.kernel.org/stable/c/c1671d2d2ef8a84837eea1b4d99ca0c6a66fb691",
            "https://git.kernel.org/stable/c/93aa71ad7379900e61c8adff6a710a4c18c7c99b"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: core: Fix bad pointer dereference when ehandler kthread is invalid\n\nCommit 66a834d09293 (\"scsi: core: Fix error handling of scsi_host_alloc()\")\nchanged the allocation logic to call put_device() to perform host cleanup\nwith the assumption that IDA removal and stopping the kthread would\nproperly be performed in scsi_host_dev_release(). However, in the unlikely\ncase that the error handler thread fails to spawn, shost->ehandler is set\nto ERR_PTR(-ENOMEM).\n\nThe error handler cleanup code in scsi_host_dev_release() will call\nkthread_stop() if shost->ehandler != NULL which will always be the case\nwhether the kthread was successfully spawned or not. In the case that it\nfailed to spawn this has the nasty side effect of trying to dereference an\ninvalid pointer when kthread_stop() is called. The following splat provides\nan example of this behavior in the wild:\n\nscsi host11: error handler thread failed to spawn, error = -4\nKernel attempted to read user page (10c) - exploit attempt? (uid: 0)\nBUG: Kernel NULL pointer dereference on read at 0x0000010c\nFaulting instruction address: 0xc00000000818e9a8\nOops: Kernel access of bad area, sig: 11 [#1]\nLE PAGE_SIZE=64K MMU=Hash SMP NR_CPUS=2048 NUMA pSeries\nModules linked in: ibmvscsi(+) scsi_transport_srp dm_multipath dm_mirror dm_region\n hash dm_log dm_mod fuse overlay squashfs loop\nCPU: 12 PID: 274 Comm: systemd-udevd Not tainted 5.13.0-rc7 #1\nNIP:  c00000000818e9a8 LR: c0000000089846e8 CTR: 0000000000007ee8\nREGS: c000000037d12ea0 TRAP: 0300   Not tainted  (5.13.0-rc7)\nMSR:  800000000280b033 &lt;SF,VEC,VSX,EE,FP,ME,IR,DR,RI,LE&gt;  CR: 28228228\nXER: 20040001\nCFAR: c0000000089846e4 DAR: 000000000000010c DSISR: 40000000 IRQMASK: 0\nGPR00: c0000000089846e8 c000000037d13140 c000000009cc1100 fffffffffffffffc\nGPR04: 0000000000000001 0000000000000000 0000000000000000 c000000037dc0000\nGPR08: 0000000000000000 c000000037dc0000 0000000000000001 00000000fffff7ff\nGPR12: 0000000000008000 c00000000a049000 c000000037d13d00 000000011134d5a0\nGPR16: 0000000000001740 c0080000190d0000 c0080000190d1740 c000000009129288\nGPR20: c000000037d13bc0 0000000000000001 c000000037d13bc0 c0080000190b7898\nGPR24: c0080000190b7708 0000000000000000 c000000033bb2c48 0000000000000000\nGPR28: c000000046b28280 0000000000000000 000000000000010c fffffffffffffffc\nNIP [c00000000818e9a8] kthread_stop+0x38/0x230\nLR [c0000000089846e8] scsi_host_dev_release+0x98/0x160\nCall Trace:\n[c000000033bb2c48] 0xc000000033bb2c48 (unreliable)\n[c0000000089846e8] scsi_host_dev_release+0x98/0x160\n[c00000000891e960] device_release+0x60/0x100\n[c0000000087e55c4] kobject_release+0x84/0x210\n[c00000000891ec78] put_device+0x28/0x40\n[c000000008984ea4] scsi_host_alloc+0x314/0x430\n[c0080000190b38bc] ibmvscsi_probe+0x54/0xad0 [ibmvscsi]\n[c000000008110104] vio_bus_probe+0xa4/0x4b0\n[c00000000892a860] really_probe+0x140/0x680\n[c00000000892aefc] driver_probe_device+0x15c/0x200\n[c00000000892b63c] device_driver_attach+0xcc/0xe0\n[c00000000892b740] __driver_attach+0xf0/0x200\n[c000000008926f28] bus_for_each_dev+0xa8/0x130\n[c000000008929ce4] driver_attach+0x34/0x50\n[c000000008928fc0] bus_add_driver+0x1b0/0x300\n[c00000000892c798] driver_register+0x98/0x1a0\n[c00000000810eb60] __vio_register_driver+0x80/0xe0\n[c0080000190b4a30] ibmvscsi_module_init+0x9c/0xdc [ibmvscsi]\n[c0000000080121d0] do_one_initcall+0x60/0x2d0\n[c000000008261abc] do_init_module+0x7c/0x320\n[c000000008265700] load_module+0x2350/0x25b0\n[c000000008265cb4] __do_sys_finit_module+0xd4/0x160\n[c000000008031110] system_call_exception+0x150/0x2d0\n[c00000000800d35c] system_call_common+0xec/0x278\n\nFix this be nulling shost->ehandler when the kthread fails to spawn."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47342",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/b663890d854403e566169f7e90aed5cd6ff64f6b",
            "https://git.kernel.org/stable/c/7ed572cdf11081f8f9e07abd4bea56a3f2c4edbd",
            "https://git.kernel.org/stable/c/61bb4a1c417e5b95d9edb4f887f131de32e419cb"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\next4: fix possible UAF when remounting r/o a mmp-protected file system\n\nAfter commit 618f003199c6 (\"ext4: fix memory leak in\next4_fill_super\"), after the file system is remounted read-only, there\nis a race where the kmmpd thread can exit, causing sbi->s_mmp_tsk to\npoint at freed memory, which the call to ext4_stop_mmpd() can trip\nover.\n\nFix this by only allowing kmmpd() to exit when it is stopped via\next4_stop_mmpd().\n\nBug-Report-Link: <20210629143603.2166962-1-yebin10@huawei.com>"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47225",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/8043903fcb72f545c52e3ec74d6fd82ef79ce7c5",
            "https://git.kernel.org/stable/c/d5befb224edbe53056c2c18999d630dafb4a08b9"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmac80211: fix deadlock in AP/VLAN handling\n\nSyzbot reports that when you have AP_VLAN interfaces that are up\nand close the AP interface they belong to, we get a deadlock. No\nsurprise - since we dev_close() them with the wiphy mutex held,\nwhich goes back into the netdev notifier in cfg80211 and tries to\nacquire the wiphy mutex there.\n\nTo fix this, we need to do two things:\n 1) prevent changing iftype while AP_VLANs are up, we can't\n    easily fix this case since cfg80211 already calls us with\n    the wiphy mutex held, but change_interface() is relatively\n    rare in drivers anyway, so changing iftype isn't used much\n    (and userspace has to fall back to down/change/up anyway)\n 2) pull the dev_close() loop over VLANs out of the wiphy mutex\n    section in the normal stop case"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47307",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/f7d1fa65e74263d11f90ddd33b4d4cd905a93759",
            "https://git.kernel.org/stable/c/e58c162789becede894d3e94c0ce6695a2ef5796",
            "https://git.kernel.org/stable/c/ae3d181f4e912f51af7776ea165f199b16fc165d",
            "https://git.kernel.org/stable/c/03313d1c3a2f086bb60920607ab79ac8f8578306"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: prevent NULL deref in cifs_compose_mount_options()\n\nThe optional @ref parameter might contain an NULL node_name, so\nprevent dereferencing it in cifs_compose_mount_options().\n\nAddresses-Coverity: 1476408 (\"Explicit null dereferenced\")"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47327",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/3761ae0d0e549f2acdaf11f49df4ed06d256b20f",
            "https://git.kernel.org/stable/c/c4007596fbdabc29f858dc2e1990858a146b60b2",
            "https://git.kernel.org/stable/c/fbf4daa6f4105e01fbd3868006f65c163365c1e3",
            "https://git.kernel.org/stable/c/fe92c058199067ae90cf2a901ddf3c271893557a",
            "https://git.kernel.org/stable/c/1adf30f198c26539a62d761e45af72cde570413d"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\niommu/arm-smmu: Fix arm_smmu_device refcount leak when arm_smmu_rpm_get fails\n\narm_smmu_rpm_get() invokes pm_runtime_get_sync(), which increases the\nrefcount of the \"smmu\" even though the return value is less than 0.\n\nThe reference counting issue happens in some error handling paths of\narm_smmu_rpm_get() in its caller functions. When arm_smmu_rpm_get()\nfails, the caller functions forget to decrease the refcount of \"smmu\"\nincreased by arm_smmu_rpm_get(), causing a refcount leak.\n\nFix this issue by calling pm_runtime_resume_and_get() instead of\npm_runtime_get_sync() in arm_smmu_rpm_get(), which can keep the refcount\nbalanced in case of failure."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47344",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/c57b2bd3247925e253729dce283d6bf6abc9339d",
            "https://git.kernel.org/stable/c/bbc80a972a3c5d7eba3f6c9c07af8fea42f5c513",
            "https://git.kernel.org/stable/c/b0633051a6cb24186ff04ce1af99c7de18c1987e",
            "https://git.kernel.org/stable/c/021c294dff030f3ba38eb81e400ba123db32ecbc",
            "https://git.kernel.org/stable/c/0edd6759167295ea9969e89283b81017b4c688aa",
            "https://git.kernel.org/stable/c/c57bfd8000d7677bf435873b440eec0c47f73a08",
            "https://git.kernel.org/stable/c/5f3f81f1c96b501d180021c23c25e9f48eaab235",
            "https://git.kernel.org/stable/c/d69b39d89f362cfeeb54a68690768d0d257b2c8f",
            "https://git.kernel.org/stable/c/0a045eac8d0427b64577a24d74bb8347c905ac65"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: zr364xx: fix memory leak in zr364xx_start_readpipe\n\nsyzbot reported memory leak in zr364xx driver.\nThe problem was in non-freed urb in case of\nusb_submit_urb() fail.\n\nbacktrace:\n  [<ffffffff82baedf6>] kmalloc include/linux/slab.h:561 [inline]\n  [<ffffffff82baedf6>] usb_alloc_urb+0x66/0xe0 drivers/usb/core/urb.c:74\n  [<ffffffff82f7cce8>] zr364xx_start_readpipe+0x78/0x130 drivers/media/usb/zr364xx/zr364xx.c:1022\n  [<ffffffff84251dfc>] zr364xx_board_init drivers/media/usb/zr364xx/zr364xx.c:1383 [inline]\n  [<ffffffff84251dfc>] zr364xx_probe+0x6a3/0x851 drivers/media/usb/zr364xx/zr364xx.c:1516\n  [<ffffffff82bb6507>] usb_probe_interface+0x177/0x370 drivers/usb/core/driver.c:396\n  [<ffffffff826018a9>] really_probe+0x159/0x500 drivers/base/dd.c:576"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47344",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/c57b2bd3247925e253729dce283d6bf6abc9339d",
            "https://git.kernel.org/stable/c/bbc80a972a3c5d7eba3f6c9c07af8fea42f5c513",
            "https://git.kernel.org/stable/c/b0633051a6cb24186ff04ce1af99c7de18c1987e",
            "https://git.kernel.org/stable/c/021c294dff030f3ba38eb81e400ba123db32ecbc",
            "https://git.kernel.org/stable/c/0edd6759167295ea9969e89283b81017b4c688aa",
            "https://git.kernel.org/stable/c/c57bfd8000d7677bf435873b440eec0c47f73a08",
            "https://git.kernel.org/stable/c/5f3f81f1c96b501d180021c23c25e9f48eaab235",
            "https://git.kernel.org/stable/c/d69b39d89f362cfeeb54a68690768d0d257b2c8f",
            "https://git.kernel.org/stable/c/0a045eac8d0427b64577a24d74bb8347c905ac65"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: zr364xx: fix memory leak in zr364xx_start_readpipe\n\nsyzbot reported memory leak in zr364xx driver.\nThe problem was in non-freed urb in case of\nusb_submit_urb() fail.\n\nbacktrace:\n  [<ffffffff82baedf6>] kmalloc include/linux/slab.h:561 [inline]\n  [<ffffffff82baedf6>] usb_alloc_urb+0x66/0xe0 drivers/usb/core/urb.c:74\n  [<ffffffff82f7cce8>] zr364xx_start_readpipe+0x78/0x130 drivers/media/usb/zr364xx/zr364xx.c:1022\n  [<ffffffff84251dfc>] zr364xx_board_init drivers/media/usb/zr364xx/zr364xx.c:1383 [inline]\n  [<ffffffff84251dfc>] zr364xx_probe+0x6a3/0x851 drivers/media/usb/zr364xx/zr364xx.c:1516\n  [<ffffffff82bb6507>] usb_probe_interface+0x177/0x370 drivers/usb/core/driver.c:396\n  [<ffffffff826018a9>] really_probe+0x159/0x500 drivers/base/dd.c:576"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47315",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/b7a2bcb4a3731d68f938207f75ed3e1d41774510",
            "https://git.kernel.org/stable/c/bd051b3e184fa56eeb6276ee913ba4d48069024b",
            "https://git.kernel.org/stable/c/d0d04b95e8ed0223844a1d58497c686fe2e4a955",
            "https://git.kernel.org/stable/c/6b3b002de90738e3c85853a682ce7e0fa078d42b",
            "https://git.kernel.org/stable/c/94bc2fe46102d1e060fc749c0c19511e76c9995f",
            "https://git.kernel.org/stable/c/d9213d4f372d30b5bc4d921795d6bed0c0e3eebf",
            "https://git.kernel.org/stable/c/8d071d270afba468708faca5f7b6d9e656f75e27",
            "https://git.kernel.org/stable/c/83af5816308b490b05fc8fa27fc1bdc769df200a",
            "https://git.kernel.org/stable/c/28f71fd81ebd3b386bf5c7c5539664156f7d72c1",
            "https://git.kernel.org/stable/c/3b132ab67fc7a358fff35e808fa65d4bea452521"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmemory: fsl_ifc: fix leak of IO mapping on probe failure\n\nOn probe error the driver should unmap the IO memory.  Smatch reports:\n\n  drivers/memory/fsl_ifc.c:298 fsl_ifc_ctrl_probe() warn: 'fsl_ifc_ctrl_dev->gregs' not released on lines: 298."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47328",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/bf20d85a88384574fabb3d53ad62a8af57e7ab11",
            "https://git.kernel.org/stable/c/d04958a348e560938410e04a12fb99da9c7e6a00",
            "https://git.kernel.org/stable/c/89812e7957ab0746eab66ed6fc49d52bb4dca250",
            "https://git.kernel.org/stable/c/f0a031f7c55ffd944fead1ddaf2aa94df9a158c1",
            "https://git.kernel.org/stable/c/fa9542b35ceb4202e8f8d65f440529a63524dca9",
            "https://git.kernel.org/stable/c/ec29d0ac29be366450a7faffbcf8cba3a6a3b506"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: iscsi: Fix conn use after free during resets\n\nIf we haven't done a unbind target call we can race where\niscsi_conn_teardown wakes up the EH thread and then frees the conn while\nthose threads are still accessing the conn ehwait.\n\nWe can only do one TMF per session so this just moves the TMF fields from\nthe conn to the session. We can then rely on the\niscsi_session_teardown->iscsi_remove_session->__iscsi_unbind_session call\nto remove the target and it's devices, and know after that point there is\nno device or scsi-ml callout trying to access the session."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47339",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/dc02c0b2bd6096f2f3ce63e1fc317aeda05f74d8",
            "https://git.kernel.org/stable/c/bfb48b54db25c3b4ef4bef5e0691464ebc4aa335",
            "https://git.kernel.org/stable/c/7b53cca764f9b291b7907fcd39d9e66ad728ee0b"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmedia: v4l2-core: explicitly clear ioctl input data\n\nAs seen from a recent syzbot bug report, mistakes in the compat ioctl\nimplementation can lead to uninitialized kernel stack data getting used\nas input for driver ioctl handlers.\n\nThe reported bug is now fixed, but it's possible that other related\nbugs are still present or get added in the future. As the drivers need\nto check user input already, the possible impact is fairly low, but it\nmight still cause an information leak.\n\nTo be on the safe side, always clear the entire ioctl buffer before\ncalling the conversion handler functions that are meant to initialize\nthem."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47317",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/7284dab07e4d51d453cc42851fae9ec4fac6ef2f",
            "https://git.kernel.org/stable/c/0d435b6d94b05dcfd836d758a63145aa566618e2",
            "https://git.kernel.org/stable/c/419ac821766cbdb9fd85872bb3f1a589df05c94c"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\npowerpc/bpf: Fix detecting BPF atomic instructions\n\nCommit 91c960b0056672 (\"bpf: Rename BPF_XADD and prepare to encode other\natomics in .imm\") converted BPF_XADD to BPF_ATOMIC and added a way to\ndistinguish instructions based on the immediate field. Existing JIT\nimplementations were updated to check for the immediate field and to\nreject programs utilizing anything more than BPF_ADD (such as BPF_FETCH)\nin the immediate field.\n\nHowever, the check added to powerpc64 JIT did not look at the correct\nBPF instruction. Due to this, such programs would be accepted and\nincorrectly JIT'ed resulting in soft lockups, as seen with the atomic\nbounds test. Fix this by looking at the correct immediate value."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47355",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/99779c9d9ffc7775da6f7fd8a7c93ac61657bed5",
            "https://git.kernel.org/stable/c/4e2a0848ea2cab0716d46f85a8ccd5fa9a493e51",
            "https://git.kernel.org/stable/c/c471569632654e57c83512e0fc1ba0dbb4544ad6",
            "https://git.kernel.org/stable/c/a7a7b2848312cc4c3a42b6e42a8ab2e441857aba",
            "https://git.kernel.org/stable/c/bdf5334250c69fabf555b7322c75249ea7d5f148",
            "https://git.kernel.org/stable/c/a7f7c42e31157d1f0871d6a8e1a0b73a6b4ea785",
            "https://git.kernel.org/stable/c/2f958b6f6ba0854b39be748d21dfe71e0fe6580f",
            "https://git.kernel.org/stable/c/5b991df8881088448cb223e769e37cab8dd40706",
            "https://git.kernel.org/stable/c/34e7434ba4e97f4b85c1423a59b2922ba7dff2ea"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\natm: nicstar: Fix possible use-after-free in nicstar_cleanup()\n\nThis module's remove path calls del_timer(). However, that function\ndoes not wait until the timer handler finishes. This means that the\ntimer handler may still be running after the driver's remove function\nhas finished, which would result in a use-after-free.\n\nFix by calling del_timer_sync(), which makes sure the timer handler\nhas finished, and unable to re-schedule itself."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47351",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/7adc05b73d91a5e3d4ca7714fa53ad9b70c53d08",
            "https://git.kernel.org/stable/c/38dde03eb239605f428f3f1e4baa73d4933a4cc6",
            "https://git.kernel.org/stable/c/9558612cb829f2c022b788f55d6b8437d5234a82",
            "https://git.kernel.org/stable/c/c0756f75c22149d20fcb7d8409827cee905eb386",
            "https://git.kernel.org/stable/c/f4e3634a3b642225a530c292fdb1e8a4007507f5"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nubifs: Fix races between xattr_{set|get} and listxattr operations\n\nUBIFS may occur some problems with concurrent xattr_{set|get} and\nlistxattr operations, such as assertion failure, memory corruption,\nstale xattr value[1].\n\nFix it by importing a new rw-lock in @ubifs_inode to serilize write\noperations on xattr, concurrent read operations are still effective,\njust like ext4.\n\n[1] https://lore.kernel.org/linux-mtd/20200630130438.141649-1-houtao1@huawei.com"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47345",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/40b613db3a95bc27998e4097d74c2f7e5d083a0b",
            "https://git.kernel.org/stable/c/e2da8ce2a9543f3ca5c93369bd1fe6eeb572101a",
            "https://git.kernel.org/stable/c/e4e062da082a199357ba4911145f331d40139ad8",
            "https://git.kernel.org/stable/c/4893c938f2a140a74be91779e45e4a7fa111198f",
            "https://git.kernel.org/stable/c/032c68b4f5be128a2167f35b558b7cec88fe4972",
            "https://git.kernel.org/stable/c/3d08b5917984f737f32d5bee9737b9075c3895c6",
            "https://git.kernel.org/stable/c/f4f553d67236145fa5fd203ed7b35b9377e19939",
            "https://git.kernel.org/stable/c/07583ba2e2d8947c3d365d97608cb436510885ac",
            "https://git.kernel.org/stable/c/74f160ead74bfe5f2b38afb4fcf86189f9ff40c9"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nRDMA/cma: Fix rdma_resolve_route() memory leak\n\nFix a memory leak when \"mda_resolve_route() is called more than once on\nthe same \"rdma_cm_id\".\n\nThis is possible if cma_query_handler() triggers the\nRDMA_CM_EVENT_ROUTE_ERROR flow which puts the state machine back and\nallows rdma_resolve_route() to be called again."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47321",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/58606882ad8ec6c39e0f40344b922921ef94ab4d",
            "https://git.kernel.org/stable/c/ca96b8ea5e74956071154bdb456778cc3027e79f",
            "https://git.kernel.org/stable/c/8bec568d7518b1504a602ed5376bb322e4dbb270",
            "https://git.kernel.org/stable/c/ecd620e0fb1ff7f78fdb593379b2e6938c99707a",
            "https://git.kernel.org/stable/c/db222f1477ad5692cd454709b714949807e5d111",
            "https://git.kernel.org/stable/c/66ba9cf929b1c4fabf545bd4c18f6f64e23e46e4",
            "https://git.kernel.org/stable/c/4c05dac488a660fe2925c047ecb119e7afaaeb1e",
            "https://git.kernel.org/stable/c/1a053c4d716898a53c2e31c574a70ea0c37044a3",
            "https://git.kernel.org/stable/c/d0212f095ab56672f6f36aabc605bda205e1e0bf"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nwatchdog: Fix possible use-after-free by calling del_timer_sync()\n\nThis driver's remove path calls del_timer(). However, that function\ndoes not wait until the timer handler finishes. This means that the\ntimer handler may still be running after the driver's remove function\nhas finished, which would result in a use-after-free.\n\nFix by calling del_timer_sync(), which makes sure the timer handler\nhas finished, and unable to re-schedule itself."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47230",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/cbb425f62df9df7abee4b3f068f7ed6ffc3561e2",
            "https://git.kernel.org/stable/c/669a8866e468fd020d34eb00e08cb41d3774b71b",
            "https://git.kernel.org/stable/c/df9a40cfb3be2cbeb1c17bb67c59251ba16630f3",
            "https://git.kernel.org/stable/c/78fcb2c91adfec8ce3a2ba6b4d0dda89f2f4a7c6"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86: Immediately reset the MMU context when the SMM flag is cleared\n\nImmediately reset the MMU context when the vCPU's SMM flag is cleared so\nthat the SMM flag in the MMU role is always synchronized with the vCPU's\nflag.  If RSM fails (which isn't correctly emulated), KVM will bail\nwithout calling post_leave_smm() and leave the MMU in a bad state.\n\nThe bad MMU role can lead to a NULL pointer dereference when grabbing a\nshadow page's rmap for a page fault as the initial lookups for the gfn\nwill happen with the vCPU's SMM flag (=0), whereas the rmap lookup will\nuse the shadow page's SMM flag, which comes from the MMU (=1).  SMM has\nan entirely different set of memslots, and so the initial lookup can find\na memslot (SMM=0) and then explode on the rmap memslot lookup (SMM=1).\n\n  general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN\n  KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]\n  CPU: 1 PID: 8410 Comm: syz-executor382 Not tainted 5.13.0-rc5-syzkaller #0\n  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\n  RIP: 0010:__gfn_to_rmap arch/x86/kvm/mmu/mmu.c:935 [inline]\n  RIP: 0010:gfn_to_rmap+0x2b0/0x4d0 arch/x86/kvm/mmu/mmu.c:947\n  Code: <42> 80 3c 20 00 74 08 4c 89 ff e8 f1 79 a9 00 4c 89 fb 4d 8b 37 44\n  RSP: 0018:ffffc90000ffef98 EFLAGS: 00010246\n  RAX: 0000000000000000 RBX: ffff888015b9f414 RCX: ffff888019669c40\n  RDX: 0000000000000000 RSI: 0000000000000001 RDI: 0000000000000001\n  RBP: 0000000000000001 R08: ffffffff811d9cdb R09: ffffed10065a6002\n  R10: ffffed10065a6002 R11: 0000000000000000 R12: dffffc0000000000\n  R13: 0000000000000003 R14: 0000000000000001 R15: 0000000000000000\n  FS:  000000000124b300(0000) GS:ffff8880b9b00000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 0000000000000000 CR3: 0000000028e31000 CR4: 00000000001526e0\n  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n  Call Trace:\n   rmap_add arch/x86/kvm/mmu/mmu.c:965 [inline]\n   mmu_set_spte+0x862/0xe60 arch/x86/kvm/mmu/mmu.c:2604\n   __direct_map arch/x86/kvm/mmu/mmu.c:2862 [inline]\n   direct_page_fault+0x1f74/0x2b70 arch/x86/kvm/mmu/mmu.c:3769\n   kvm_mmu_do_page_fault arch/x86/kvm/mmu.h:124 [inline]\n   kvm_mmu_page_fault+0x199/0x1440 arch/x86/kvm/mmu/mmu.c:5065\n   vmx_handle_exit+0x26/0x160 arch/x86/kvm/vmx/vmx.c:6122\n   vcpu_enter_guest+0x3bdd/0x9630 arch/x86/kvm/x86.c:9428\n   vcpu_run+0x416/0xc20 arch/x86/kvm/x86.c:9494\n   kvm_arch_vcpu_ioctl_run+0x4e8/0xa40 arch/x86/kvm/x86.c:9722\n   kvm_vcpu_ioctl+0x70f/0xbb0 arch/x86/kvm/../../../virt/kvm/kvm_main.c:3460\n   vfs_ioctl fs/ioctl.c:51 [inline]\n   __do_sys_ioctl fs/ioctl.c:1069 [inline]\n   __se_sys_ioctl+0xfb/0x170 fs/ioctl.c:1055\n   do_syscall_64+0x3f/0xb0 arch/x86/entry/common.c:47\n   entry_SYSCALL_64_after_hwframe+0x44/0xae\n  RIP: 0033:0x440ce9"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47358",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/92b67aaafb7c449db9f0c3dcabc0ff967cb3a42d",
            "https://git.kernel.org/stable/c/64062fcaca8872f063ec9da011e7bf30470be33f",
            "https://git.kernel.org/stable/c/a5cfd51f6348e8fd7531461366946039c29c7e69",
            "https://git.kernel.org/stable/c/4dc56951a8d9d61d364d346c61a5f1d70b4f5e14",
            "https://git.kernel.org/stable/c/b9e697e60ce9890e9258a73eb061288e7d68e5e6",
            "https://git.kernel.org/stable/c/9872ff6fdce8b229f01993b611b5d1719cb70ff1",
            "https://git.kernel.org/stable/c/92dc0b1f46e12cfabd28d709bb34f7a39431b44f"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nstaging: greybus: uart: fix tty use after free\n\nUser space can hold a tty open indefinitely and tty drivers must not\nrelease the underlying structures until the last user is gone.\n\nSwitch to using the tty-port reference counter to manage the life time\nof the greybus tty state to avoid use after free after a disconnect."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47348",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/c5b518f4b98dbb2bc31b6a55e6aaa1e0e2948f2e",
            "https://git.kernel.org/stable/c/44c7c901cb368a9f2493748f213b247b5872639f",
            "https://git.kernel.org/stable/c/3b2b93a485fb7a970bc8b5daef16f4cf579d172f",
            "https://git.kernel.org/stable/c/06888d571b513cbfc0b41949948def6cb81021b2"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Avoid HDCP over-read and corruption\n\nInstead of reading the desired 5 bytes of the actual target field,\nthe code was reading 8. This could result in a corrupted value if the\ntrailing 3 bytes were non-zero, so instead use an appropriately sized\nand zero-initialized bounce buffer, and read only 5 bytes before casting\nto u64."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47319",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/381bde79d11e596002edfd914e6714291826967a",
            "https://git.kernel.org/stable/c/102d6bc6475ab09bab579c18704e6cf8d898e93c",
            "https://git.kernel.org/stable/c/863da837964c80c72e368a4f748c30d25daa1815",
            "https://git.kernel.org/stable/c/600942d2fd49b90e44857d20c774b20d16f3130f",
            "https://git.kernel.org/stable/c/04c6e60b884cb5e94ff32af46867fb41d5848358",
            "https://git.kernel.org/stable/c/cd24da0db9f75ca11eaf6060f0ccb90e2f3be3b0",
            "https://git.kernel.org/stable/c/ca2b8ae93a6da9839dc7f9eb9199b18aa03c3dae",
            "https://git.kernel.org/stable/c/29a2f4a3214aa14d61cc9737c9f886dae9dbb710",
            "https://git.kernel.org/stable/c/b71ba22e7c6c6b279c66f53ee7818709774efa1f"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nvirtio-blk: Fix memory leak among suspend/resume procedure\n\nThe vblk->vqs should be freed before we call init_vqs()\nin virtblk_restore()."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47236",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/f12554b0ff639e74612cc01b3b4a049e098d2d65",
            "https://git.kernel.org/stable/c/14184ec5c958b589ba934da7363a2877879204df",
            "https://git.kernel.org/stable/c/1bcacd6088d61c0ac6a990d87975600a81f3247e",
            "https://git.kernel.org/stable/c/f4e6a7f19c82f39b1803e91c54718f0d7143767d",
            "https://git.kernel.org/stable/c/81de2ed06df8b5451e050fe6a318af3263dbff3f",
            "https://git.kernel.org/stable/c/05b2b9f7d24b5663d9b47427fe1555bdafd3ea02",
            "https://git.kernel.org/stable/c/b4f7a9fc9d094c0c4a66f2ad7c37b1dbe9e78f88",
            "https://git.kernel.org/stable/c/c3b26fdf1b32f91c7a3bc743384b4a298ab53ad7"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: cdc_eem: fix tx fixup skb leak\n\nwhen usbnet transmit a skb, eem fixup it in eem_tx_fixup(),\nif skb_copy_expand() failed, it return NULL,\nusbnet_start_xmit() will have no chance to free original skb.\n\nfix it by free orginal skb in eem_tx_fixup() first,\nthen check skb clone status, if failed, return NULL to usbnet."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47357",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/9e161687855175334ca93c6c3ccb221731194479",
            "https://git.kernel.org/stable/c/a832ee2f2145f57443b2d565f8cb5490e8339f42",
            "https://git.kernel.org/stable/c/bcdd2be48edd8c6867fb44112cb8d18086beae29",
            "https://git.kernel.org/stable/c/89ce0b0747f319eb70f85bc820dcc43cebbd5417",
            "https://git.kernel.org/stable/c/c9172498d4d62c9b64e5fb37c1ee0343e65fe51b",
            "https://git.kernel.org/stable/c/e759ff76ebbbfcdcf83b6634c54dc47828573d8b",
            "https://git.kernel.org/stable/c/b58d246a058ae88484758cd4ab27b3180fd5ecf8",
            "https://git.kernel.org/stable/c/d1fb12412874c94ad037e11d0ecdd1140a439297",
            "https://git.kernel.org/stable/c/1c72e6ab66b9598cac741ed397438a52065a8f1f"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\natm: iphase: fix possible use-after-free in ia_module_exit()\n\nThis module's remove path calls del_timer(). However, that function\ndoes not wait until the timer handler finishes. This means that the\ntimer handler may still be running after the driver's remove function\nhas finished, which would result in a use-after-free.\n\nFix by calling del_timer_sync(), which makes sure the timer handler\nhas finished, and unable to re-schedule itself."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47353",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/2f3d9ddd32a28803baa547e6274983b67d5e287c",
            "https://git.kernel.org/stable/c/371566f63cbd0bb6fbb25b8fe9d5798268d35af9",
            "https://git.kernel.org/stable/c/baea588a42d675e35daeaddd10fbc9700550bc4d",
            "https://git.kernel.org/stable/c/3638705ecd5ad2785e996f820121c0ad15ce64b5",
            "https://git.kernel.org/stable/c/80d505aee6398cf8beb72475c7edcf1733c1c68b",
            "https://git.kernel.org/stable/c/21bf1414580c36ffc8d8de043beb3508cf812238",
            "https://git.kernel.org/stable/c/aebed6b19e51a34003d998da5ebb1dfdd2cb1d02",
            "https://git.kernel.org/stable/c/5150877e4d99f85057a458daac7cd7c01005d5c6",
            "https://git.kernel.org/stable/c/fa236c2b2d4436d9f19ee4e5d5924e90ffd7bb43"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nudf: Fix NULL pointer dereference in udf_symlink function\n\nIn function udf_symlink, epos.bh is assigned with the value returned\nby udf_tgetblk. The function udf_tgetblk is defined in udf/misc.c\nand returns the value of sb_getblk function that could be NULL.\nThen, epos.bh is used without any check, causing a possible\nNULL pointer dereference when sb_getblk fails.\n\nThis fix adds a check to validate the value of epos.bh."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47359",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/9f6c7aff21f81ae8856da1f63847d1362d523409",
            "https://git.kernel.org/stable/c/71826b068884050d5fdd37fda857ba1539c513d3"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: Fix soft lockup during fsstress\n\nBelow traces are observed during fsstress and system got hung.\n[  130.698396] watchdog: BUG: soft lockup - CPU#6 stuck for 26s!"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47359",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/9f6c7aff21f81ae8856da1f63847d1362d523409",
            "https://git.kernel.org/stable/c/71826b068884050d5fdd37fda857ba1539c513d3"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: Fix soft lockup during fsstress\n\nBelow traces are observed during fsstress and system got hung.\n[  130.698396] watchdog: BUG: soft lockup - CPU#6 stuck for 26s!"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47326",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/00fcd8f33e9b9f57115c3b1cfc4cb96450c18796",
            "https://git.kernel.org/stable/c/74569cb9ed7bc60e395927f55d3dc3be143a0164",
            "https://git.kernel.org/stable/c/74d6fcea1d896800e60f1c675137efebd1a6c9a6",
            "https://git.kernel.org/stable/c/afb04d0b5543a5bf8e157b9119fbfc52606f4c11",
            "https://git.kernel.org/stable/c/2beb4a53fc3f1081cedc1c1a198c7f56cc4fc60c"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/signal: Detect and prevent an alternate signal stack overflow\n\nThe kernel pushes context on to the userspace stack to prepare for the\nuser's signal handler. When the user has supplied an alternate signal\nstack, via sigaltstack(2), it is easy for the kernel to verify that the\nstack size is sufficient for the current hardware context.\n\nCheck if writing the hardware context to the alternate stack will exceed\nit's size. If yes, then instead of corrupting user-data and proceeding with\nthe original signal handler, an immediate SIGSEGV signal is delivered.\n\nRefactor the stack pointer check code from on_sig_stack() and use the new\nhelper.\n\nWhile the kernel allows new source code to discover and use a sufficient\nalternate signal stack size, this check is still necessary to protect\nbinaries with insufficient alternate signal stack size from data\ncorruption."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47239",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/7cc8b2e05fcea6edd022d26e82091d781af8fd9b",
            "https://git.kernel.org/stable/c/64160d1741a3de5204d1a822e058e0b4cc526504",
            "https://git.kernel.org/stable/c/c4e3be2e7742863e454ce31faf8fd0109c00050b",
            "https://git.kernel.org/stable/c/2fc8300c9cfa5167fcb5b1a2a07db6f53e82f59b",
            "https://git.kernel.org/stable/c/4252bf6c2b245f47011098113d405ffad6ad5d5b",
            "https://git.kernel.org/stable/c/570a52cf3e01d19f7fd1a251dfc52b0cd86c13cb",
            "https://git.kernel.org/stable/c/14616c372a7be01a2fb8c56c9d8debd232b9e43d",
            "https://git.kernel.org/stable/c/56b786d86694e079d8aad9b314e015cd4ac02a3d"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: usb: fix possible use-after-free in smsc75xx_bind\n\nThe commit 46a8b29c6306 (\"net: usb: fix memory leak in smsc75xx_bind\")\nfails to clean up the work scheduled in smsc75xx_reset->\nsmsc75xx_set_multicast, which leads to use-after-free if the work is\nscheduled to start after the deallocation. In addition, this patch\nalso removes a dangling pointer - dev->data[0].\n\nThis patch calls cancel_work_sync to cancel the scheduled work and set\nthe dangling pointer to NULL."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47361",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/8a558261fa57a6deefb0925ab1829f698b194aea",
            "https://git.kernel.org/stable/c/115b07d9f47e3996430b8f2007edd9768e1f807f",
            "https://git.kernel.org/stable/c/66f74ba9be9daf9c47fface6af3677f602774f6b",
            "https://git.kernel.org/stable/c/7751f609eadf36b1f53712bae430019c53a16eb0",
            "https://git.kernel.org/stable/c/91e4ad05bf18322b5921d1a6c9b603f6eb1694f0",
            "https://git.kernel.org/stable/c/9fc198f415dee070a1de957bb5bf5921d8df3499",
            "https://git.kernel.org/stable/c/25a1433216489de4abc889910f744e952cb6dbae"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmcb: fix error handling in mcb_alloc_bus()\n\nThere are two bugs:\n1) If ida_simple_get() fails then this code calls put_device(carrier)\n   but we haven't yet called get_device(carrier) and probably that\n   leads to a use after free.\n2) After device_initialize() then we need to use put_device() to\n   release the bus.  This will free the internal resources tied to the\n   device and call mcb_free_bus() which will free the rest."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47361",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/8a558261fa57a6deefb0925ab1829f698b194aea",
            "https://git.kernel.org/stable/c/115b07d9f47e3996430b8f2007edd9768e1f807f",
            "https://git.kernel.org/stable/c/66f74ba9be9daf9c47fface6af3677f602774f6b",
            "https://git.kernel.org/stable/c/7751f609eadf36b1f53712bae430019c53a16eb0",
            "https://git.kernel.org/stable/c/91e4ad05bf18322b5921d1a6c9b603f6eb1694f0",
            "https://git.kernel.org/stable/c/9fc198f415dee070a1de957bb5bf5921d8df3499",
            "https://git.kernel.org/stable/c/25a1433216489de4abc889910f744e952cb6dbae"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmcb: fix error handling in mcb_alloc_bus()\n\nThere are two bugs:\n1) If ida_simple_get() fails then this code calls put_device(carrier)\n   but we haven't yet called get_device(carrier) and probably that\n   leads to a use after free.\n2) After device_initialize() then we need to use put_device() to\n   release the bus.  This will free the internal resources tied to the\n   device and call mcb_free_bus() which will free the rest."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47324",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/63a3dc24bd053792f84cb4eef0168b1266202a02",
            "https://git.kernel.org/stable/c/862f2b5a7c38762ac9e369daefbf361a91aca685",
            "https://git.kernel.org/stable/c/0ac50a76cf3cd63db000648b3b19f3f98b8aaa76",
            "https://git.kernel.org/stable/c/dc9403097be52d57a5c9c35efa9be79d166a78af",
            "https://git.kernel.org/stable/c/146cc288fb80c662c9c35e7bc58325d1ac0a7875",
            "https://git.kernel.org/stable/c/a397cb4576fc2fc802562418b3a50b8f67d60d31",
            "https://git.kernel.org/stable/c/b4ebf4a4692e84163a69444c70ad515de06e2259",
            "https://git.kernel.org/stable/c/8adbbe6c86bb13e14f8a19e036ae5f4f5661fd90",
            "https://git.kernel.org/stable/c/c08a6b31e4917034f0ed0cb457c3bb209576f542"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nwatchdog: Fix possible use-after-free in wdt_startup()\n\nThis module's remove path calls del_timer(). However, that function\ndoes not wait until the timer handler finishes. This means that the\ntimer handler may still be running after the driver's remove function\nhas finished, which would result in a use-after-free.\n\nFix by calling del_timer_sync(), which makes sure the timer handler\nhas finished, and unable to re-schedule itself."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47356",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/49331c07ef0f8fdfa42b30ba6a83a657b29d7fbe",
            "https://git.kernel.org/stable/c/54ff3202928952a100c477248e65ac6db01258a7",
            "https://git.kernel.org/stable/c/7867ddc5f3de7f289aee63233afc0df4b62834c5",
            "https://git.kernel.org/stable/c/5f2818185da0fe82a932f0856633038b66faf124",
            "https://git.kernel.org/stable/c/3ecd228c636ee17c14662729737fa07242a93cb0",
            "https://git.kernel.org/stable/c/b7ee9ae1e0cf55a037c4a99af2acc5d78cb7802d",
            "https://git.kernel.org/stable/c/61370ff07e0acc657559a8fac02551dfeb9d3020",
            "https://git.kernel.org/stable/c/ed7c3739d0a07e2ec3ccbffe7e93cea01c438cda",
            "https://git.kernel.org/stable/c/009fc857c5f6fda81f2f7dd851b2d54193a8e733"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmISDN: fix possible use-after-free in HFC_cleanup()\n\nThis module's remove path calls del_timer(). However, that function\ndoes not wait until the timer handler finishes. This means that the\ntimer handler may still be running after the driver's remove function\nhas finished, which would result in a use-after-free.\n\nFix by calling del_timer_sync(), which makes sure the timer handler\nhas finished, and unable to re-schedule itself."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47371",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/741760fa6252628a3d3afad439b72437d4b123d9",
            "https://git.kernel.org/stable/c/3106a0847525befe3e22fc723909d1b21eb0d520"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnexthop: Fix memory leaks in nexthop notification chain listeners\n\nsyzkaller discovered memory leaks [1] that can be reduced to the\nfollowing commands:\n\n # ip nexthop add id 1 blackhole\n # devlink dev reload pci/0000:06:00.0\n\nAs part of the reload flow, mlxsw will unregister its netdevs and then\nunregister from the nexthop notification chain. Before unregistering\nfrom the notification chain, mlxsw will receive delete notifications for\nnexthop objects using netdevs registered by mlxsw or their uppers. mlxsw\nwill not receive notifications for nexthops using netdevs that are not\ndismantled as part of the reload flow. For example, the blackhole\nnexthop above that internally uses the loopback netdev as its nexthop\ndevice.\n\nOne way to fix this problem is to have listeners flush their nexthop\ntables after unregistering from the notification chain. This is\nerror-prone as evident by this patch and also not symmetric with the\nregistration path where a listener receives a dump of all the existing\nnexthops.\n\nTherefore, fix this problem by replaying delete notifications for the\nlistener being unregistered. This is symmetric to the registration path\nand also consistent with the netdev notification chain.\n\nThe above means that unregister_nexthop_notifier(), like\nregister_nexthop_notifier(), will have to take RTNL in order to iterate\nover the existing nexthops and that any callers of the function cannot\nhold RTNL. This is true for mlxsw and netdevsim, but not for the VXLAN\ndriver. To avoid a deadlock, change the latter to unregister its nexthop\nlistener without holding RTNL, making it symmetric to the registration\npath.\n\n[1]\nunreferenced object 0xffff88806173d600 (size 512):\n  comm \"syz-executor.0\", pid 1290, jiffies 4295583142 (age 143.507s)\n  hex dump (first 32 bytes):\n    41 9d 1e 60 80 88 ff ff 08 d6 73 61 80 88 ff ff  A..`......sa....\n    08 d6 73 61 80 88 ff ff 01 00 00 00 00 00 00 00  ..sa............\n  backtrace:\n    [<ffffffff81a6b576>] kmemleak_alloc_recursive include/linux/kmemleak.h:43 [inline]\n    [<ffffffff81a6b576>] slab_post_alloc_hook+0x96/0x490 mm/slab.h:522\n    [<ffffffff81a716d3>] slab_alloc_node mm/slub.c:3206 [inline]\n    [<ffffffff81a716d3>] slab_alloc mm/slub.c:3214 [inline]\n    [<ffffffff81a716d3>] kmem_cache_alloc_trace+0x163/0x370 mm/slub.c:3231\n    [<ffffffff82e8681a>] kmalloc include/linux/slab.h:591 [inline]\n    [<ffffffff82e8681a>] kzalloc include/linux/slab.h:721 [inline]\n    [<ffffffff82e8681a>] mlxsw_sp_nexthop_obj_group_create drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c:4918 [inline]\n    [<ffffffff82e8681a>] mlxsw_sp_nexthop_obj_new drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c:5054 [inline]\n    [<ffffffff82e8681a>] mlxsw_sp_nexthop_obj_event+0x59a/0x2910 drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c:5239\n    [<ffffffff813ef67d>] notifier_call_chain+0xbd/0x210 kernel/notifier.c:83\n    [<ffffffff813f0662>] blocking_notifier_call_chain kernel/notifier.c:318 [inline]\n    [<ffffffff813f0662>] blocking_notifier_call_chain+0x72/0xa0 kernel/notifier.c:306\n    [<ffffffff8384b9c6>] call_nexthop_notifiers+0x156/0x310 net/ipv4/nexthop.c:244\n    [<ffffffff83852bd8>] insert_nexthop net/ipv4/nexthop.c:2336 [inline]\n    [<ffffffff83852bd8>] nexthop_add net/ipv4/nexthop.c:2644 [inline]\n    [<ffffffff83852bd8>] rtm_new_nexthop+0x14e8/0x4d10 net/ipv4/nexthop.c:2913\n    [<ffffffff833e9a78>] rtnetlink_rcv_msg+0x448/0xbf0 net/core/rtnetlink.c:5572\n    [<ffffffff83608703>] netlink_rcv_skb+0x173/0x480 net/netlink/af_netlink.c:2504\n    [<ffffffff833de032>] rtnetlink_rcv+0x22/0x30 net/core/rtnetlink.c:5590\n    [<ffffffff836069de>] netlink_unicast_kernel net/netlink/af_netlink.c:1314 [inline]\n    [<ffffffff836069de>] netlink_unicast+0x5ae/0x7f0 net/netlink/af_netlink.c:1340\n    [<ffffffff83607501>] netlink_sendmsg+0x8e1/0xe30 net/netlink/af_netlink.c:1929\n    [<ffffffff832fde84>] sock_sendmsg_nosec net/socket.c:704 [inline\n---truncated---"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47329",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/0c6226601c3e191a44a57d8f9f814b7e5c308959",
            "https://git.kernel.org/stable/c/0680db6f41920b2c91c7df3cc9cd5968701a6f74",
            "https://git.kernel.org/stable/c/04b6b9ea80906e3b41ff120b45db31768947cf72",
            "https://git.kernel.org/stable/c/e623f79691c5104317669ab36ec316a90c05062f",
            "https://git.kernel.org/stable/c/b5438f48fdd8e1c3f130d32637511efd32038152"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nscsi: megaraid_sas: Fix resource leak in case of probe failure\n\nThe driver doesn't clean up all the allocated resources properly when\nscsi_add_host(), megasas_start_aen() function fails during the PCI device\nprobe.\n\nClean up all those resources."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47332",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/88262229b778f4f7a896da828d966f94dcb35d19",
            "https://git.kernel.org/stable/c/7d7f30cf182e55023fa8fde4c084b2d37c6be69d",
            "https://git.kernel.org/stable/c/bee295f5e03510252d18b25cc1d26230256eb87a",
            "https://git.kernel.org/stable/c/82e5ee742fdd8874fe996181b87fafe1eb5f1196",
            "https://git.kernel.org/stable/c/cae0cf651adccee2c3f376e78f30fbd788d0829f"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nALSA: usx2y: Don't call free_pages_exact() with NULL address\n\nUnlike some other functions, we can't pass NULL pointer to\nfree_pages_exact().  Add a proper NULL check for avoiding possible\nOops."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47334",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/1512e7dc5eb08b7d92a12e2bfcd9cb8c4a1ec069",
            "https://git.kernel.org/stable/c/29ba8e2ba89ee2862a26d91204dd5fe77ceee25a",
            "https://git.kernel.org/stable/c/5b06ca113bf197aab2ab61288f42506e0049fbab",
            "https://git.kernel.org/stable/c/481a76d4749ee3a27f902ba213fdcbb4bb39720e",
            "https://git.kernel.org/stable/c/38660031e80eaa6cc9370b031c180612f414b00d",
            "https://git.kernel.org/stable/c/b9c87ce3bc6331f82811a8cf8e930423c22523a3",
            "https://git.kernel.org/stable/c/ef1067d2baa847d53c9988510d99fb494de4d12c",
            "https://git.kernel.org/stable/c/a7268e8a227d5a4f0bd1584f556246b0224ab274",
            "https://git.kernel.org/stable/c/7272b591c4cb9327c43443f67b8fbae7657dd9ae"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmisc/libmasm/module: Fix two use after free in ibmasm_init_one\n\nIn ibmasm_init_one, it calls ibmasm_init_remote_input_dev().\nInside ibmasm_init_remote_input_dev, mouse_dev and keybd_dev are\nallocated by input_allocate_device(), and assigned to\nsp->remote.mouse_dev and sp->remote.keybd_dev respectively.\n\nIn the err_free_devices error branch of ibmasm_init_one,\nmouse_dev and keybd_dev are freed by input_free_device(), and return\nerror. Then the execution runs into error_send_message error branch\nof ibmasm_init_one, where ibmasm_free_remote_input_dev(sp) is called\nto unregister the freed sp->remote.mouse_dev and sp->remote.keybd_dev.\n\nMy patch add a \"error_init_remote\" label to handle the error of\nibmasm_init_remote_input_dev(), to avoid the uaf bugs."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47366",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/e66fc460d6dcf85cf12288e133a081205aebcd97",
            "https://git.kernel.org/stable/c/b537a3c21775075395af475dcc6ef212fcf29db8"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nafs: Fix corruption in reads at fpos 2G-4G from an OpenAFS server\n\nAFS-3 has two data fetch RPC variants, FS.FetchData and FS.FetchData64, and\nLinux's afs client switches between them when talking to a non-YFS server\nif the read size, the file position or the sum of the two have the upper 32\nbits set of the 64-bit value.\n\nThis is a problem, however, since the file position and length fields of\nFS.FetchData are *signed* 32-bit values.\n\nFix this by capturing the capability bits obtained from the fileserver when\nit's sent an FS.GetCapabilities RPC, rather than just discarding them, and\nthen picking out the VICED_CAPABILITY_64BITFILES flag.  This can then be\nused to decide whether to use FS.FetchData or FS.FetchData64 - and also\nFS.StoreData or FS.StoreData64 - rather than using upper_32_bits() to\nswitch on the parameter values.\n\nThis capabilities flag could also be used to limit the maximum size of the\nfile, but all servers must be checked for that.\n\nNote that the issue does not exist with FS.StoreData - that uses *unsigned*\n32-bit values.  It's also not a problem with Auristor servers as its\nYFS.FetchData64 op uses unsigned 64-bit values.\n\nThis can be tested by cloning a git repo through an OpenAFS client to an\nOpenAFS server and then doing \"git status\" on it from a Linux afs\nclient[1].  Provided the clone has a pack file that's in the 2G-4G range,\nthe git status will show errors like:\n\n\terror: packfile .git/objects/pack/pack-5e813c51d12b6847bbc0fcd97c2bca66da50079c.pack does not match index\n\terror: packfile .git/objects/pack/pack-5e813c51d12b6847bbc0fcd97c2bca66da50079c.pack does not match index\n\nThis can be observed in the server's FileLog with something like the\nfollowing appearing:\n\nSun Aug 29 19:31:39 2021 SRXAFS_FetchData, Fid = 2303380852.491776.3263114, Host 192.168.11.201:7001, Id 1001\nSun Aug 29 19:31:39 2021 CheckRights: len=0, for host=192.168.11.201:7001\nSun Aug 29 19:31:39 2021 FetchData_RXStyle: Pos 18446744071815340032, Len 3154\nSun Aug 29 19:31:39 2021 FetchData_RXStyle: file size 2400758866\n...\nSun Aug 29 19:31:40 2021 SRXAFS_FetchData returns 5\n\nNote the file position of 18446744071815340032.  This is the requested file\nposition sign-extended."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47366",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/e66fc460d6dcf85cf12288e133a081205aebcd97",
            "https://git.kernel.org/stable/c/b537a3c21775075395af475dcc6ef212fcf29db8"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nafs: Fix corruption in reads at fpos 2G-4G from an OpenAFS server\n\nAFS-3 has two data fetch RPC variants, FS.FetchData and FS.FetchData64, and\nLinux's afs client switches between them when talking to a non-YFS server\nif the read size, the file position or the sum of the two have the upper 32\nbits set of the 64-bit value.\n\nThis is a problem, however, since the file position and length fields of\nFS.FetchData are *signed* 32-bit values.\n\nFix this by capturing the capability bits obtained from the fileserver when\nit's sent an FS.GetCapabilities RPC, rather than just discarding them, and\nthen picking out the VICED_CAPABILITY_64BITFILES flag.  This can then be\nused to decide whether to use FS.FetchData or FS.FetchData64 - and also\nFS.StoreData or FS.StoreData64 - rather than using upper_32_bits() to\nswitch on the parameter values.\n\nThis capabilities flag could also be used to limit the maximum size of the\nfile, but all servers must be checked for that.\n\nNote that the issue does not exist with FS.StoreData - that uses *unsigned*\n32-bit values.  It's also not a problem with Auristor servers as its\nYFS.FetchData64 op uses unsigned 64-bit values.\n\nThis can be tested by cloning a git repo through an OpenAFS client to an\nOpenAFS server and then doing \"git status\" on it from a Linux afs\nclient[1].  Provided the clone has a pack file that's in the 2G-4G range,\nthe git status will show errors like:\n\n\terror: packfile .git/objects/pack/pack-5e813c51d12b6847bbc0fcd97c2bca66da50079c.pack does not match index\n\terror: packfile .git/objects/pack/pack-5e813c51d12b6847bbc0fcd97c2bca66da50079c.pack does not match index\n\nThis can be observed in the server's FileLog with something like the\nfollowing appearing:\n\nSun Aug 29 19:31:39 2021 SRXAFS_FetchData, Fid = 2303380852.491776.3263114, Host 192.168.11.201:7001, Id 1001\nSun Aug 29 19:31:39 2021 CheckRights: len=0, for host=192.168.11.201:7001\nSun Aug 29 19:31:39 2021 FetchData_RXStyle: Pos 18446744071815340032, Len 3154\nSun Aug 29 19:31:39 2021 FetchData_RXStyle: file size 2400758866\n...\nSun Aug 29 19:31:40 2021 SRXAFS_FetchData returns 5\n\nNote the file position of 18446744071815340032.  This is the requested file\nposition sign-extended."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47336",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/5f9880403e6b71d56924748ba331daf836243fca",
            "https://git.kernel.org/stable/c/5c2dca9a7a7ff6a2df34158903515e2e4fd3d2b2",
            "https://git.kernel.org/stable/c/cbd87ba6a13891acf6180783f8234a8b7a3e3d4d",
            "https://git.kernel.org/stable/c/135122f174c357b7a3e58f40fa5792156c5e93e6",
            "https://git.kernel.org/stable/c/3780348c1a0e14ffefcaf1fc521f815bcaac94b0",
            "https://git.kernel.org/stable/c/8f5c773a2871cf446e3f36b2834fb25bbb28512b",
            "https://git.kernel.org/stable/c/258fd821f69378453c071b9dd767b298810fc766",
            "https://git.kernel.org/stable/c/49ec114a6e62d8d320037ce71c1aaf9650b3cafd"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nsmackfs: restrict bytes count in smk_set_cipso()\n\nOops, I failed to update subject line.\n\nFrom 07571157c91b98ce1a4aa70967531e64b78e8346 Mon Sep 17 00:00:00 2001\nDate: Mon, 12 Apr 2021 22:25:06 +0900\nSubject: [PATCH] smackfs: restrict bytes count in smk_set_cipso()\n\nCommit 7ef4c19d245f3dc2 (\"smackfs: restrict bytes count in smackfs write\nfunctions\") missed that count > SMK_CIPSOMAX check applies to only\nformat == SMK_FIXED24_FMT case."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47368",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/4c4c3052911b577920353a7646e4883d5da40c28",
            "https://git.kernel.org/stable/c/6c3f1b741c6c2914ea120e3a5790d3e900152f7b",
            "https://git.kernel.org/stable/c/6f329d9da2a5ae032fcde800a99b118124ed5270",
            "https://git.kernel.org/stable/c/7237a494decfa17d0b9d0076e6cee3235719de90"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nenetc: Fix illegal access when reading affinity_hint\n\nirq_set_affinity_hit() stores a reference to the cpumask_t\nparameter in the irq descriptor, and that reference can be\naccessed later from irq_affinity_hint_proc_show(). Since\nthe cpu_mask parameter passed to irq_set_affinity_hit() has\nonly temporary storage (it's on the stack memory), later\naccesses to it are illegal. Thus reads from the corresponding\nprocfs affinity_hint file can result in paging request oops.\n\nThe issue is fixed by the get_cpu_mask() helper, which provides\na permanent storage for the cpumask_t parameter."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47368",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/4c4c3052911b577920353a7646e4883d5da40c28",
            "https://git.kernel.org/stable/c/6c3f1b741c6c2914ea120e3a5790d3e900152f7b",
            "https://git.kernel.org/stable/c/6f329d9da2a5ae032fcde800a99b118124ed5270",
            "https://git.kernel.org/stable/c/7237a494decfa17d0b9d0076e6cee3235719de90"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nenetc: Fix illegal access when reading affinity_hint\n\nirq_set_affinity_hit() stores a reference to the cpumask_t\nparameter in the irq descriptor, and that reference can be\naccessed later from irq_affinity_hint_proc_show(). Since\nthe cpu_mask parameter passed to irq_set_affinity_hit() has\nonly temporary storage (it's on the stack memory), later\naccesses to it are illegal. Thus reads from the corresponding\nprocfs affinity_hint file can result in paging request oops.\n\nThe issue is fixed by the get_cpu_mask() helper, which provides\na permanent storage for the cpumask_t parameter."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47367",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/f020bb63b5d2e5576acadd10e158fe3b04af67ba",
            "https://git.kernel.org/stable/c/afd92d82c9d715fb97565408755acad81573591a"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nvirtio-net: fix pages leaking when building skb in big mode\n\nWe try to use build_skb() if we had sufficient tailroom. But we forget\nto release the unused pages chained via private in big mode which will\nleak pages. Fixing this by release the pages after building the skb in\nbig mode."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47371",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/741760fa6252628a3d3afad439b72437d4b123d9",
            "https://git.kernel.org/stable/c/3106a0847525befe3e22fc723909d1b21eb0d520"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnexthop: Fix memory leaks in nexthop notification chain listeners\n\nsyzkaller discovered memory leaks [1] that can be reduced to the\nfollowing commands:\n\n # ip nexthop add id 1 blackhole\n # devlink dev reload pci/0000:06:00.0\n\nAs part of the reload flow, mlxsw will unregister its netdevs and then\nunregister from the nexthop notification chain. Before unregistering\nfrom the notification chain, mlxsw will receive delete notifications for\nnexthop objects using netdevs registered by mlxsw or their uppers. mlxsw\nwill not receive notifications for nexthops using netdevs that are not\ndismantled as part of the reload flow. For example, the blackhole\nnexthop above that internally uses the loopback netdev as its nexthop\ndevice.\n\nOne way to fix this problem is to have listeners flush their nexthop\ntables after unregistering from the notification chain. This is\nerror-prone as evident by this patch and also not symmetric with the\nregistration path where a listener receives a dump of all the existing\nnexthops.\n\nTherefore, fix this problem by replaying delete notifications for the\nlistener being unregistered. This is symmetric to the registration path\nand also consistent with the netdev notification chain.\n\nThe above means that unregister_nexthop_notifier(), like\nregister_nexthop_notifier(), will have to take RTNL in order to iterate\nover the existing nexthops and that any callers of the function cannot\nhold RTNL. This is true for mlxsw and netdevsim, but not for the VXLAN\ndriver. To avoid a deadlock, change the latter to unregister its nexthop\nlistener without holding RTNL, making it symmetric to the registration\npath.\n\n[1]\nunreferenced object 0xffff88806173d600 (size 512):\n  comm \"syz-executor.0\", pid 1290, jiffies 4295583142 (age 143.507s)\n  hex dump (first 32 bytes):\n    41 9d 1e 60 80 88 ff ff 08 d6 73 61 80 88 ff ff  A..`......sa....\n    08 d6 73 61 80 88 ff ff 01 00 00 00 00 00 00 00  ..sa............\n  backtrace:\n    [<ffffffff81a6b576>] kmemleak_alloc_recursive include/linux/kmemleak.h:43 [inline]\n    [<ffffffff81a6b576>] slab_post_alloc_hook+0x96/0x490 mm/slab.h:522\n    [<ffffffff81a716d3>] slab_alloc_node mm/slub.c:3206 [inline]\n    [<ffffffff81a716d3>] slab_alloc mm/slub.c:3214 [inline]\n    [<ffffffff81a716d3>] kmem_cache_alloc_trace+0x163/0x370 mm/slub.c:3231\n    [<ffffffff82e8681a>] kmalloc include/linux/slab.h:591 [inline]\n    [<ffffffff82e8681a>] kzalloc include/linux/slab.h:721 [inline]\n    [<ffffffff82e8681a>] mlxsw_sp_nexthop_obj_group_create drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c:4918 [inline]\n    [<ffffffff82e8681a>] mlxsw_sp_nexthop_obj_new drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c:5054 [inline]\n    [<ffffffff82e8681a>] mlxsw_sp_nexthop_obj_event+0x59a/0x2910 drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c:5239\n    [<ffffffff813ef67d>] notifier_call_chain+0xbd/0x210 kernel/notifier.c:83\n    [<ffffffff813f0662>] blocking_notifier_call_chain kernel/notifier.c:318 [inline]\n    [<ffffffff813f0662>] blocking_notifier_call_chain+0x72/0xa0 kernel/notifier.c:306\n    [<ffffffff8384b9c6>] call_nexthop_notifiers+0x156/0x310 net/ipv4/nexthop.c:244\n    [<ffffffff83852bd8>] insert_nexthop net/ipv4/nexthop.c:2336 [inline]\n    [<ffffffff83852bd8>] nexthop_add net/ipv4/nexthop.c:2644 [inline]\n    [<ffffffff83852bd8>] rtm_new_nexthop+0x14e8/0x4d10 net/ipv4/nexthop.c:2913\n    [<ffffffff833e9a78>] rtnetlink_rcv_msg+0x448/0xbf0 net/core/rtnetlink.c:5572\n    [<ffffffff83608703>] netlink_rcv_skb+0x173/0x480 net/netlink/af_netlink.c:2504\n    [<ffffffff833de032>] rtnetlink_rcv+0x22/0x30 net/core/rtnetlink.c:5590\n    [<ffffffff836069de>] netlink_unicast_kernel net/netlink/af_netlink.c:1314 [inline]\n    [<ffffffff836069de>] netlink_unicast+0x5ae/0x7f0 net/netlink/af_netlink.c:1340\n    [<ffffffff83607501>] netlink_sendmsg+0x8e1/0xe30 net/netlink/af_netlink.c:1929\n    [<ffffffff832fde84>] sock_sendmsg_nosec net/socket.c:704 [inline\n---truncated---"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47246",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/4b16118665e94c90a3e84a5190486fd0e4eedd74",
            "https://git.kernel.org/stable/c/be7f3f401d224e1efe8112b2fa8b837eeb8c5e52",
            "https://git.kernel.org/stable/c/b374c1304f6d3d4752ad1412427b7bf02bb1fd61",
            "https://git.kernel.org/stable/c/a3e5fd9314dfc4314a9567cde96e1aef83a7458a"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet/mlx5e: Fix page reclaim for dead peer hairpin\n\nWhen adding a hairpin flow, a firmware-side send queue is created for\nthe peer net device, which claims some host memory pages for its\ninternal ring buffer. If the peer net device is removed/unbound before\nthe hairpin flow is deleted, then the send queue is not destroyed which\nleads to a stack trace on pci device remove:\n\n[ 748.005230] mlx5_core 0000:08:00.2: wait_func:1094:(pid 12985): MANAGE_PAGES(0x108) timeout. Will cause a leak of a command resource\n[ 748.005231] mlx5_core 0000:08:00.2: reclaim_pages:514:(pid 12985): failed reclaiming pages: err -110\n[ 748.001835] mlx5_core 0000:08:00.2: mlx5_reclaim_root_pages:653:(pid 12985): failed reclaiming pages (-110) for func id 0x0\n[ 748.002171] ------------[ cut here ]------------\n[ 748.001177] FW pages counter is 4 after reclaiming all pages\n[ 748.001186] WARNING: CPU: 1 PID: 12985 at drivers/net/ethernet/mellanox/mlx5/core/pagealloc.c:685 mlx5_reclaim_startup_pages+0x34b/0x460 [mlx5_core]                      [  +0.002771] Modules linked in: cls_flower mlx5_ib mlx5_core ptp pps_core act_mirred sch_ingress openvswitch nsh xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink xt_addrtype iptable_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 br_netfilter rpcrdma rdma_ucm ib_iser libiscsi scsi_transport_iscsi rdma_cm ib_umad ib_ipoib iw_cm ib_cm ib_uverbs ib_core overlay fuse [last unloaded: pps_core]\n[ 748.007225] CPU: 1 PID: 12985 Comm: tee Not tainted 5.12.0+ #1\n[ 748.001376] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\n[ 748.002315] RIP: 0010:mlx5_reclaim_startup_pages+0x34b/0x460 [mlx5_core]\n[ 748.001679] Code: 28 00 00 00 0f 85 22 01 00 00 48 81 c4 b0 00 00 00 31 c0 5b 5d 41 5c 41 5d 41 5e 41 5f c3 48 c7 c7 40 cc 19 a1 e8 9f 71 0e e2 <0f> 0b e9 30 ff ff ff 48 c7 c7 a0 cc 19 a1 e8 8c 71 0e e2 0f 0b e9\n[ 748.003781] RSP: 0018:ffff88815220faf8 EFLAGS: 00010286\n[ 748.001149] RAX: 0000000000000000 RBX: ffff8881b4900280 RCX: 0000000000000000\n[ 748.001445] RDX: 0000000000000027 RSI: 0000000000000004 RDI: ffffed102a441f51\n[ 748.001614] RBP: 00000000000032b9 R08: 0000000000000001 R09: ffffed1054a15ee8\n[ 748.001446] R10: ffff8882a50af73b R11: ffffed1054a15ee7 R12: fffffbfff07c1e30\n[ 748.001447] R13: dffffc0000000000 R14: ffff8881b492cba8 R15: 0000000000000000\n[ 748.001429] FS:  00007f58bd08b580(0000) GS:ffff8882a5080000(0000) knlGS:0000000000000000\n[ 748.001695] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[ 748.001309] CR2: 000055a026351740 CR3: 00000001d3b48006 CR4: 0000000000370ea0\n[ 748.001506] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[ 748.001483] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[ 748.001654] Call Trace:\n[ 748.000576]  ? mlx5_satisfy_startup_pages+0x290/0x290 [mlx5_core]\n[ 748.001416]  ? mlx5_cmd_teardown_hca+0xa2/0xd0 [mlx5_core]\n[ 748.001354]  ? mlx5_cmd_init_hca+0x280/0x280 [mlx5_core]\n[ 748.001203]  mlx5_function_teardown+0x30/0x60 [mlx5_core]\n[ 748.001275]  mlx5_uninit_one+0xa7/0xc0 [mlx5_core]\n[ 748.001200]  remove_one+0x5f/0xc0 [mlx5_core]\n[ 748.001075]  pci_device_remove+0x9f/0x1d0\n[ 748.000833]  device_release_driver_internal+0x1e0/0x490\n[ 748.001207]  unbind_store+0x19f/0x200\n[ 748.000942]  ? sysfs_file_ops+0x170/0x170\n[ 748.001000]  kernfs_fop_write_iter+0x2bc/0x450\n[ 748.000970]  new_sync_write+0x373/0x610\n[ 748.001124]  ? new_sync_read+0x600/0x600\n[ 748.001057]  ? lock_acquire+0x4d6/0x700\n[ 748.000908]  ? lockdep_hardirqs_on_prepare+0x400/0x400\n[ 748.001126]  ? fd_install+0x1c9/0x4d0\n[ 748.000951]  vfs_write+0x4d0/0x800\n[ 748.000804]  ksys_write+0xf9/0x1d0\n[ 748.000868]  ? __x64_sys_read+0xb0/0xb0\n[ 748.000811]  ? filp_open+0x50/0x50\n[ 748.000919]  ? syscall_enter_from_user_mode+0x1d/0x50\n[ 748.001223]  do_syscall_64+0x3f/0x80\n[ 748.000892]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n[ 748.00\n---truncated---"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47252",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/45011f2973f6b52cf50db397bb27bf805f5f0e7f",
            "https://git.kernel.org/stable/c/6031daaaf6d5c359c99dfffa102e332df234ff09",
            "https://git.kernel.org/stable/c/77a99aad5bc3ea105806ebae6be3cbadc2fc615e",
            "https://git.kernel.org/stable/c/e8e9d2968a9d08bf5c683afca182f1537edebf8d",
            "https://git.kernel.org/stable/c/e7fbd8184fa9e85f0d648c499841cb7ff6dec9f4",
            "https://git.kernel.org/stable/c/282baa8104af44e04c4af3e7f933b44267c7f86f",
            "https://git.kernel.org/stable/c/2eb4e0b3631832a4291c8bf4c9db873f60b128c8",
            "https://git.kernel.org/stable/c/9f460ae31c4435fd022c443a6029352217a16ac1"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nbatman-adv: Avoid WARN_ON timing related checks\n\nThe soft/batadv interface for a queued OGM can be changed during the time\nthe OGM was queued for transmission and when the OGM is actually\ntransmitted by the worker.\n\nBut WARN_ON must be used to denote kernel bugs and not to print simple\nwarnings. A warning can simply be printed using pr_warn."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47377",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/c5d5a43dd2b649a0a290bfed00fb76d1aff89be6",
            "https://git.kernel.org/stable/c/6bba79c6a073741b672b0bf86a1f03c0fe47f973",
            "https://git.kernel.org/stable/c/29917bbb07c30be295dece245c7c21872e1a6fbb",
            "https://git.kernel.org/stable/c/372d3e6ea1e115942fdfb4b25f7003d822d071be",
            "https://git.kernel.org/stable/c/922fd5b6bb13ad31ff36e86e2eba2f26d8135272",
            "https://git.kernel.org/stable/c/8480ed9c2bbd56fc86524998e5f2e3e22f5038f6"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nxen/balloon: use a kernel thread instead a workqueue\n\nToday the Xen ballooning is done via delayed work in a workqueue. This\nmight result in workqueue hangups being reported in case of large\namounts of memory are being ballooned in one go (here 16GB):\n\nBUG: workqueue lockup - pool cpus=6 node=0 flags=0x0 nice=0 stuck for 64s!\nShowing busy workqueues and worker pools:\nworkqueue events: flags=0x0\n  pwq 12: cpus=6 node=0 flags=0x0 nice=0 active=2/256 refcnt=3\n    in-flight: 229:balloon_process\n    pending: cache_reap\nworkqueue events_freezable_power_: flags=0x84\n  pwq 12: cpus=6 node=0 flags=0x0 nice=0 active=1/256 refcnt=2\n    pending: disk_events_workfn\nworkqueue mm_percpu_wq: flags=0x8\n  pwq 12: cpus=6 node=0 flags=0x0 nice=0 active=1/256 refcnt=2\n    pending: vmstat_update\npool 12: cpus=6 node=0 flags=0x0 nice=0 hung=64s workers=3 idle: 2222 43\n\nThis can easily be avoided by using a dedicated kernel thread for doing\nthe ballooning work."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47253",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/9e8c2af010463197315fa54a6c17e74988b5259c",
            "https://git.kernel.org/stable/c/aa000f828e60ac15d6340f606ec4a673966f5b0b",
            "https://git.kernel.org/stable/c/c5699e2d863f58221044efdc3fa712dd32d55cde"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amd/display: Fix potential memory leak in DMUB hw_init\n\n[Why]\nOn resume we perform DMUB hw_init which allocates memory:\ndm_resume->dm_dmub_hw_init->dc_dmub_srv_create->kzalloc\nThat results in memory leak in suspend/resume scenarios.\n\n[How]\nAllocate memory for the DC wrapper to DMUB only if it was not\nallocated before.\nNo need to reallocate it on suspend/resume."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47341",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/f2ff9d03432fcb160e9f7d4be26174d89de2779a",
            "https://git.kernel.org/stable/c/679837dc0abaa2c6e2a7bcd86483e05eee1d5066",
            "https://git.kernel.org/stable/c/8d7c539316d652d217e5e82b89ee204c812a7061",
            "https://git.kernel.org/stable/c/069d44a24c0ff8f85adf49233aae7a8ca16f5c7e",
            "https://git.kernel.org/stable/c/23fa2e46a5556f787ce2ea1a315d3ab93cced204"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: mmio: Fix use-after-free Read in kvm_vm_ioctl_unregister_coalesced_mmio\n\nBUG: KASAN: use-after-free in kvm_vm_ioctl_unregister_coalesced_mmio+0x7c/0x1ec arch/arm64/kvm/../../../virt/kvm/coalesced_mmio.c:183\nRead of size 8 at addr ffff0000c03a2500 by task syz-executor083/4269\n\nCPU: 5 PID: 4269 Comm: syz-executor083 Not tainted 5.10.0 #7\nHardware name: linux,dummy-virt (DT)\nCall trace:\n dump_backtrace+0x0/0x2d0 arch/arm64/kernel/stacktrace.c:132\n show_stack+0x28/0x34 arch/arm64/kernel/stacktrace.c:196\n __dump_stack lib/dump_stack.c:77 [inline]\n dump_stack+0x110/0x164 lib/dump_stack.c:118\n print_address_description+0x78/0x5c8 mm/kasan/report.c:385\n __kasan_report mm/kasan/report.c:545 [inline]\n kasan_report+0x148/0x1e4 mm/kasan/report.c:562\n check_memory_region_inline mm/kasan/generic.c:183 [inline]\n __asan_load8+0xb4/0xbc mm/kasan/generic.c:252\n kvm_vm_ioctl_unregister_coalesced_mmio+0x7c/0x1ec arch/arm64/kvm/../../../virt/kvm/coalesced_mmio.c:183\n kvm_vm_ioctl+0xe30/0x14c4 arch/arm64/kvm/../../../virt/kvm/kvm_main.c:3755\n vfs_ioctl fs/ioctl.c:48 [inline]\n __do_sys_ioctl fs/ioctl.c:753 [inline]\n __se_sys_ioctl fs/ioctl.c:739 [inline]\n __arm64_sys_ioctl+0xf88/0x131c fs/ioctl.c:739\n __invoke_syscall arch/arm64/kernel/syscall.c:36 [inline]\n invoke_syscall arch/arm64/kernel/syscall.c:48 [inline]\n el0_svc_common arch/arm64/kernel/syscall.c:158 [inline]\n do_el0_svc+0x120/0x290 arch/arm64/kernel/syscall.c:220\n el0_svc+0x1c/0x28 arch/arm64/kernel/entry-common.c:367\n el0_sync_handler+0x98/0x170 arch/arm64/kernel/entry-common.c:383\n el0_sync+0x140/0x180 arch/arm64/kernel/entry.S:670\n\nAllocated by task 4269:\n stack_trace_save+0x80/0xb8 kernel/stacktrace.c:121\n kasan_save_stack mm/kasan/common.c:48 [inline]\n kasan_set_track mm/kasan/common.c:56 [inline]\n __kasan_kmalloc+0xdc/0x120 mm/kasan/common.c:461\n kasan_kmalloc+0xc/0x14 mm/kasan/common.c:475\n kmem_cache_alloc_trace include/linux/slab.h:450 [inline]\n kmalloc include/linux/slab.h:552 [inline]\n kzalloc include/linux/slab.h:664 [inline]\n kvm_vm_ioctl_register_coalesced_mmio+0x78/0x1cc arch/arm64/kvm/../../../virt/kvm/coalesced_mmio.c:146\n kvm_vm_ioctl+0x7e8/0x14c4 arch/arm64/kvm/../../../virt/kvm/kvm_main.c:3746\n vfs_ioctl fs/ioctl.c:48 [inline]\n __do_sys_ioctl fs/ioctl.c:753 [inline]\n __se_sys_ioctl fs/ioctl.c:739 [inline]\n __arm64_sys_ioctl+0xf88/0x131c fs/ioctl.c:739\n __invoke_syscall arch/arm64/kernel/syscall.c:36 [inline]\n invoke_syscall arch/arm64/kernel/syscall.c:48 [inline]\n el0_svc_common arch/arm64/kernel/syscall.c:158 [inline]\n do_el0_svc+0x120/0x290 arch/arm64/kernel/syscall.c:220\n el0_svc+0x1c/0x28 arch/arm64/kernel/entry-common.c:367\n el0_sync_handler+0x98/0x170 arch/arm64/kernel/entry-common.c:383\n el0_sync+0x140/0x180 arch/arm64/kernel/entry.S:670\n\nFreed by task 4269:\n stack_trace_save+0x80/0xb8 kernel/stacktrace.c:121\n kasan_save_stack mm/kasan/common.c:48 [inline]\n kasan_set_track+0x38/0x6c mm/kasan/common.c:56\n kasan_set_free_info+0x20/0x40 mm/kasan/generic.c:355\n __kasan_slab_free+0x124/0x150 mm/kasan/common.c:422\n kasan_slab_free+0x10/0x1c mm/kasan/common.c:431\n slab_free_hook mm/slub.c:1544 [inline]\n slab_free_freelist_hook mm/slub.c:1577 [inline]\n slab_free mm/slub.c:3142 [inline]\n kfree+0x104/0x38c mm/slub.c:4124\n coalesced_mmio_destructor+0x94/0xa4 arch/arm64/kvm/../../../virt/kvm/coalesced_mmio.c:102\n kvm_iodevice_destructor include/kvm/iodev.h:61 [inline]\n kvm_io_bus_unregister_dev+0x248/0x280 arch/arm64/kvm/../../../virt/kvm/kvm_main.c:4374\n kvm_vm_ioctl_unregister_coalesced_mmio+0x158/0x1ec arch/arm64/kvm/../../../virt/kvm/coalesced_mmio.c:186\n kvm_vm_ioctl+0xe30/0x14c4 arch/arm64/kvm/../../../virt/kvm/kvm_main.c:3755\n vfs_ioctl fs/ioctl.c:48 [inline]\n __do_sys_ioctl fs/ioctl.c:753 [inline]\n __se_sys_ioctl fs/ioctl.c:739 [inline]\n __arm64_sys_ioctl+0xf88/0x131c fs/ioctl.c:739\n __invoke_syscall arch/arm64/kernel/syscall.c:36 [inline]\n invoke_syscall arch/arm64/kernel/sys\n---truncated---"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47378",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/ecf0dc5a904830c926a64feffd8e01141f89822f",
            "https://git.kernel.org/stable/c/d268a182c56e8361e19fb781137411643312b994",
            "https://git.kernel.org/stable/c/9817d763dbe15327b9b3ff4404fa6f27f927e744"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nnvme-rdma: destroy cm id before destroy qp to avoid use after free\n\nWe should always destroy cm_id before destroy qp to avoid to get cma\nevent after qp was destroyed, which may lead to use after free.\nIn RDMA connection establishment error flow, don't destroy qp in cm\nevent handler.Just report cm_error to upper level, qp will be destroy\nin nvme_rdma_alloc_queue() after destroy cm id."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47260",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/fab8bfdfb4aac9e4e8363666333adfdf21e89106",
            "https://git.kernel.org/stable/c/a979e601000982a3ca693171a6d4dffc47f8ad00",
            "https://git.kernel.org/stable/c/634f17ff1d59905eb3b4bbbc00805961d08beaee",
            "https://git.kernel.org/stable/c/4b380a7d84ef2ce3f4f5bec5d8706ed937ac6502",
            "https://git.kernel.org/stable/c/0057ecef9f324007c0ba5fcca4ddd131178ce78b",
            "https://git.kernel.org/stable/c/279ad78a00f8b9c5ff24171a59297187a3bd44b7",
            "https://git.kernel.org/stable/c/58ddf61f10b8f9b7b1341644bfee2f1c6508d4e1",
            "https://git.kernel.org/stable/c/09226e8303beeec10f2ff844d2e46d1371dc58e0"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nNFS: Fix a potential NULL dereference in nfs_get_client()\n\nNone of the callers are expecting NULL returns from nfs_get_client() so\nthis code will lead to an Oops.  It's better to return an error\npointer.  I expect that this is dead code so hopefully no one is\naffected."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47370",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/f8ff625a8082db8c2b58dcb5229b27928943b94b",
            "https://git.kernel.org/stable/c/977d293e23b48a1129830d7968605f61c4af71a0"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nmptcp: ensure tx skbs always have the MPTCP ext\n\nDue to signed/unsigned comparison, the expression:\n\n\tinfo->size_goal - skb->len > 0\n\nevaluates to true when the size goal is smaller than the\nskb size. That results in lack of tx cache refill, so that\nthe skb allocated by the core TCP code lacks the required\nMPTCP skb extensions.\n\nDue to the above, syzbot is able to trigger the following WARN_ON():\n\nWARNING: CPU: 1 PID: 810 at net/mptcp/protocol.c:1366 mptcp_sendmsg_frag+0x1362/0x1bc0 net/mptcp/protocol.c:1366\nModules linked in:\nCPU: 1 PID: 810 Comm: syz-executor.4 Not tainted 5.14.0-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\nRIP: 0010:mptcp_sendmsg_frag+0x1362/0x1bc0 net/mptcp/protocol.c:1366\nCode: ff 4c 8b 74 24 50 48 8b 5c 24 58 e9 0f fb ff ff e8 13 44 8b f8 4c 89 e7 45 31 ed e8 98 57 2e fe e9 81 f4 ff ff e8 fe 43 8b f8 <0f> 0b 41 bd ea ff ff ff e9 6f f4 ff ff 4c 89 e7 e8 b9 8e d2 f8 e9\nRSP: 0018:ffffc9000531f6a0 EFLAGS: 00010216\nRAX: 000000000000697f RBX: 0000000000000000 RCX: ffffc90012107000\nRDX: 0000000000040000 RSI: ffffffff88eac9e2 RDI: 0000000000000003\nRBP: ffff888078b15780 R08: 0000000000000000 R09: 0000000000000000\nR10: ffffffff88eac017 R11: 0000000000000000 R12: ffff88801de0a280\nR13: 0000000000006b58 R14: ffff888066278280 R15: ffff88803c2fe9c0\nFS:  00007fd9f866e700(0000) GS:ffff8880b9d00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007faebcb2f718 CR3: 00000000267cb000 CR4: 00000000001506e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n __mptcp_push_pending+0x1fb/0x6b0 net/mptcp/protocol.c:1547\n mptcp_release_cb+0xfe/0x210 net/mptcp/protocol.c:3003\n release_sock+0xb4/0x1b0 net/core/sock.c:3206\n sk_stream_wait_memory+0x604/0xed0 net/core/stream.c:145\n mptcp_sendmsg+0xc39/0x1bc0 net/mptcp/protocol.c:1749\n inet6_sendmsg+0x99/0xe0 net/ipv6/af_inet6.c:643\n sock_sendmsg_nosec net/socket.c:704 [inline]\n sock_sendmsg+0xcf/0x120 net/socket.c:724\n sock_write_iter+0x2a0/0x3e0 net/socket.c:1057\n call_write_iter include/linux/fs.h:2163 [inline]\n new_sync_write+0x40b/0x640 fs/read_write.c:507\n vfs_write+0x7cf/0xae0 fs/read_write.c:594\n ksys_write+0x1ee/0x250 fs/read_write.c:647\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x44/0xae\nRIP: 0033:0x4665f9\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007fd9f866e188 EFLAGS: 00000246 ORIG_RAX: 0000000000000001\nRAX: ffffffffffffffda RBX: 000000000056c038 RCX: 00000000004665f9\nRDX: 00000000000e7b78 RSI: 0000000020000000 RDI: 0000000000000003\nRBP: 00000000004bfcc4 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 000000000056c038\nR13: 0000000000a9fb1f R14: 00007fd9f866e300 R15: 0000000000022000\n\nFix the issue rewriting the relevant expression to avoid\nsign-related problems - note: size_goal is always >= 0.\n\nAdditionally, ensure that the skb in the tx cache always carries\nthe relevant extension."
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47379",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/d12ddd843f1877de1f7dd2aeea4907cf9ff3ac08",
            "https://git.kernel.org/stable/c/f58d305887ad7b24986d58e881f6806bb81b2bdf",
            "https://git.kernel.org/stable/c/7c2c69e010431b0157c9454adcdd2305809bf9fb",
            "https://git.kernel.org/stable/c/858560b27645e7e97aca37ee8f232cccd658fbd2"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nblk-cgroup: fix UAF by grabbing blkcg lock before destroying blkg pd\n\nKASAN reports a use-after-free report when doing fuzz test:\n\n[693354.104835] ==================================================================\n[693354.105094] BUG: KASAN: use-after-free in bfq_io_set_weight_legacy+0xd3/0x160\n[693354.105336] Read of size 4 at addr ffff888be0a35664 by task sh/1453338\n\n[693354.105607] CPU: 41 PID: 1453338 Comm: sh Kdump: loaded Not tainted 4.18.0-147\n[693354.105610] Hardware name: Huawei 2288H V5/BC11SPSCB0, BIOS 0.81 07/02/2018\n[693354.105612] Call Trace:\n[693354.105621]  dump_stack+0xf1/0x19b\n[693354.105626]  ? show_regs_print_info+0x5/0x5\n[693354.105634]  ? printk+0x9c/0xc3\n[693354.105638]  ? cpumask_weight+0x1f/0x1f\n[693354.105648]  print_address_description+0x70/0x360\n[693354.105654]  kasan_report+0x1b2/0x330\n[693354.105659]  ? bfq_io_set_weight_legacy+0xd3/0x160\n[693354.105665]  ? bfq_io_set_weight_legacy+0xd3/0x160\n[693354.105670]  bfq_io_set_weight_legacy+0xd3/0x160\n[693354.105675]  ? bfq_cpd_init+0x20/0x20\n[693354.105683]  cgroup_file_write+0x3aa/0x510\n[693354.105693]  ? ___slab_alloc+0x507/0x540\n[693354.105698]  ? cgroup_file_poll+0x60/0x60\n[693354.105702]  ? 0xffffffff89600000\n[693354.105708]  ? usercopy_abort+0x90/0x90\n[693354.105716]  ? mutex_lock+0xef/0x180\n[693354.105726]  kernfs_fop_write+0x1ab/0x280\n[693354.105732]  ? cgroup_file_poll+0x60/0x60\n[693354.105738]  vfs_write+0xe7/0x230\n[693354.105744]  ksys_write+0xb0/0x140\n[693354.105749]  ? __ia32_sys_read+0x50/0x50\n[693354.105760]  do_syscall_64+0x112/0x370\n[693354.105766]  ? syscall_return_slowpath+0x260/0x260\n[693354.105772]  ? do_page_fault+0x9b/0x270\n[693354.105779]  ? prepare_exit_to_usermode+0xf9/0x1a0\n[693354.105784]  ? enter_from_user_mode+0x30/0x30\n[693354.105793]  entry_SYSCALL_64_after_hwframe+0x65/0xca\n\n[693354.105875] Allocated by task 1453337:\n[693354.106001]  kasan_kmalloc+0xa0/0xd0\n[693354.106006]  kmem_cache_alloc_node_trace+0x108/0x220\n[693354.106010]  bfq_pd_alloc+0x96/0x120\n[693354.106015]  blkcg_activate_policy+0x1b7/0x2b0\n[693354.106020]  bfq_create_group_hierarchy+0x1e/0x80\n[693354.106026]  bfq_init_queue+0x678/0x8c0\n[693354.106031]  blk_mq_init_sched+0x1f8/0x460\n[693354.106037]  elevator_switch_mq+0xe1/0x240\n[693354.106041]  elevator_switch+0x25/0x40\n[693354.106045]  elv_iosched_store+0x1a1/0x230\n[693354.106049]  queue_attr_store+0x78/0xb0\n[693354.106053]  kernfs_fop_write+0x1ab/0x280\n[693354.106056]  vfs_write+0xe7/0x230\n[693354.106060]  ksys_write+0xb0/0x140\n[693354.106064]  do_syscall_64+0x112/0x370\n[693354.106069]  entry_SYSCALL_64_after_hwframe+0x65/0xca\n\n[693354.106114] Freed by task 1453336:\n[693354.106225]  __kasan_slab_free+0x130/0x180\n[693354.106229]  kfree+0x90/0x1b0\n[693354.106233]  blkcg_deactivate_policy+0x12c/0x220\n[693354.106238]  bfq_exit_queue+0xf5/0x110\n[693354.106241]  blk_mq_exit_sched+0x104/0x130\n[693354.106245]  __elevator_exit+0x45/0x60\n[693354.106249]  elevator_switch_mq+0xd6/0x240\n[693354.106253]  elevator_switch+0x25/0x40\n[693354.106257]  elv_iosched_store+0x1a1/0x230\n[693354.106261]  queue_attr_store+0x78/0xb0\n[693354.106264]  kernfs_fop_write+0x1ab/0x280\n[693354.106268]  vfs_write+0xe7/0x230\n[693354.106271]  ksys_write+0xb0/0x140\n[693354.106275]  do_syscall_64+0x112/0x370\n[693354.106280]  entry_SYSCALL_64_after_hwframe+0x65/0xca\n\n[693354.106329] The buggy address belongs to the object at ffff888be0a35580\n                 which belongs to the cache kmalloc-1k of size 1024\n[693354.106736] The buggy address is located 228 bytes inside of\n                 1024-byte region [ffff888be0a35580, ffff888be0a35980)\n[693354.107114] The buggy address belongs to the page:\n[693354.107273] page:ffffea002f828c00 count:1 mapcount:0 mapping:ffff888107c17080 index:0x0 compound_mapcount: 0\n[693354.107606] flags: 0x17ffffc0008100(slab|head)\n[693354.107760] raw: 0017ffffc0008100 ffffea002fcbc808 ffffea0030bd3a08 ffff888107c17080\n[693354.108020] r\n---truncated---"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47263",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/e0b518a2eb44d8a74c19e50f79a8ed393e96d634",
            "https://git.kernel.org/stable/c/dd55331d493b7ea75c5db1f24d6822946fde2862",
            "https://git.kernel.org/stable/c/dbec64b11c65d74f31427e2b9d5746fbf17bf840"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\ngpio: wcd934x: Fix shift-out-of-bounds error\n\nbit-mask for pins 0 to 4 is BIT(0) to BIT(4) however we ended up with BIT(n - 1)\nwhich is not right, and this was caught by below usban check\n\nUBSAN: shift-out-of-bounds in drivers/gpio/gpio-wcd934x.c:34:14"
    },
    {
        "Modified": "2024-05-21T15:15:00",
        "Published": "2024-05-21T15:15:00",
        "access": {},
        "assigner": "cve@kernel.org",
        "cvss": null,
        "cwe": "Unknown",
        "id": "CVE-2021-47373",
        "impact": {},
        "last-modified": "2024-05-21T15:15:00",
        "references": [
            "https://git.kernel.org/stable/c/7d39992d45acd6f2d6b2f62389c55b61fb3d486b",
            "https://git.kernel.org/stable/c/5701e8bff314c155e7afdc467b1e0389d86853d0",
            "https://git.kernel.org/stable/c/42d3711c23781045e7a5cd28536c774b9a66d20b",
            "https://git.kernel.org/stable/c/568662e37f927e3dc3e475f3ff7cf4ab7719c5e7",
            "https://git.kernel.org/stable/c/e0c1c2e5da19685a20557a50f10c6aa4fa26aa84",
            "https://git.kernel.org/stable/c/280bef512933b2dda01d681d8cbe499b98fc5bdd"
        ],
        "summary": "In the Linux kernel, the following vulnerability has been resolved:\n\nirqchip/gic-v3-its: Fix potential VPE leak on error\n\nIn its_vpe_irq_domain_alloc, when its_vpe_init() returns an error,\nthere is an off-by-one in the number of VPEs to be freed.\n\nFix it by simply passing the number of VPEs allocated, which is the\nindex of the loop iterating over the VPEs.\n\n[maz: fixed commit message]"
    }
]